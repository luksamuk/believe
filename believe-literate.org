#+TITLE:    Believe: A Bel interpreter built with C11 [Beta]
#+AUTHOR:   Lucas Vieira
#+EMAIL:    lucasvieira@protonmail.com
# #+DATE:     2019
#+PROPERTY: header-args:C :eval no :main no :tangle believe.c
#+STARTUP:  content

:LATEX_PROPERTIES:
# Evaluate this block to use a book which starts with chapters instead
# of parts.

#+begin_src emacs-lisp :tangle no :eval yes :results silent :exports none
(add-to-list 'org-latex-classes
             '("book-noparts"
               "\\documentclass{book}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src

# Preamble
# #+LATEX_CLASS: article
#+LATEX_CLASS: book-noparts
#+LATEX_CLASS_OPTIONS: [a4paper,twoside]
#+LATEX_HEADER: \usepackage[brazil]{babel}
#+LATEX_HEADER: \usepackage{times}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{microtype}
#+LATEX_HEADER: \usepackage{titlesec}
#+LATEX_HEADER: \usepackage[brazilian, hyperpageref]{backref}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage[alf,abnt-emphasize=bf,abnt-doi=link]{abntex2cite}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{draftwatermark}

# Remove colorization of links
#+LATEX_HEADER: \definecolor{blue}{RGB}{41,5,195}
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \hypersetup{
# #+LATEX_HEADER:     pdftitle={%t},
# #+LATEX_HEADER:     pdfauthor={%a},
# #+LATEX_HEADER:     pdfkeywords={%k},
# #+LATEX_HEADER:     pdfsubject={%d},
# #+LATEX_HEADER:     pdfcreator={%c},
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     linkcolor=black,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     filecolor=black,
#+LATEX_HEADER:     urlcolor=blue,
#+LATEX_HEADER:     bookmarksdepth=4
#+LATEX_HEADER: }
#+LATEX_HEADER: \makeatother
#+BIND: org-latex-hyperref-template ""

# Make watermark softer
#+LATEX_HEADER: \SetWatermarkLightness{0.85}
:END:

* Introduction

The goal of this project is to provide a fully-functioning
implementation of the Bel language, proposed by Paul Graham. The main
goal is not to provide performance; instead, it is supposed to be a
didatic approach to implementing a Lisp interpreter.

The code here contained is also a study on how to build a Lisp
interpreter from scratch in C. Given that Bel is so simple and is
supposed to be a formalism before a commercial language, it seems like
the perfect didatic resource to do so.

Here are some useful links with language resources:

- [[http://paulgraham.com/bel.html][Paul Graham's Bel release website]]
- [[https://sep.yimg.com/ty/cdn/paulgraham/bellanguage.txt?t=1570993483&][Language Guide]]
- [[https://sep.yimg.com/ty/cdn/paulgraham/bel.bel?t=1570993483&][Language Source Code, written in Bel itself]]
- [[https://sep.yimg.com/ty/cdn/paulgraham/belexamples.txt?t=1570993483&][Bel examples]]

Note that *this software is still a work-in-progress. Do not expect it to work
fully yet.*

** About literate programming

#+TODO: Lacks references! Use Org-ref for that!
This interpreter is built using [[https://orgmode.org/][Org with Org-mode in Emacs]]. Its
website specifies that Org is "a format for keeping notes, maintaining
TODO lists, planning projects, and authoring documents with a fast and
effective plain-text system".

All the code here appears in the order it is written on the actual
code files. By using [[http://www.literateprogramming.com/knuthweb.pdf][Donald Knuth's concept of literate programming]],
the relevant code blocks are /tangled/ and written in their specified
code files, and then the application can be compiled.

By using this approach, I hope to maintain an application where the
understanding of what is being written comes before the code itself,
so that the reader is able to take and analyse parts of said code
based on the prose that accompanies it.

** Licenses
*** Prose license

This work is licensed under a [[http://creativecommons.org/licenses/by-sa/4.0/][Creative Commons Attribution-ShareAlike
4.0 International License]]. This means that you are free to:

- *Share*: copy and redistribute the material in any medium or format
- *Adapt*: remix, transform, and build upon the material for any
  purpose, even commercially.

But only if you follow the terms below:

- *Attribution*: You must give appropriate credit[fn:1], provide a link to the
  license, and indicate if changes were made[fn:2]. You may do so in any
  reasonable manner, but not in any way that suggests the licensor
  endorses you or your use.
- *ShareAlike*: If you remix, transform, or build upon the material, you
  must distribute your contributions under the same license[fn:3] as the
  original.


See the link for more information.

#+ATTR_LATEX: :width .2\textwidth
[[file:images/cc-by-sa.png]]

*** Software license

This is a verbatim copy of the software's license file.

#+begin_src text :tangle LICENSE
MIT License

Copyright (c) 2019 Lucas Vieira

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
#+end_src

* Acknowledgements

This is an open-source project which anyone can contribute to. I'd
like to thank the people who helped me so far with this project. Here
is a list of them.

- Carl Mäsak ([[https://github.com/masak][github.com/masak]])

* COMMENT TO-DO list
** Roadmap
- [x] Data types
  - [x] Symbols
  - [x] Pairs
    - [x] Lists
  - [x] Characters
  - [x] Strings
  - [x] Numbers (opaque; general type only)
    - [x] Integers
    - [x] Float
    - [x] Fractions
    - [x] Complex
- [x] Literals
  - [x] Primitives (representation)
- [x] Environments
  - [x] Environment hierarchy (dyn > lex > glo) [implemented on
    lookup]
  - [ ] Dynamic binding (visible everywhere for short time)
  - [x] Hierarchical lookup (=bel_lookup=)
- [x] Functions
  - [x] Lexical bindings
- [ ] Evaluation [wip]
  - [x] Eval [wip]
    - [ ] Special forms [wip]
      - [x] =quote=
      - [x] =lit=
        - [x] =fn=   => literal closure
      - [x] =if=
      - [ ] =apply=
      - [x] =join=
      - [ ] =where=  => not so straightforward
      - [ ] =dyn=
      - [ ] =after=
      - [ ] =ccc=    => Later?
      - [ ] =thread= => Later?
      - [ ] =set=    => global binding
  - [x] Apply
  
** On-the-fly checklist
- [x] Environment functions
- [x] Global environment object =globe=
- [x] Various necessary predicates
  - [x] =stringp= predicate
- [x] Error object
- [x] String printing
- [x] Test for errors on core functions
- [x] Dynamic environment
- [x] Assignments/Unassignments
- [x] =err= primitive function, basic error handling
- [x] Use =BEL_DEBUG= flag everywhere!
- [x] Move debug printing functions to actual printing behaviour
- [x] Prototype evaluator
- [ ] Proper error propagation
- [ ] Add proper references with Org-ref and bibtex
- [ ] Lexical environment object =scope=, shadowable, not unique (is it
  necessary?)
- [ ] Prevent circular printing. Particularly useful for environments
  and closures

* Tools and scripts
** Makefile

This software was primarily developed on Void Linux x86_64, using the
Clang compiler. The following Makefile is the one used for building
Believe.

#+begin_src makefile :tangle Makefile
CC     = clang
CFLAGS = --std=c11 -g -O2 -Wall -DBEL_DEBUG
CLIBS  = -lgc -lm
BIN    = believe
OBJ    = believe.o

.PHONY: clean

$(BIN): $(OBJ)
	$(CC) $(CFLAGS) $(CLIBS) -o $@ $^

%.o: %.c
	$(CC) $(CFLAGS) -c -o $@ $^

clean:
	rm -rf *.o $(BIN)
#+end_src

** Memory leak testing

This script generates a log file with memory leak information using
Valgrind. Valgrind's output is stored in =believe.log=.

#+begin_src bash :results silent :tangle no
valgrind --check_leaks=full --log-file="believe.log" -v ./believe
#+end_src

** Tangling

The following snippet can be run from Emacs to enable tangling on save
for this file only.

Tangling is the process of taking each block of code and adding it to
its specific file. Believe's code will be written in C source files;
the Makefile will be written in its own file; and so on. Notice that
some blocks (like this one) is not written anywhere, and is meant to
be evaluated from inside Emacs.

#+begin_src emacs-lisp :tangle no :exports none :results silent
(let ((orig-lex-bind lexical-binding))
  (setq lexical-binding t)
  (add-hook 'after-save-hook 'org-babel-tangle)
  (setq lexical-binding orig-lex-bind))
#+end_src

** Running the program

This script attempts to build and run the Bel interpreter. It will
also enable verbose output for the garbage collector.

#+begin_src bash :tangle run.sh :eval no :cache yes :results silent :exports code
make
export GC_PRINT_STATS=1
./believe
#+end_src

* Libraries and headers

** Default headers

We'll be using =stdio.h= for default console I/O, plus =stdint.h= for some
standard integer types. =string.h= provides definitions to handle string
manipulation on the C side, however Bel is supposed to have its own
string representation, to be discussed later. =errno.h= is used to fetch
error strings from streams, for example; and =math.h= is useful for math
operations.

#+begin_src C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <math.h>
#+end_src

** Definitions

We'll use a flag for debug which influences the building
process. Let's call this flag =BEL_DEBUG=.

When building, if you pass this flag to Clang (see the Makefile), some
debug outputs will be available.

By default we'll leave it on, at least for now.

Let's also add a modest copyright notice to the program's header.

#+begin_src C
/* Believe v0.2                                           *
 ,* A Bel Lisp interpreter.                                *
 ,* Copyright (c) 2019 Lucas Vieira.                       *
 ,* This program is distributed under the MIT License. See *
 ,* the LICENSE file for details.                          *
 ,*                                                        *
 ,* Development information can also be consulted on the   *
 ,* book which accompanies this software, which was        * 
 ,* written in literate programming form. For more         *
 ,* information, see https://github.com/luksamuk/believe.  */
#+end_src

** Boehm-Demers-Weiser Garbage Collector

We also use Boehm-Demers-Weiser GC for garbage collection, instead of
programming our own. The =GC_DEBUG= flag helps on debugging. See that we
use =-lgc= on the Makefile to link the relevant library to the
application.

#+begin_src C
#ifdef BEL_DEBUG
#define GC_DEBUG
#endif

#include <gc.h>
#+end_src

Plus, [[https://www.hboehm.info/gc/04tutorial.pdf][one could check the Boehm-Demers-Weiser GC tutorial slides]] by
Hans-J. Boehm, for a quick overview of this library.

#+TODO: Use GC_REGISTER_FINALIZER for streams... if convenient.

** Software-related definitions

These definitions relate to program metadata which is going to be
displayed on its startup.

#+begin_src C
#define BELIEVE_VERSION   "0.2"
#define BELIEVE_COPYRIGHT "2019 Lucas Vieira"
#define BELIEVE_LICENSE   "MIT"
#+end_src

* Fundamental data types

The first thing to do is specify how the data is going to be handled
by the interpreter. Here, we define each of these kinds of data. Any
procedure for data manipulation will be defined afterwards.

** Enumerating Bel types

We begin by specifying all data types, which Bel has four: symbols,
pairs, characters and streams. We also add a number type, which is
non-standard, but will be useful; this decision will be explained in
its section.

#+begin_src C
typedef enum
{
    BEL_SYMBOL,
    BEL_PAIR,
    BEL_CHAR,
    BEL_STREAM,
    BEL_NUMBER
} BEL_TYPE;
#+end_src

** Pair

A pair can have two things, which can in return be one of the four
data types themselves. Since this is sort of a recursive definition,
we need to make a forward declaration of the general =Bel= type, which
encloses all four data types.

#+begin_src C
typedef struct BEL Bel; // Forward declaration

typedef struct
{
    Bel *car;
    Bel *cdr;
} Bel_pair;
#+end_src

** Character

A character is nothing but an integer in standard C. For now we'll
support only ASCII, so there is no actual need to instantiate the
proposed table of characters -- this might change in the future.

We say that a character is nothing but a signed 8-bit integer. Should
be enough for now.

#+begin_src C
typedef int8_t Bel_char;
#+end_src

** Symbol

A symbol is nothing but a specific index on the symbol table, so
that's how we'll define it.

#+begin_src C
typedef uint64_t Bel_sym;
#+end_src

** Stream

The stream type is somewhat implementation-dependent. In C, a standard
way to refer to streams is to use a =FILE= pointer, since =stdout= and
=stdin= themselves are of such type. So we just wrap these pointers in
a stream type.

Plus, as per Bel's specification, a stream has three statuses: closed,
open for reading, open for writing. Therefore, we use a single
enumeration to represent these three states.

Since Bel's specification writes to a stream bit by bit, we need to
cache the currently filled byte inside the structure, from left to
right, dumping each byte as it is filled. Upon closing, the stream
shall write the cache at the end of the file, plus the incomplete
remaining bits. A "new" (not written and not dumped) cache is a single
byte, and is guaranteed to be filled with zero =(\0 \0 \0 \0 \0 \0 \0
\0)=.

When dealing with reading from a stream, since Bel also reads bit by
bit only, we take the same advantage of the cache, however as the
opposite approach: we read a single byte from stream and keep the
cache full. As we read each bit, we convert it to a Bel character (=\0=
or =\1=). Once all bits of the cache have been read, another byte is
fetched, stored on cache, and so on.

#+begin_src C
typedef enum BEL_STREAM_STATUS
{
    BEL_STREAM_CLOSED,
    BEL_STREAM_READ,
    BEL_STREAM_WRITE
} BEL_STREAM_STATUS;

typedef struct
{
    BEL_STREAM_STATUS  status;
    FILE              *raw_stream;
    uint8_t            cache;
    uint8_t            cache_used;
} Bel_stream;
#+end_src

** Number

Bel does not specify any numeric types in its standard. In fact,
numbers could be reproduced in Bel by using Church numerals, for
example. However, this approach has a huge impact on performance,
enough to make us want actual numeric types in our interpreter.

A /number/ in Believe is a union of many number subtypes. The /number/ can
be an integer, a float, a fraction or even a complex number in its
constitution, but this coercion happens away from the eyes of the Bel
programmer; from his standpoint, there is only an opaque /number/ type.

Let's start by defining the enumeration of types. Integers are C
/64-bit signed ints/, and floats are, in fact, C /doubles/.

#+begin_src C
typedef enum {
    BEL_NUMBER_INT,
    BEL_NUMBER_FLOAT,
    BEL_NUMBER_FRACTION,
    BEL_NUMBER_COMPLEX
} BEL_NUMBER_TYPE;

typedef int64_t Bel_longint;
typedef double  Bel_float;
#+end_src

We forward declare the =Bel_number= structure as a /typedef/ for a =struct
BEL_NUMBER=.

#+begin_src C
typedef struct BEL_NUMBER Bel_number; // Forward declaration
#+end_src

Now we define our /fraction/ and /complex/ subtypes. Notice that they use
=Bel_number= in their constitution. This is on purpose, as it allows us
to create recursive definitions of numbers.

#+begin_src C
typedef struct {
    Bel *numer;
    Bel *denom;
} Bel_fraction;

typedef struct {
    Bel *real;
    Bel *imag;
} Bel_complex;
#+end_src

All that is left is to define our =Bel_number= formally.

#+begin_src C
struct BEL_NUMBER {
    BEL_NUMBER_TYPE type;
    union {
        Bel_longint  num_int;
        Bel_float    num_float;
        Bel_fraction num_frac;
        Bel_complex  num_compl;
    };
};
#+end_src

** The =Bel= structure

The remaining thing to do is join all the types into the =Bel= type,
which will serve as our generic way of dealing with things.

#+begin_src C
// Aliased as 'Bel' before
struct BEL
{
    BEL_TYPE type;
    union {
        Bel_sym     sym;
        Bel_pair   *pair;
        Bel_char    chr;
        Bel_stream  stream;
        Bel_number  number;
    };
};
#+end_src

* Essential structures and manipulation of data
** Basic definitions

These definitions relate to essential symbols of the Bel global
environment. They also encode the symbols' position on the global
symbol table, to be defined later.

#+begin_src C
#define BEL_NIL   ((Bel_sym)0)
#define BEL_T     ((Bel_sym)1)
#define BEL_O     ((Bel_sym)2)
#define BEL_APPLY ((Bel_sym)3)
#+end_src

The following symbols are axioms which are global to the program. One
is expected to use them instead of creating new symbols, though it is
not strictly necessary.

#+begin_src C
Bel *bel_g_nil;
Bel *bel_g_t;
Bel *bel_g_o;
Bel *bel_g_apply;
#+end_src

These other variables are responsible for holding other axioms on the
system. More on then will be specified later.

#+TODO: Add `errs` as an error stream?

#+begin_src C
Bel *bel_g_chars;
Bel *bel_g_ins_sys;
Bel *bel_g_outs_sys;
Bel *bel_g_ins;
Bel *bel_g_outs;
Bel *bel_g_prim;
Bel *bel_g_clo;
#+end_src

We may also define temporary variables for the global, lexical and
dynamic environments.

#+begin_src C
Bel *bel_g_scope;
Bel *bel_g_globe;
Bel *bel_g_dynae;
#+end_src

*** Forward declarations

We need to forward declare a few functions which will be useful for
certain operations. For example, it is important that we make a
forward declaration of =bel_mkerror=, since the primitives should depend
on it; also, providing =bel_mkstring= ensures that the error format can
be easily created, and so on.

#+TODO: Is this even correct? Test whether bel_mkerror creates an infinite loop!

#+begin_src C
Bel *bel_mkerror(Bel *format, Bel *vars);   // Forward declaration
Bel *bel_mkstring(const char*);             // Forward declaration
Bel *bel_mksymbol(const char*);             // Forward declaration
Bel *bel_car(Bel*);                         // Forward declaration
Bel *bel_cdr(Bel*);                         // Forward declaration
#+end_src

** Predicates

It is important to have a few predicates which will help us check for
errors. These predicates do not check for argument nullability
(e.g. unmanaged pointers), so use it wisely and only on initialized
data!

*** =symbolp=

=bel_symbolp= tests whether the element is a symbol.

#+begin_src C
#define bel_symbolp(x) ((x)->type==BEL_SYMBOL)
#+end_src

*** =nilp=

=bel_nilp= tests whether the element is the /symbol/ =nil=.

#+begin_src C
#define bel_nilp(x)                             \
    (bel_symbolp(x) && ((x)->sym==BEL_NIL))
#+end_src

*** =pairp=

=bel_pairp= tests whether the element is a /pair/.

#+begin_src C
#define bel_pairp(x) ((x)->type==BEL_PAIR)
#+end_src

*** =atomp=

=bel_atomp= tests whether an element is not a /pair/ -- that is, if it is
not "divisible".

#+begin_src C
#define bel_atomp(x) (!bel_pairp(x))
#+end_src

*** =charp=

=bel_charp= tests whether the object is a character.

#+begin_src C
#define bel_charp(x)                            \
    (((x)->type==BEL_CHAR))
#+end_src

*** =streamp=

=bel_streamp= tests whether the object is a stream.

#+begin_src C
#define bel_streamp(x)                          \
    (((x)->type==BEL_STREAM))
#+end_src

*** =numberp=

=bel_numberp= determines whether =x= is a number or not. Notice that
numbers are non-standard to Bel's definition.

#+begin_src C
#define bel_numberp(x)                          \
    ((x)->type==BEL_NUMBER)
#+end_src

*** =idp=

=bel_idp= tests whether an object is identical to another.
According to the Bel specification, identity is stricter than
equality: there is only one of each symbol and character. Pairs and
streams are compared by their references, so they are identical if and
only if they reside in the same memory address.

This is the first predicate that is implemented as a proper C
function, and it is used only internally; therefore, it outputs a C
integer value for truth and falsity.

#+begin_src C
int bel_idp_nums(Bel *x, Bel *y); // Forward declaration
#+end_src

#+begin_src C
int
bel_idp(Bel *x, Bel *y)
{
    if(bel_symbolp(x))
        return (x->sym == y->sym);
    else if(bel_charp(x))
        return (x->chr == y->chr);
    else if(bel_numberp(x)) {
        // Non-standard
        return bel_idp_nums(x, y);
    }

    // For pairs and streams, check for
    // pointer aliasing
    return (x == y);
}
#+end_src

Numbers are non-standard, so we develop our own identity test for
them: if two /numbers/ have the same /subtype/ (integer, float, fraction,
complex) and the same /value/, they are identical. In the case of
numbers with components (fraction, complex) we recursively test for
component identity instead of comparing /values/ directly.

#+begin_src C
int
bel_idp_nums(Bel *x, Bel *y)
{
    if(x->number.type == y->number.type) {
        switch(x->number.type) {
        case BEL_NUMBER_INT:
            return (x->number.num_int
                    == y->number.num_int);
        case BEL_NUMBER_FLOAT:
            return (x->number.num_float
                    == y->number.num_float);
        case BEL_NUMBER_FRACTION:
            return
                (bel_idp_nums(
                    x->number.num_frac.numer,
                    y->number.num_frac.numer)
                 && bel_idp_nums(
                     x->number.num_frac.denom,
                     y->number.num_frac.denom));
        case BEL_NUMBER_COMPLEX:
            return
                (bel_idp_nums(
                    x->number.num_compl.real,
                    y->number.num_compl.real)
                 && bel_idp_nums(
                     x->number.num_compl.imag,
                     y->number.num_compl.imag));
        };
    }
    return 0;
}
#+end_src

*** =errorp=

=bel_errorp= tests whether a specific object is a list in the format
=(lit err . rest)=.

#+begin_src C
int
bel_errorp(Bel *x)
{
    if(!bel_pairp(x)) return 0;
    if(!bel_idp(bel_car(x), bel_mksymbol("lit")))
        return 0;
    Bel *cdr = bel_cdr(x);
    if(!bel_idp(bel_car(cdr), bel_mksymbol("err")))
        return 0;
    return 1;
}
#+end_src

*** =proper-list-p=

A proper list is any list which ends in an appropriate =nil= symbol. So
for example, =(1 2 3)= is a proper list, but =(1 2 3 . 4)= is not. Compare
how these lists can be expressed by using dot notation:

- =(1 . (2 . (3 . nil)))=
- =(1 . (2 . (3 . 4)))=

An empty list is considered a proper list as well.

=bel_proper_list_p= checks whether a list is indeed a proper list. We do
that by traversing the list, pair by pair. If the /cdr/ is =nil=, it is
proper; if it is a pair, it proceeds with the traversal. But if the /cdr/
is anything else, then it is not a proper list.

#+begin_src C
int
bel_proper_list_p(Bel *x)
{
    if(!bel_pairp(x))
        return 0;
    
    Bel *itr = x;
    while(!bel_nilp(itr)) {
        if(!bel_pairp(itr))
            return 0;
        itr = bel_cdr(itr);
    }

    return 1;
}
#+end_src

*** =stringp=

An object is a string if and only if:

- it is a proper list;
- it contains characters only.

=bel_stringp= tests for this. However, this first implementation is a
little naïve, since it performs a proper list check, which involves
traversing an entire list, and then it traverses the list again,
checking for characters in the /car/. This overhead can be reduced in
the future.

#+begin_src C
int
bel_stringp(Bel *x)
{
    if(!bel_proper_list_p(x)) {
        return 0;
    }

    Bel *itr = x;
    while(!bel_nilp(itr)) {
        Bel *car = bel_car(itr);

        if(!bel_charp(car))
            return 0;

        itr = bel_cdr(itr);
    }

    return 1;
}
#+end_src

*** =literalp=

=bel_literalp= takes a proper list and tells whether the list is a
literal, that is, if the first element of the list is the symbol =lit=.

#+begin_src C
int
bel_literalp(Bel *x)
{
    if(!bel_proper_list_p(x))
        return 0;

    return bel_idp(bel_car(x),
                   bel_mksymbol("lit"));
}
#+end_src

*** =primitivep=

=bel_primitivep= takes a literal and tests whether it is a primitive,
that is, if the second element of the list is the symbol =prim=.

#+begin_src C
int
bel_primitivep(Bel *x)
{
    return bel_literalp(x)
        && bel_idp(bel_car(bel_cdr(x)),
                   bel_mksymbol("prim"));
}
#+end_src

*** =closurep=

=bel_closurep= takes a literal and tests whether it is a closure, that
is, if the second element of the list is the symbol =clo=.

#+begin_src C
int
bel_closurep(Bel *x)
{
    return bel_literalp(x)
        && bel_idp(bel_car(bel_cdr(x)),
                   bel_mksymbol("clo"));
}
#+end_src

*** =quotep=

=bel_quotep= takes a proper list and determines whether it is a quoted
form.

#+begin_src C
int
bel_quotep(Bel *x)
{
    if(!bel_proper_list_p(x))
        return 0;

    return bel_idp(bel_car(x),
                   bel_mksymbol("quote"));
}
#+end_src

*** =number-list-p=

=bel_number_list_p= determines whether =x= is a proper list of numbers.

#+begin_src C
int
bel_number_list_p(Bel *x)
{
    if(!bel_proper_list_p(x)) {
        return 0;
    }

    Bel *itr = x;
    while(!bel_nilp(itr)) {
        Bel *car = bel_car(itr);

        if(!bel_numberp(car))
            return 0;

        itr = bel_cdr(itr);
    }

    return 1;
}
#+end_src

** Symbol Table and Symbols

The symbol table is an array that grows as necessary, doubling in
size, but never shrinks on the program's lifetime. Each element of the
table is a =const= C string.

We begin by defining such structure and a global symbol table.

#+begin_src C
typedef struct {
    const char **tbl;
    uint64_t     n_syms;
    uint64_t     size;
} _Bel_sym_table;

_Bel_sym_table g_sym_table;
#+end_src

To initialize the symbol table, we give it an initial size of four,
just enough to enclose Bel's four fundamental symbols: =nil=, =t=, =o= and
=apply=. Notice that the order of these symbols relate to their
predefined macros, so any failure here is unexpected.

#+begin_src C
void
bel_sym_table_init(void)
{
    g_sym_table.n_syms = 4;
    g_sym_table.size   = 4;
    g_sym_table.tbl    =
        GC_MALLOC(g_sym_table.size * sizeof(char*));

    g_sym_table.tbl[BEL_NIL]   = "nil";
    g_sym_table.tbl[BEL_T]     = "t";
    g_sym_table.tbl[BEL_O]     = "o";
    g_sym_table.tbl[BEL_APPLY] = "apply";
}
#+end_src

The lookup function =bel_sym_table_find= does a linear search for the
presented literal on the symbol table. However, if it doesn't find the
symbol, it implicitly calls =bel_sym_table_add=, which appends the
symbol to the table.

This is obviously not a very wise approach as it opens up for some
exploits on interning symbols, but should be enough as long as these
symbols are only really interned on =lit= or =quote= scopes.

#+begin_src C
Bel_sym bel_sym_table_add(const char*); // Forward declaration

Bel_sym
bel_sym_table_find(const char *sym_literal)
{
    uint64_t i;
    for(i = 0; i < g_sym_table.n_syms; i++) {
        if(!strcmp(sym_literal, g_sym_table.tbl[i])) {
            return i;
        }
    }

    return bel_sym_table_add(sym_literal);
}

Bel_sym
bel_sym_table_add(const char *sym_literal)
{
    if(g_sym_table.n_syms == g_sym_table.size) {
        uint64_t new_size = 2 * g_sym_table.size;
        g_sym_table.tbl = GC_REALLOC(g_sym_table.tbl,
                                     new_size * sizeof(char*));
        g_sym_table.size = new_size;
    }
    g_sym_table.tbl[g_sym_table.n_syms++] = sym_literal;
    return (g_sym_table.n_syms - 1);
}
#+end_src

Eventually we'll also need to take a symbol and find its character
counterpart. Since the table is immutable, we can do that
instantaneously by taking the character string at the symbol's
position on the table. Notice that we do not check whether the given
argument is a symbol, since it is also an internal function.

#+begin_src C
const char*
bel_sym_find_name(Bel *sym)
{
    return g_sym_table.tbl[sym->sym];
}
#+end_src

Last but not least, we create a proper tool to build a symbol. Just
give it your desired symbol as a string literal and the runtime takes
care of the rest.

#+begin_src C
Bel*
bel_mksymbol(const char *str)
{
    Bel *ret  = GC_MALLOC(sizeof (*ret));
    ret->type = BEL_SYMBOL;
    ret->sym  = bel_sym_table_find(str);
    return ret;
}
#+end_src

** Pairs

Pairs are the kernel of every Lisp, so we need tools to manipulate
them.

We begin by specifying the function which builds pairs. Notice that
the function itself takes two references to values, so pairs cannot
exist without their /car/ and /cdr/.

#+begin_src C
Bel*
bel_mkpair(Bel *car, Bel *cdr)
{
    Bel *ret  = GC_MALLOC(sizeof (*ret));
    ret->type = BEL_PAIR;
    ret->pair = GC_MALLOC(sizeof (Bel_pair));
    ret->pair->car = car;
    ret->pair->cdr = cdr;
    return ret;
}
#+end_src

Now we may easily extract information from pairs, using the /car/ and
/cdr/ operations.

#+begin_src C
Bel*
bel_car(Bel *p)
{
    if(bel_nilp(p))
        return bel_g_nil;
    
    if(!bel_pairp(p)) {
        return bel_mkerror(
            bel_mkstring("Cannot extract the car of ~a."),
            bel_mkpair(p, bel_g_nil));
    }
    
    return p->pair->car;
}
#+end_src

#+begin_src C
Bel*
bel_cdr(Bel *p)
{
    if(bel_nilp(p))
        return bel_g_nil;
    
    if(!bel_pairp(p)) {
        return bel_mkerror(
            bel_mkstring("Cannot extract the cdr of ~a."),
            bel_mkpair(p, bel_g_nil));
    }
    
    return p->pair->cdr;
}
#+end_src

Let's also build a utility to return the size of a list. This is a
=O(n)= operation which takes a well-formed list and iterates over
it.

Note that *calculating the length of something that is not a /proper
list/ makes no sense and will crash this operation*. So before calling
=bel_length=, it is probably a good idea to check for a valid proper
list using =bel_proper_list_p= or a similar procedure.

#+begin_src C
uint64_t
bel_length(Bel *list)
{
    Bel *itr = list;
    uint64_t len = 0;
    while(!bel_nilp(itr)) {
        len++;
        itr = bel_cdr(itr);
    }
    return len;
}
#+end_src

** Characters and Strings

Let's begin by adding a small function to wrap a character in a Bel
object.

#+begin_src C
Bel*
bel_mkchar(Bel_char c)
{
    Bel *ret  = GC_MALLOC(sizeof *ret);
    ret->type = BEL_CHAR;
    ret->chr  = c;
    return ret;
}
#+end_src

#+TODO: This needs to change if unicode support is enabled
Characters have the size of one byte, so if we take a single list of 8
=\1= and =\0= characters, we should be able to generate a bitmask of the
corresponding character in question.

#+begin_src C
Bel*
bel_char_from_binary(Bel *list)
{
    if(!bel_pairp(list)) {
        return bel_mkerror(
            bel_mkstring("The binary representation of "
                         "a character must be a string of "
                         "characters \\0 and \\1."),
            bel_g_nil);
    }

    if(!bel_proper_list_p(list)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a proper "
                         "list, and therefore not a list "
                         "of characters \\0 and \\1."),
            bel_mkpair(list, bel_g_nil));
    }

    size_t len = bel_length(list);

    if(len != 8) {
        return bel_mkerror(
            bel_mkstring("The binary representation of "
                         "a character must have exactly "
                         "eight characters \\0 or \\1."),
            bel_g_nil);
    }
    
    Bel_char mask = '\0';
    size_t i;
    Bel *current = list;
    
    for(i = 0; i < len; i++) {
        Bel *bitchar = bel_car(current);

        if(!bel_charp(bitchar)) {
            return bel_mkerror(
                bel_mkstring("The provided binary "
                             "representation of a "
                             "character does not contain "
                             "only characters."),
                bel_g_nil);
        }

        if(bitchar->chr != '0' && bitchar->chr != '1') {
            return bel_mkerror(
                bel_mkstring("The binary representation of "
                             "a character must have exactly "
                             "eight characters \\0 or \\1."),
                bel_g_nil);
        }
        
        if(bitchar->chr == '1') {
            mask |= (1 << (7 - i));
        }
        current = bel_cdr(current);
    }
    return bel_mkchar(mask);
}
#+end_src

Strings on the Bel environment are nothing more than a list of
characters, therefore we need a way to convert C strings to proper Bel
lists.

#+begin_src C
Bel*
bel_mkstring(const char *str)
{
    size_t len = strlen(str);

    if(len == 0)
        return bel_g_nil;
    
    Bel **pairs = GC_MALLOC(len * sizeof (Bel));

    // Create pairs where CAR is a character and CDR is nil
    size_t i;
    for(i = 0; i < len; i++) {
        Bel *chr  = GC_MALLOC(sizeof *chr);
        chr->type = BEL_CHAR;
        chr->chr  = str[i];
        pairs[i]  = bel_mkpair(chr, bel_g_nil);
    }

    // Link all pairs properly
    for(i = 0; i < len - 1; i++) {
        pairs[i]->pair->cdr = pairs[i + 1];
    }

    return pairs[0];
}
#+end_src

We also add a utility to take back a Bel string and turn it into a
garbage-collected C string.

Note that the errors it can produce are instead dumped to the console
and we return a null pointer; proper manipulation of this function is
a responsibility of the programmer, since this is an internal
function.

#+begin_src C
char*
bel_cstring(Bel *belstr)
{
    if(!bel_pairp(belstr)) {
        puts("INTERNAL ERROR on bel_cstring: "
             "argument is not a pair");
        return NULL;
    }
    
    if(!bel_stringp(belstr)) {
        puts("INTERNAL ERROR on bel_cstring: "
             "argument is not a string");
        return NULL;
    }
    
    uint64_t len = bel_length(belstr);
    if(len == 0) return NULL;
    
    char *str    = GC_MALLOC((len + 1) * sizeof (*str));

    Bel *itr     = belstr;
    size_t i     = 0;

    while(!bel_nilp(itr)) {
        str[i] = bel_car(itr)->chr;
        itr    = bel_cdr(itr);
        i++;
    }
    str[i] = '\0';
    return str;
}
#+end_src

** Streams

#+TODO: Enclose stderr on Bel object
We start by creating tools to manipulate streams. First, we create a
raw stream from a file.

#+begin_src C
Bel*
bel_mkstream(const char* name, BEL_STREAM_STATUS status)
{
    Bel *ret           = GC_MALLOC(sizeof *ret);
    ret->type          = BEL_STREAM;

    if(status == BEL_STREAM_CLOSED) {
        return bel_mkerror(
            bel_mkstring("Cannot create a stream with "
                         "CLOSED status."),
            bel_g_nil);
    }

    if(!strncmp(name, "ins", 3)) {
        ret->stream.raw_stream = stdin;
    } else if(!strncmp(name, "outs", 4)) {
        ret->stream.raw_stream = stdout;
    } else {
        ret->stream.raw_stream =
            fopen(name,
                  status == BEL_STREAM_READ ? "rb" : "wb");
        
        if(!ret->stream.raw_stream) {
            return bel_mkerror(
                bel_mkstring("Unable to open stream ~a."),
                bel_mkpair(
                    bel_mkstring(name), bel_g_nil));
        }
    }

    ret->stream.status     = status;
    ret->stream.cache      = 0u;
    ret->stream.cache_used = 0u;
    return ret;
}
#+end_src

One important thing to have is a function which inputs a single bit in
a file. We use the previously defined cache system for that; by
filling the bits from left to right, we'll enable output as a single
bit.

First we define the function which dumps and resets the cache of a
specific stream when the cache is full; this should come in handy when
closing the stream as well. After that, we do the actual bit
writing. And of course, writing a bit returns =t= or =nil= for success and
failure; this will most likely not be external to the Bel environment
itself, since a failure in writing must signal an error. But that is
not the job for this primitive.

#+begin_src C
Bel*
bel_stream_dump_cache(Bel_stream *stream)
{
    if(!fwrite(&stream->cache, 1, 1, stream->raw_stream)) {
        return bel_g_nil;
    }
    stream->cache_used = 0u;
    stream->cache      = 0u;
    return bel_g_t;
}

Bel*
bel_stream_write_bit(Bel_stream *stream, Bel_char bit)
{
    if(bit != '0' || bit != '1') {
        return bel_mkerror(
            bel_mkstring("Written bit must be represented "
                         "as a character 0 or 1"),
            bel_g_nil);
    }

    if(stream->status != BEL_STREAM_WRITE) {
        return bel_mkerror(
            bel_mkstring("Write stream is not at WRITE "
                         "state"),
            bel_g_nil);
    }

    if(stream->cache_used >= 8) {
        return bel_stream_dump_cache(stream);
    } else {
        if(bit == '1') {
            stream->cache |= (1 << (7 - stream->cache_used));
        }
        stream->cache_used++;
    }
    
    return bel_mkchar(bit);
}
#+end_src

We can take advantage of the same variables to read single bits from a
file, as described before too. Keep the cache full, read single bits
as Bel characters, fill the cache when the read bits are exhausted.

#+TODO: "Being unable to read a bit" signals an error.
#+TODO: "No bit is currently available" returns nil -- but how should I do it?

#+begin_src C
Bel*
bel_stream_fill_cache(Bel_stream *stream)
{
    if(!fread(&stream->cache, 1, 1, stream->raw_stream)) {
        // Return nil on EOF
        return bel_g_nil;
    }
    stream->cache_used = 8;
    return bel_g_t;
}

Bel*
bel_stream_read_bit(Bel_stream *stream)
{
    if(stream->status != BEL_STREAM_READ) {
        return bel_mkerror(
            bel_mkstring("Read stream is not at READ "
                         "state"),
            bel_g_nil);
    }
    
    Bel *ret;
    if(stream->cache_used == 0) {
        ret = bel_stream_fill_cache(stream);
        if(bel_nilp(ret)) {
            return bel_mksymbol("eof");
        }
    }

    uint8_t mask = (1 << (stream->cache_used - 1));
    ret = bel_mkchar(((mask & stream->cache) == mask)
                     ? ((Bel_char)'1') : ((Bel_char)'0'));
    stream->cache_used--;
    return ret;
}
#+end_src

#+TODO: Byte input/output -- unecessary?
#+TODO: Text input/output, specifically for ins/outs -- unecessary?

We'll also need a tool to close a certain stream. Here we're being a
little more careful, since streams are managed more directly, by using
the C API. And of course, if we're dealing with output, dump the
stream cache before closing the file.

#+begin_src C
Bel*
bel_stream_close(Bel *obj)
{
    if(obj->type != BEL_STREAM) {
        return bel_mkerror(
            bel_mkstring("Cannot close something that "
                         "is not a stream."),
            bel_g_nil);
    }
    
    if(obj->stream.status == BEL_STREAM_CLOSED) {
        return bel_mkerror(
            bel_mkstring("Cannot close a closed stream."),
            bel_g_nil);
    }

    // Dump cache before closing
    if(obj->stream.status == BEL_STREAM_WRITE) {
        bel_stream_dump_cache(&obj->stream);
    }
    
    if(!fclose(obj->stream.raw_stream)) {
        obj->stream.raw_stream = NULL;
        obj->stream.status     = BEL_STREAM_CLOSED;
        return bel_g_t;
    }

    return bel_mkerror(
        bel_mkstring("Error closing stream: ~a."),
        bel_mkpair(
            bel_mkstring(strerror(errno)),
            bel_g_nil));
}
#+end_src

The default input and output streams are enclosed in Bel objects here,
however they relate to =stdin= and =stdout= respectively. To the system,
by default they have =nil= value.

#+begin_src C
void
bel_init_streams(void)
{
    bel_g_ins      = bel_g_nil;
    bel_g_outs     = bel_g_nil;
    bel_g_ins_sys  = bel_mkstream("ins",  BEL_STREAM_READ);
    bel_g_outs_sys = bel_mkstream("outs", BEL_STREAM_WRITE);
}
#+end_src

*** Stream manipulation safety

Since streams are defined taking advantage of the C API for
manipulating files, unfortunately these demand careful usage on Bel
programs. When handling streams, it is absolutely necessary to close
them. The Boehm GC does not have finalizers for C bindings, so
unfortunately it is not possible for now to call a finalizer which
automatically closes the stream when the stream object is garbage
collected.

** Numbers

As stated before, numbers are not described in Bel specification,
however we're implementing it for minimal ease and performance for
arithmetic manipulation.

We've built a resilient and recursive model for constituting numbers,
so we begin by arranging tools to create them.

*** Number generation

/Integers/ are pretty straightforward: we just allocate a proper space
and store them.

#+begin_src C
Bel*
bel_mkinteger(int64_t num)
{
    Bel *ret            = GC_MALLOC(sizeof (*ret));
    ret->type           = BEL_NUMBER;
    ret->number.type    = BEL_NUMBER_INT;
    ret->number.num_int = num;
    return ret;
}
#+end_src

The same goes for the /float/ type (which is actually a C double).

#+begin_src C
Bel*
bel_mkfloat(double num)
{
    Bel *ret              = GC_MALLOC(sizeof (*ret));
    ret->type             = BEL_NUMBER;
    ret->number.type      = BEL_NUMBER_FLOAT;
    ret->number.num_float = num;
    return ret;
}
#+end_src

A fraction has a layer of complexity, though. We take a numerator and
a denominator as /numbers/, but we need to make sure they are
numbers. Plus, even if they were, we need to make sure that the
denominator /is not zero/. However, the only checks we perform here are
related to the /numberness/ of numerator and denominator.

#+begin_src C
Bel*
bel_mkfraction(Bel *numer, Bel *denom)
{
    if(!bel_numberp(numer)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a number."),
            bel_mkpair(numer, bel_g_nil));
    }

    if(!bel_numberp(denom)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a number."),
            bel_mkpair(numer, bel_g_nil));
    }
    
    Bel *ret                   = GC_MALLOC(sizeof (*ret));
    ret->type                  = BEL_NUMBER;
    ret->number.type           = BEL_NUMBER_FRACTION;
    ret->number.num_frac.numer = numer;
    ret->number.num_frac.denom = denom;
    return ret;
}
#+end_src

We follow the same principle for a complex number: /real/ and /imaginary/
parts need to be a number themselves.

#+begin_src C
Bel*
bel_mkcomplex(Bel *real, Bel *imag)
{
    if(!bel_numberp(real)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a number."),
            bel_mkpair(real, bel_g_nil));
    }

    if(!bel_numberp(imag)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a number."),
            bel_mkpair(imag, bel_g_nil));
    }
    
    Bel *ret                   = GC_MALLOC(sizeof (*ret));
    ret->type                  = BEL_NUMBER;
    ret->number.type           = BEL_NUMBER_COMPLEX;
    ret->number.num_compl.real = real;
    ret->number.num_compl.imag = imag;
    return ret;
}
#+end_src

*** Number arithmetic

The following operations always happen between two numbers. We make
sure they are of compatible types to perform these operations, and
then we return numbers of a proper subtype afterwards.

**** Forward declarations

#+begin_src C
Bel *bel_num_add(Bel *x, Bel *y); // Forward declaration
Bel *bel_num_sub(Bel *x, Bel *y); // Forward declaration
Bel *bel_num_mul(Bel *x, Bel *y); // Forward declaration
Bel *bel_num_div(Bel *x, Bel *y); // Forward declaration
#+end_src

**** Coercion

Let's start with subtype coercion. Given a number and a number type
flag, we coerce that number to a new number of that subtype. Returns a
new number, and does not modify the old one.

Coercing a float to a fraction uses a naïve approach: we multiply the
number by =10= until it has no significant digits on the decimal
part. We count the =i= multiplications we've made, and then we build a
fraction where the numerator is a truncated, converted to integer
result, and the denominator is exactly ten to the power of =i=.

#+begin_src C
Bel*
bel_num_coerce(Bel *number, BEL_NUMBER_TYPE type)
{
    if(number->number.type == type)
        return number;

    switch(number->number.type) {
    case BEL_NUMBER_INT:
    {
        switch(type) {
        case BEL_NUMBER_FLOAT:
            return bel_mkfloat(
                (double)number->number.num_int);
        case BEL_NUMBER_FRACTION:
            return bel_mkfraction(
                number,
                bel_mkinteger(1));
        case BEL_NUMBER_COMPLEX:
            return bel_mkcomplex(
                number,
                bel_mkinteger(0));
        default: break;
        };
    }
    break;
    case BEL_NUMBER_FLOAT:
    {
        switch(type) {
        case BEL_NUMBER_INT:
            return bel_mkinteger(
                (int64_t)trunc(number->number.num_float));
        case BEL_NUMBER_FRACTION:
        {
            double num  = number->number.num_float;
            double trun = trunc(num);
            int i = 0;
            while(num != trun) {
                num *= 10.0;
                trun = trunc(num);
                i++;
            }
            return bel_mkfraction(
                bel_mkinteger((int64_t)num),
                bel_mkinteger((int64_t)pow(10, i)));
        }
        case BEL_NUMBER_COMPLEX:
            return bel_mkcomplex(number,
                                 bel_mkfloat(0.0));
        default: break;
        };
    }
    break;
    case BEL_NUMBER_FRACTION:
    {
        switch(type) {
        case BEL_NUMBER_INT:
        {
            Bel *float_res =
                bel_num_div(
                    bel_num_coerce(
                        number->number.num_frac.numer,
                        BEL_NUMBER_FLOAT),
                    bel_num_coerce(
                        number->number.num_frac.denom,
                        BEL_NUMBER_FLOAT));
            
            return bel_mkinteger(
                (int64_t)trunc(
                    float_res->number.num_float));
        }
        case BEL_NUMBER_FLOAT:
            return bel_num_div(
                bel_num_coerce(
                    number->number.num_frac.numer,
                    BEL_NUMBER_FLOAT),
                bel_num_coerce(
                    number->number.num_frac.denom,
                    BEL_NUMBER_FLOAT));
        case BEL_NUMBER_COMPLEX:
            return bel_mkcomplex(number,
                                 bel_mkinteger(0));
        default: break;
        };
    }
    break;
    case BEL_NUMBER_COMPLEX:
    {
        switch(type) {
        case BEL_NUMBER_INT:
        {
            Bel *coerced =
                bel_num_coerce(
                    number->number.num_compl.real,
                    BEL_NUMBER_FLOAT);
            
            return bel_mkinteger(
                (int64_t)trunc(
                    coerced->number.num_float));
        }
        case BEL_NUMBER_FLOAT:
            return bel_num_coerce(
                number->number.num_compl.real,
                BEL_NUMBER_FLOAT);
        case BEL_NUMBER_FRACTION:
            return bel_num_coerce(
                number->number.num_compl.real,
                BEL_NUMBER_FRACTION);
        default: break;
        };
    }
    break;
    default: break;
    };

    return number;
}
#+end_src

**** Force same type

The following function takes two numbers, and makes sure they both
have a subtype where both retain full information. Returns a pair
containing both numbers.

#+begin_src C
Bel*
bel_num_mksametype(Bel *x, Bel *y)
{
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        switch(y->number.type) {
        case BEL_NUMBER_INT:
            // int -> int -> int
            return bel_mkpair(x, y);
        case BEL_NUMBER_FLOAT:
            // int -> float -> float
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_FLOAT),
                y);
        case BEL_NUMBER_FRACTION:
            // int -> fraction -> fraction
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_FRACTION),
                y);
        case BEL_NUMBER_COMPLEX:
            // int -> complex -> complex
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_COMPLEX),
                y);
        default: break;
        }
        break;
    case BEL_NUMBER_FLOAT:
        switch(y->number.type) {
        case BEL_NUMBER_INT:
            // float -> int -> float
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FLOAT:
            // float -> float -> float
            // same type
            return bel_mkpair(x, y);
        case BEL_NUMBER_FRACTION:
            // float -> fraction -> fraction
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_FRACTION),
                y);
        case BEL_NUMBER_COMPLEX:
            // float -> complex -> complex
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_COMPLEX),
                y);
            break;
        default: break;
        }
        break;
    case BEL_NUMBER_FRACTION:
        switch(y->number.type) {
        case BEL_NUMBER_INT:
            // fraction -> int -> int
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FLOAT:
            // fraction -> float -> fraction
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FRACTION:
            // fraction -> fraction -> fraction
            // same type
            return bel_mkpair(x, y);
        case BEL_NUMBER_COMPLEX:
            // fraction -> complex -> complex
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_COMPLEX),
                y);
            break;
        default: break;
        }
        break;
    case BEL_NUMBER_COMPLEX:
        switch(y->number.type) {
        case BEL_NUMBER_INT:
            // complex -> int -> complex
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FLOAT:
            // complex -> float -> complex
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FRACTION:
            // complex -> fraction -> complex
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_COMPLEX:
            // complex -> complex -> complex
            // same type
            return bel_mkpair(x, y);
        default: break;
        }
        break;
    default: break;
    }
}
#+end_src

***** Helper macro for functions

The following macro does an inline conversion of =Bel= pointers to same
number subtype. Only the locals =x= and =y= will be affected; the original
pointed objects won't be modified.

#+begin_src C
#define BEL_NUM_SAMETYPE(x, y)                  \
    {                                           \
    Bel *p = bel_num_mksametype(x, y);          \
    x = bel_car(p);                             \
    y = bel_cdr(p);                             \
    }
#+end_src

**** Checking for zero

This function checks whether the argument is zero.

Comparing directly for zero on a double is not a really good
idea. We're doing a naïve approach here, but it is not completely
guaranteed.

#+begin_src C
int
bel_num_zerop(Bel *x)
{
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        return (x->number.num_int == 0);
    case BEL_NUMBER_FLOAT:
        return (x->number.num_float == 0.0)
            || (x->number.num_float == -0.0);
    case BEL_NUMBER_FRACTION:
        return bel_num_zerop(
            x->number.num_frac.numer);
    case BEL_NUMBER_COMPLEX:
        return (bel_num_zerop(
                    x->number.num_compl.real))
            && (bel_num_zerop(
                    x->number.num_compl.imag));
    }

    // This should not be reached...
    return 0;
}
#+end_src

**** Addition

The following function adds two arbitrary numbers.

#+begin_src C
Bel*
bel_num_add(Bel *x, Bel *y)
{
    BEL_NUM_SAMETYPE(x, y);
    
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        return bel_mkinteger(
            x->number.num_int + y->number.num_int);
    case BEL_NUMBER_FLOAT:
        return bel_mkfloat(
            x->number.num_float + y->number.num_float);
    case BEL_NUMBER_FRACTION:
    {
        Bel *new_numer_x =
            bel_num_mul(x->number.num_frac.numer,
                        y->number.num_frac.denom);
        Bel *new_numer_y =
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.numer);
        Bel *new_denom =
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.denom);

        return bel_mkfraction(
            bel_num_add(new_numer_x, new_numer_y),
            new_denom);
    }
    case BEL_NUMBER_COMPLEX:
        return bel_mkcomplex(
            bel_num_add(x->number.num_compl.real,
                        y->number.num_compl.real),
            bel_num_add(x->number.num_compl.imag,
                        y->number.num_compl.imag));
    default: break;
    };
    
    return bel_mkerror(
        bel_mkstring("Error while adding ~a and ~a."),
        bel_mkpair(x, bel_mkpair(y, bel_g_nil)));
}
#+end_src

**** Subtraction

This function is identical to =bel_num_add=, however it subtracts two
numbers.

#+begin_src C
Bel*
bel_num_sub(Bel *x, Bel *y)
{
    BEL_NUM_SAMETYPE(x, y);

    switch(x->number.type) {
    case BEL_NUMBER_INT:
        return bel_mkinteger(
            x->number.num_int - y->number.num_int);
    case BEL_NUMBER_FLOAT:
        return bel_mkfloat(
            x->number.num_float - y->number.num_float);
    case BEL_NUMBER_FRACTION:
    {
        Bel *new_numer_x =
            bel_num_mul(x->number.num_frac.numer,
                        y->number.num_frac.denom);
        Bel *new_numer_y =
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.numer);
        Bel *new_denom =
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.denom);

        return bel_mkfraction(
            bel_num_sub(new_numer_x, new_numer_y),
            new_denom);
    }
    case BEL_NUMBER_COMPLEX:
        return bel_mkcomplex(
            bel_num_sub(x->number.num_compl.real,
                        y->number.num_compl.real),
            bel_num_sub(x->number.num_compl.imag,
                        y->number.num_compl.imag));
    default: break;
    };
    
    return bel_mkerror(
        bel_mkstring("Error while subtracting ~a "
                     "and ~a."),
        bel_mkpair(x, bel_mkpair(y, bel_g_nil)));
}
#+end_src

**** Multiplication

This function multiplies two arbitrary numbers.

#+begin_src C
Bel*
bel_num_mul(Bel *x, Bel *y)
{
    BEL_NUM_SAMETYPE(x, y);
    
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        return bel_mkinteger(
            x->number.num_int * y->number.num_int);
    case BEL_NUMBER_FLOAT:
        return bel_mkfloat(
            x->number.num_float * y->number.num_float);
    case BEL_NUMBER_FRACTION:
        return bel_mkfraction(
            bel_num_mul(x->number.num_frac.numer,
                        y->number.num_frac.numer),
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.denom));
    case BEL_NUMBER_COMPLEX:
    {
        Bel *real =
            bel_num_sub(
                bel_num_mul(x->number.num_compl.real,
                            y->number.num_compl.real),
                bel_num_mul(x->number.num_compl.imag,
                            y->number.num_compl.imag));
        Bel *imag =
            bel_num_add(
                bel_num_mul(x->number.num_compl.real,
                            y->number.num_compl.imag),
                bel_num_mul(x->number.num_compl.imag,
                            y->number.num_compl.real));

        return bel_mkcomplex(real, imag);
    }
    break;
    default: break;
    };

    return bel_mkerror(
        bel_mkstring("Error while multiplying "
                     "~a and ~a."),
        bel_mkpair(x, bel_mkpair(y, bel_g_nil)));
}
#+end_src

**** Division

This function divides two arbitrary numbers.
Notice that we check whether the second argument is zero.

#+begin_src C
Bel*
bel_num_div(Bel *x, Bel *y)
{
    BEL_NUM_SAMETYPE(x, y);

    if(bel_num_zerop(y)) {
        return bel_mkerror(
            bel_mkstring("Cannot divide by zero."),
            bel_g_nil);
    }
    
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        if(x->number.num_int % y->number.num_int) {
            return bel_mkfraction(x, y);
        } else {
            return bel_mkinteger(
                x->number.num_int / y->number.num_int);
        }
    case BEL_NUMBER_FLOAT:
        return bel_mkfloat(
            x->number.num_float / y->number.num_float);
    case BEL_NUMBER_FRACTION:
        return bel_mkfraction(
            bel_num_mul(x->number.num_frac.numer,
                        y->number.num_frac.denom),
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.numer));
    case BEL_NUMBER_COMPLEX:
    {
        Bel *numer = bel_mkcomplex(
            bel_num_add(
                bel_num_mul(x->number.num_compl.real,
                            y->number.num_compl.real),
                bel_num_mul(x->number.num_compl.imag,
                            y->number.num_compl.imag)),
            bel_num_add(
                bel_num_mul(
                    bel_mkinteger(-1),
                    bel_num_mul(x->number.num_compl.real,
                                y->number.num_compl.imag)),
                bel_num_mul(x->number.num_compl.imag,
                            y->number.num_compl.real)));

        Bel *denom = bel_num_add(
            bel_num_mul(y->number.num_compl.real,
                        y->number.num_compl.real),
            bel_num_mul(y->number.num_compl.imag,
                        y->number.num_compl.imag));

        return bel_mkfraction(numer, denom);
    }
    default: break;
    }

    return bel_mkerror(
        bel_mkstring("Error while dividing "
                     "~a and ~a."),
        bel_mkpair(x, bel_mkpair(y, bel_g_nil)));
}
#+end_src

** Errors

Bel does not have a formal specification on errors in primitives,
other than saying that there might be an =err= function which throws an
error in the system.

I will therefore specify that, in Believe, an error is a literal (much
like closures and primitives) which obeys the pattern...

=(lit err format . args)=

...where =lit= is the expected symbol for something that evaluates to
itself, =err= is the symbol which specifies that the object is an error,
=format= is a Bel string which contains a format for the given
arguments, and =args= is a list of arguments which should be parsed
within the format.

For a first implementation, I intend to make the format specification
follow loosely the conventions of the =format= macro in Common Lisp,
having =~a= as the format for any object and =~%= as the format for a new
line, for example.

Here's how it could look like:

#+begin_example
> (err "Cannot use ~a on ~a.~%" '(1 2 3) square)
Error: Cannot use (1 2 3) on (lit clo nil (x) (* x x)).

#+end_example

However, since this is a detail which can be implemented in Bel
itself, we'll just go ahead and say that there is a string format and
a list of arguments.

#+begin_src C
Bel*
bel_mkerror(Bel *format, Bel *arglist)
{
    return bel_mkpair(
        bel_mksymbol("lit"),
        bel_mkpair(
            bel_mksymbol("err"),
            bel_mkpair(format, arglist)));
}
#+end_src

* Axioms

To save memory, some of the following things will be globally defined.

** Variables and constants

Define global symbols which can be used across the program. These
symbols should be used repeatedly, and that's why they were already
declared. See the =bel_init= function to refer to their initialization.

#+begin_src C
void
bel_init_ax_vars(void)
{
    bel_g_nil   = bel_mksymbol("nil");
    bel_g_t     = bel_mksymbol("t");
    bel_g_o     = bel_mksymbol("o");
    bel_g_apply = bel_mksymbol("apply");

    bel_g_prim  = bel_mksymbol("prim");
    bel_g_clo   = bel_mksymbol("clo");
}
#+end_src

=bel_g_prim= is not part of the axiom variables, but we'll define it
here since we'll need this symbol for generating primitives later.

** List of all characters

First, we build an auxiliary function which converts an 8-bit number
into a string, where each character represents a bit.

#+begin_src C
char*
bel_conv_bits(uint8_t num)
{
    char *str = GC_MALLOC(9 * sizeof(*str));
    
    uint8_t i;
    for(i = 0; i < 8; i++) {
        int is_bit_set = num & (1 << i);
        str[7 - i] = is_bit_set ? '1' : '0';
    }
    str[8] = '\0';
    
    return str;
}
#+end_src

We build a list of all characters so that the specification gets
happy. It will be stored in the previously defined =bel_g_chars= global
variable. This might seem unecessary in the future, though.

The list is supposed to be built out of pairs, therefore we start by
creating 255 =Bel= instances, representing list nodes; every node is
supposed to hold the pointer to a =Bel_pair=. These pairs will be linked
to one another: the /cdr/ of the first =Bel_pair= (again, contained inside
a =Bel= instance) points to the second =Bel=; the /cdr/ of the second
=Bel_pair= (also contained on its =Bel= instance) points to the third =Bel=,
and so on. The last /cdr/ of the last =Bel_pair=, also enclosed on a =Bel=
instance, contains the symbol =nil=.

Now, we discuss what should be held in the /car/ of each of these
pairs. And that would be other pairs, which will hold the actual
information we desire. Each of these secondary pairs is comprised of a
character at its /car/, and a Bel string representing the bits of the
character as its /cdr/.

#+begin_src C
void
bel_init_ax_chars(void)
{
    // Create a vector of 255 list nodes
    Bel **list = GC_MALLOC(255 * sizeof(*list));

    size_t i;
    for(i = 0; i < 255; i++) {        
        // Build a pair which holds the character information
        Bel *pair = bel_mkpair(bel_mkchar((Bel_char)i),
                               bel_mkstring(bel_conv_bits(i)));
        // Assign the car of a node to the current pair,
        // set its cdr temporarily to nil
        list[i] = bel_mkpair(pair, bel_g_nil);
    }

    // Assign each pair cdr to the pair on the front.
    // Last pair should have a nil cdr still.
    for(i = 0; i < 254; i++) {
        list[i]->pair->cdr = list[i + 1];
    }

    // Hold reference to first element only
    bel_g_chars = list[0];
}
#+end_src

** Environment

Any environment is nothing but a list of pairs, where each pair =(var
. val)= represents the binding of a specific symbol =var= to the value
=val=.

We begin by creating a function which pushes, non-destructively, a new
pair to any environment. The result is the new environment.

#+begin_src C
Bel*
bel_env_push(Bel *env, Bel *var, Bel *val)
{
    Bel *new_pair = bel_mkpair(var, val);
    return bel_mkpair(new_pair, env);
}
#+end_src

Notice that this non-destructive approach is important, since a
lexical enviroment is supposed to extend the enviroment it is called
on -- for example, the environment of a function called from top-level
is a list where the first elements are lexical bindings, and
(conceptually) the latter elements are bindings belonging to the
global environment.

Now we register all our axioms to our global environment. This way, a
lookup operation on the global scope will yield proper values.

First, we define a macro which uses =bel_env_push= to modify the =globe=
environment variable. This macro just takes a =SYMSTR=, turns it into a
symbol, and generates a new environment, which is then assigned to the
global environment.

#+begin_src C
#define BEL_ENV_GLOBAL_PUSH(SYMSTR, VAL)           \
    (bel_g_globe =                                 \
     bel_env_push(bel_g_globe,                     \
                  bel_mksymbol(SYMSTR), VAL))
#+end_src

Initializing the global environment involves pushing certain values to
it. But the dynamic and lexical environments are initialized to =nil=.

#+begin_src C
void
bel_init_ax_env(void)
{
    bel_g_globe = bel_g_nil;
    bel_g_dynae = bel_g_nil;
    bel_g_scope = bel_g_nil; // TODO: is this really necessary?
    
    BEL_ENV_GLOBAL_PUSH("chars", bel_g_chars);
    BEL_ENV_GLOBAL_PUSH("ins",   bel_g_ins);
    BEL_ENV_GLOBAL_PUSH("outs",  bel_g_outs);
}
#+end_src

Then, we create a lookup function. This function traverses an
environment in linear time, so it is not fast, but it does its job. A
lookup process either returns the associated value or returns =nil=.

#+begin_src C
Bel*
bel_env_lookup(Bel *env, Bel *sym)
{
    if(bel_nilp(env)) {
        return bel_g_nil;
    }
    
    if(!bel_symbolp(sym)) {
        return bel_mkerror(
            bel_mkstring("Cannot perform lookup of ~a, "
                         "which is not a symbol."),
            bel_mkpair(sym, bel_g_nil));
    }

    Bel *itr = env;
    while(!bel_nilp(itr)) {
        Bel *p = bel_car(itr);
        if(bel_car(p)->type == BEL_SYMBOL
           && bel_car(p)->sym == sym->sym) {
            return bel_cdr(p);
        }
        
        itr = bel_cdr(itr);
    }
    return bel_g_nil;
}
#+end_src

We also implement a proper lookup function which takes a lexical
environment and a symbol. The function traverses all environments in
order (dynamic, lexical, global) to find the associated value of the
given symbol. If the symbol is not found, returns an error.

#+begin_src C
Bel*
bel_lookup(Bel *lenv, Bel *sym)
{
    Bel *value;

    // Dynamic scope lookup
    value = bel_env_lookup(bel_g_dynae, sym);
    if(!bel_nilp(value)) {
        return value;
    }
    
    // Lexical scope lookup
    value = bel_env_lookup(lenv, sym);
    if(!bel_nilp(value)) {
        return value;
    }

    // Global scope lookup
    value = bel_env_lookup(bel_g_globe, sym);
    if(bel_nilp(value)) {
        return bel_mkerror(
            bel_mkstring("The symbol ~a is unbound."),
            bel_mkpair(sym, bel_g_nil));
    }

    return value;
}
#+end_src

Another thing to do is enable assignment. We begin by creating a
function which finds a specific symbol on a specific environment and
replaces its value by the given one. On success, it returns the
symbol; on failure, it returns =nil=. If the environment is empty, we
also return =nil=. Oh, we also don't check if the given symbol is really
a symbol, since this is an internal function.

#+begin_src C
Bel*
bel_env_replace_val(Bel *env, Bel *sym, Bel *new_val)
{
    if(bel_nilp(env)) {
        return bel_g_nil;
    }
    
    Bel *itr = env;
    while(!bel_nilp(itr)) {
        Bel *p = bel_car(itr);
        if(bel_idp(sym, bel_car(p))) {
            p->pair->cdr = new_val;
            return sym;
        }
        itr = bel_cdr(itr);
    }
    return bel_g_nil;
}
#+end_src

We also need a function which takes the reference to an environment
and a symbol, and /unbinds/ that symbol from the value in the
environment. This can be achieved by simply iterating over the list
and "unlinking" the relevant pair. We also don't perform all the
checks on this internal function.

This function might modify the environment passed as reference by
argument. We only return a non-nil answer (which is the same
environment, but modified) if and only if the unbinding was
successful.

#+begin_src C
Bel*
bel_env_unbind(Bel **env, Bel *sym)
{
    if(bel_nilp(*env)) {
        return bel_g_nil;
    }
    
    // If first element is a match, return
    // cdr of environment
    if(bel_idp(bel_car(bel_car(*env)), sym)) {
        ,*env = bel_cdr(*env);
        return bel_g_t;
    }

    // Iterate looking at the next element always.
    // If next element is a match, set current cdr
    // to cdr of next element
    Bel *itr = *env;
    while(!bel_nilp(bel_cdr(itr))) {
        Bel *p = bel_car(bel_cdr(itr));
        if(bel_idp(bel_car(p), sym)) {
            itr->pair->cdr = p->pair->cdr;
            return bel_g_t;
        }
        
        itr = bel_cdr(itr);
    }

    // On no substitution, return nil
    return bel_g_nil;
}
#+end_src

The assignment operation itself respects the hierarchy of
environments, to be described in the next subsection. We attempt to
make an assignment on the three kinds of environment (lexical -- given
as argument --, dynamic and global). If the assignment fails in any of
these, the symbol is bound to the given new value, on the /global/
environment.

#+begin_src C
Bel*
bel_assign(Bel *lenv, Bel *sym, Bel *new_val)
{
    Bel *ret;

    // Dynamic assignment
    ret = bel_env_replace_val(bel_g_dynae, sym, new_val);
    if(!bel_nilp(ret)) return sym;
    
    // Lexical assignment
    ret = bel_env_replace_val(lenv, sym, new_val);
    if(!bel_nilp(ret)) return sym;

    // Global assignment
    ret = bel_env_replace_val(bel_g_globe, sym, new_val);
    if(!bel_nilp(ret)) return sym;

    // When not assignment was made, we push a global value
    bel_g_globe = bel_env_push(bel_g_globe, sym, new_val);
    return sym;
}
#+end_src

We proceed by the same principle for the actual unbinding function: we
respect the hierarchy of environments. Like =bel_env_unbind=, this
function might modify the passed environment, and that is why we take
a reference to it.

#+begin_src C
Bel*
bel_unbind(Bel **lenv, Bel *sym)
{
    Bel *ans;

    // Dynamic unbinding
    ans = bel_env_unbind(&bel_g_dynae, sym);
    if(!bel_nilp(ans)) {
        return sym;
    }
    
    // Lexical unbinding
    ans = bel_env_unbind(lenv, sym);
    if(!bel_nilp(ans)) {
        return sym;
    }

    // Global unbinding
    ans = bel_env_unbind(&bel_g_globe, sym);
    if(!bel_nilp(ans)) {
        return sym;
    }

    // On no unbinding, return nil
    return bel_g_nil;
}
#+end_src

*** Types and hierarchy of environments

There are three kinds of environments in Bel: Global, Lexical and
Dynamic. The global environment (=bel_g_globe=, =globe=) contains symbols
which are always visible from all scopes. This environment lives for
the lifetime of the interpreter.

The lexical environment (=bel_g_scope=, =scope=) contains symbols which
are visible only inside the current scope, and lives for a short
period of time, linked to its scope. It is the environment captured by
closures, and also the environment created when a closure is applied
(as a specific symbol is bound to evaluate a closure's body).

The dynamic environment (=bel_g_dynae=) is like the global environment
on its regards to access (symbols are visible to the whole
application). However, the dynamic environment lives for a short
period of time, linked to the scope it is used.

In Bel, any symbol lookup is performed by traversing the environments
in the following order: /Dynamic/, /Lexical/, /Global/.

*** Environment extension and capturing

Being a sequential list of pairs, where the values are pushed to their
top, environments (such as the lexical) can share symbols. For
example, suppose the following closure called =orig-fun=.

#+begin_example lisp
(def orig-fun (x y)
  (join (new-fun x) y))
#+end_example

Suppose further that this closure is applied to the symbols =foo= and
=bar=. They are then bound respectively to =x= and =y=. The closure's
lexical environment during application would look like this:

#+begin_example lisp
((y . bar)  (x . foo))
#+end_example

Suppose also that the closure =new-fun= is defined like this:

#+begin_example lisp
(def new-fun (x)
  (id x 'foo))
#+end_example

When =new-fun= is applied inside =orig-fun=, it captures =orig-fun='s
lexical environment. Additionally, =new-fun= binds =foo= (associated with
the original =x= symbol) to a new =x= symbol. So =new-fun='s lexical
environment looks like this:

#+begin_example lisp
((x . foo)  (y . bar)  (x . foo))
#+end_example

Since the environment stacks up definitions, a lookup process begins
at top (here displayed as the leftmost pair) and finds the first
binding of the requested symbol that it can find. So in =new-fun=, the
value associated to the symbol =x= can only be the first pair
represented above; however, after the evaluation of =new-fun=, back at
=orig-fun=, the associated value of =x= would be the last pair.

Another interesting fact is that, if =new-fun= were to make a blind
assignment to =y= after being called inside =orig-fun=, =y='s associated
value would be changed in =orig-fun='s lexical environment, so the
new value of =y= would be seen not only at =new-fun=; it would still be
different when we returned to =orig-fun=.

If =new-fun= were called from outside =orig-fun= (more specifically, at
top level), such assignment to =y= would create a new binding on the
global environment, effectively creating a new global variable.

** Literals

Although literals have already been seen on error implementation, but
here we reuse the concept to generate literals that should exist on
the global environment.

A /literal/ is a list, where the first element is the symbol
=lit=. Literals are described like persistent quotes, since evaluating a
quoted form strips away the quoting. A /literal/ is what should be used
to describe things that evaluate to themselves.

Literals follow the form =(lit . rest)=, where =lit= is a symbol, and =rest=
is a proper list of things that should be treated as a literal.

Primitives and functions are internally described as /literals/.

The first thing to do is create a tool for generating a literal; in
general, what it does is create a pair, where the /car/ is the symbol
=lit=, and the /cdr/ is anything that should be treated as a literal.

#+begin_src C
Bel*
bel_mkliteral(Bel *rest)
{
    if(!bel_proper_list_p(rest)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a "
                         "proper list to be turned "
                         "into a literal."),
            bel_mkpair(rest, bel_g_nil));
    }

    return bel_mkpair(bel_mksymbol("lit"),
                      rest);
}
#+end_src

*** Primitives

As stated above, primitives are represented as literals, since they
evaluate to themselves. We start by defining a tool to create a
certain primitive; it should be noted that, since primitives are
internal to the Bel implementation, this function does not check for
errors.

A primitive has the form =(lit prim name)=, where =lit= and =prim= are
constant symbols, and =name= is a symbol for the primitive name.

#+begin_src C
Bel*
bel_mkprim(Bel *sym)
{
    return bel_mkliteral(
        bel_mkpair(bel_g_prim,
                   bel_mkpair(sym, bel_g_nil)));
}
#+end_src

The next definition is a macro where, given an environment =env= and a
C string literal =x=, it generates a primitive for =x= and pushes it to
the enviroment =env=.

#+begin_src C
#define BEL_REGISTER_PRIM(env, x)               \
    {                                           \
    Bel *sym = bel_mksymbol(x);                 \
    env = bel_env_push(env, sym,                \
                       bel_mkprim(sym));        \
    }
#+end_src

Then we create a function where, given an environment =env=, it
registers all Bel primitives on it, creating a new environment which
is returned. Notice that this new environment is in fact making use of
the original one.

#+begin_src C
Bel*
bel_gen_primitives(Bel *env)
{
    // Primitive functions
    BEL_REGISTER_PRIM(env, "id");
    BEL_REGISTER_PRIM(env, "join");
    BEL_REGISTER_PRIM(env, "car");
    BEL_REGISTER_PRIM(env, "cdr");
    BEL_REGISTER_PRIM(env, "type");
    BEL_REGISTER_PRIM(env, "xar");
    BEL_REGISTER_PRIM(env, "xdr");
    BEL_REGISTER_PRIM(env, "sym");
    BEL_REGISTER_PRIM(env, "nom");
    BEL_REGISTER_PRIM(env, "wrb");
    BEL_REGISTER_PRIM(env, "rdb");
    BEL_REGISTER_PRIM(env, "ops");
    BEL_REGISTER_PRIM(env, "cls");
    BEL_REGISTER_PRIM(env, "stat");
    BEL_REGISTER_PRIM(env, "coin");
    BEL_REGISTER_PRIM(env, "sys");

    // Primitive operators
    BEL_REGISTER_PRIM(env, "+");
    BEL_REGISTER_PRIM(env, "-");
    BEL_REGISTER_PRIM(env, "*");
    BEL_REGISTER_PRIM(env, "/");
    BEL_REGISTER_PRIM(env, "<");
    BEL_REGISTER_PRIM(env, "<=");
    BEL_REGISTER_PRIM(env, ">");
    BEL_REGISTER_PRIM(env, ">=");
    BEL_REGISTER_PRIM(env, "=");

    // Other primitives
    BEL_REGISTER_PRIM(env, "err");
    
    return env;
}
#+end_src

The last step is to have a function which pushes these primitives
automatically to the =globe= environment.

#+begin_src C
void
bel_init_ax_primitives()
{
    bel_g_globe = bel_gen_primitives(bel_g_globe);
}
#+end_src

*** Closures

Creating a closure is very straightforward. We take an environment and
a list. Such list must have two elements, where the first is a lambda
list, and the second is the body of the function.

#+begin_src C
Bel*
bel_mkclosure(Bel *lenv, Bel *rest)
{
    return bel_mkliteral(
        bel_mkpair(bel_g_clo,
                   bel_mkpair(lenv, rest)));
}
#+end_src

* Printing

The following functions are used to print a certain object on standard
output.

#+TODO: Print to Bel streams?

** Forward declarations

We forward declare the =bel_print= function since printing pairs calls
it for the pairs' parts.

#+begin_src C
void bel_print(Bel*); // Forward declaration
#+end_src

** Printing pairs

The first function is a specialization for printing pairs in
general. This function should also handle the printing of lists
gracefully.

#+begin_src C
void
bel_print_pair(Bel *obj)
{
    if(bel_nilp(obj)) return;
    
    Bel *itr = obj;
    
    putchar('(');
    while(!bel_nilp(itr)) {
        Bel *car = bel_car(itr);
        Bel *cdr = bel_cdr(itr);

        bel_print(car);
        
        if(bel_nilp(cdr)) {
            break;
        } else if(cdr->type != BEL_PAIR) {
            putchar(' ');
            putchar('.');
            putchar(' ');
            bel_print(cdr);
            break;
        }
        putchar(' ');
        itr = cdr;
    }
    putchar(')');
}
#+end_src

** Printing strings

A string is a very specific type of list: it is a proper list
comprised only of characters. However, this function is not supposed
to test for the object's type; instead, it must be called when we are
certain that the object in question is a string.

#+begin_src C
void
bel_print_string(Bel *obj)
{
    putchar('\"');
    Bel *itr = obj;
    while(!bel_nilp(itr)) {
        Bel_char c = bel_car(itr)->chr;

        switch(c) {
        case '\a': printf("\\bel"); break;
        default:   putchar(c);      break;
        }

        itr = bel_cdr(itr);
    }
    putchar('\"');
}
#+end_src

** Printing streams

Printing a stream involves printing something that cannot be read back
in, so it can be considered merely aestethic. I made an option of
either printing that it is closed, or printing its status along with
the raw pointer.

#+begin_src C
void
bel_print_stream(Bel *obj)
{
    printf("#<stream :status ");
    if(obj->stream.status == BEL_STREAM_CLOSED) {
        printf("closed>");
    } else {
        switch(obj->stream.status) {
        case BEL_STREAM_READ:  printf("input ");  break;
        case BEL_STREAM_WRITE: printf("output "); break;
        default: printf("unknown ");              break;
        }
        printf("{0x%08lx}>", (uint64_t)obj->stream.raw_stream);
    }
}
#+end_src

** Printing numbers

We develop a function to print an arbitrary number. The function takes
the number itself and a parameter which tells whether the sign should
be explicit (the reason for that will be evident soon).

To print an /integer/, the only thing to do is to print a =long int=. We
prepend it with a plus if the number is positive and the explicit sign
flag is on.

To print a /float/, we print a =double= with reduced notation. If the
number is round, we append =.0= to it. We also follow the same rule of
/integers/ when prepending the plus sign.

A /fraction/ is a pair of two numbers. We just enclose them in a textual
representation like =#(f number)=, where =number= is the numerator and
the denominator separated by a slash. These two components can also be
numbers of any kind, so we print them recursively, without forcing the
plus sign.

A /complex/ is also a pair of two numbers of any kind, where the first
number is the /real/ part and the second number is the /imaginary/ part,
which multiplies =i=. So we enclose it in a textual representation like
=#(c number)=, where =number= is a complex number in the form =R+Ai=. In
this form, =R= is the real part, printed as any Bel number; =A= is the
imaginary part, but we force it to print its sign on screen, and then
we prepend it with an =i=. To force =A='s sign to appear, we call this
function recursively, with the =force_sign= flag active.

#+begin_src C
void
bel_print_number(Bel *num, int force_sign)
{
    switch(num->number.type) {
    case BEL_NUMBER_INT:
        if(force_sign && (num->number.num_int >= 0))
            putchar('+');
        printf("%ld", num->number.num_int);
        break;
    case BEL_NUMBER_FLOAT:
        if(force_sign && (num->number.num_float >= 0.0))
            putchar('+');
        printf("%lg", num->number.num_float);
        // Trailing .0 on round number
        if(num->number.num_float
           == trunc(num->number.num_float)) {
            printf(".0");
        }
        break;
    case BEL_NUMBER_FRACTION:
        printf("#(f ");
        bel_print_number(num->number.num_frac.numer, 0);
        putchar('/');
        bel_print_number(num->number.num_frac.denom, 0);
        putchar(')');
        break;
    case BEL_NUMBER_COMPLEX:
        printf("#(c ");
        bel_print_number(num->number.num_frac.numer, 0);
        bel_print_number(num->number.num_frac.denom, 1);
        printf("i)");
        break;
    default:
        printf("#<\?\?\?>");
        break;
    }
}
#+end_src

** Generic printing

The next function handles the printing of any data type. Notice that
it does not automatically print a newline character.

#+begin_src C
void
bel_print(Bel *obj)
{
    switch(obj->type) {
    case BEL_SYMBOL:
        printf("%s", g_sym_table.tbl[obj->sym]);
        break;
    case BEL_PAIR:
        if(!bel_stringp(obj)) {
            bel_print_pair(obj);
        } else {
            bel_print_string(obj);
        }
        break;
    case BEL_CHAR:
        if(obj->chr == '\a')
            printf("\\bel"); // There is no Bel without \bel
        else printf("\\%c", obj->chr);
        break;
    case BEL_STREAM:
        bel_print_stream(obj);
        break;
    case BEL_NUMBER:
        bel_print_number(obj, 0);
        break;
    default:
        printf("#<\?\?\?>"); // wat
        break;
    };
}
#+end_src

* Evaluator

The evaluator is the most crucial part of the Bel system. We follow
the pattern of the /metacircular evaluator/: by having two functions,
=eval= and =apply=, we make them call themselves mutually, equipping
them with auxiliary functions and special forms to produce a working
interpreter for a Lisp language.

** Forward declarations

These declarations specify the most crucial functions of the
interpreter. Forward declarations are important for the mutual calling
part.

#+begin_src C
Bel *bel_eval(Bel *exp, Bel *lenv);             // Forward declaration
Bel *bel_apply(Bel *proc, Bel *args);           // Forward declaration
Bel *bel_evlist(Bel *elist, Bel *lenv);         // Forward declaration
Bel *bel_apply_primop(Bel *sym, Bel *args);     // Forward declaration
Bel *bel_bind(Bel *vars, Bel *vals, Bel *lenv); // Forward declaration
#+end_src

The following forward declarations are related to /special forms/ on the
evaluator. These special forms are handled outside of the /eval/
function to make it more succint.

#+begin_src C
Bel *bel_special_if(Bel *exp, Bel *lenv);       // Forward declaration
Bel *bel_special_quote(Bel *exp, Bel *lenv);    // Forward declaration
#+end_src

** The /eval/ function

=bel_eval= is the /evaluation/ function. The objective is to take a
particular expression, identify what it is (whether it is a special
form or a simple function application), and dispatch it
accordingly.

When a simple application is performed, we take a list and consider
that the first element is the symbol that the function is bound to. So
we evaluate every element of the list, including the function, and
then we /apply/ the closure (produced by evaluation of the function) to
the rest of the evaluated elements, which will be passed as
arguments.

It is also important to notice that the closure captures the lexical
environment where it is evaluated.

#+begin_src C
Bel*
bel_eval(Bel *exp, Bel *lenv)
{
#ifdef BEL_DEBUG
    printf("eval>  ");
    bel_print(exp);
    putchar(10);
#endif

    // numbers eval to themselves
    if(bel_numberp(exp))
        return exp;
    
    // symbol
    if(bel_symbolp(exp)) {
        // If one of axiom symbols, eval to itself
        if(bel_idp(exp, bel_g_nil)
           || bel_idp(exp, bel_g_t)
           || bel_idp(exp, bel_g_o)
           || bel_idp(exp, bel_g_apply))
            return exp;
        // else lookup on table
        return bel_lookup(lenv, exp);
    }

    // quote
    if(bel_quotep(exp))
        return bel_special_quote(exp, lenv);
    
    // lit
    else if(bel_literalp(exp))
        return exp; // eval to itself

    // string
    else if(bel_stringp(exp))
        return exp; // eval to itself

    // Special forms
    else if(bel_proper_list_p(exp)) {
        // fn: closure
        if(bel_idp(bel_car(exp), bel_mksymbol("fn")))
            return bel_mkclosure(lenv, bel_cdr(exp));
    
        // if
        if(bel_idp(bel_car(exp), bel_mksymbol("if")))
            return bel_special_if(exp, lenv);

        // TODO:
        // apply
        // where (not straightforward)
        // dyn (dynamic binding)
        // after
        // set (global binding)
        // ccc (call/cc)
        // thread

        // otherwise it is the case of an application
        return bel_apply(bel_eval(bel_car(exp), lenv),
                         bel_evlist(bel_cdr(exp), lenv));
    }

    return bel_mkerror(
        bel_mkstring("~a is not a proper list "
                     "for the application of "
                     "a function."),
        bel_mkpair(exp, bel_g_nil));
}
#+end_src

*** Evaluating special forms

Some special forms require greater attention, and so it is a little
better to give them their own function.

**** =(if . clauses)=

The conditional =if= takes any number of clauses (at least two), and
does their evaluation in pairs of clauses (not to be confused with the
pair data type).

Suppose that we have a conditional such as

#+begin_example lisp
(if cond1 pred1 cond2 pred2)
#+end_example

We evaluate =cond1=. If its result is not =nil=, we return the evaluation
of =pred1=.

If evaluation of =cond1= is =nil=, however, we don't evaluate =pred1=; we
proceed to test the evaluation of =cond2=. If =cond2= yields a non-=nil=
result, however, we return the evaluation of =pred2=.

There can also be a different scenario, where the number of clauses is
odd, like

#+begin_example lisp
(if cond1 pred1 cond2 pred2 altern)
#+end_example

If, during evaluation, =cond2= did not yield a non-=nil= result, then
=pred2= would be skipped; however, as there are no more pairs, but only
the a single =altern= clause, it will be evaluated and its results will
be returned, as an alternative.

#+begin_src C
Bel*
bel_special_if(Bel *exp, Bel *lenv)
{
    Bel *body       = bel_cdr(exp);
    uint64_t length = bel_length(body);

    if(length < 2) {
        return bel_mkerror(
            bel_mkstring("if statement must have at "
                         "least one predicate with "
                         "a consequent."),
            bel_g_nil);
    }

    Bel *predicate;
    Bel *consequent;
            
    while(1) {
        predicate  = bel_car(body);
        consequent = bel_car(bel_cdr(body));
        body = bel_cdr(bel_cdr(body));

        // nil consequent = return-eval predicate
        if(bel_nilp(consequent)) {
            return bel_eval(predicate, lenv);
        }

        if(!bel_nilp(bel_eval(predicate, lenv))) {
            return bel_eval(consequent, lenv);
        }
    }
            
    return bel_g_nil;
}
#+end_src

**** =(quote x)=

In Lisp languages, quoting an atom, like the expression ='a=, translates
to an expression such as =(quote a)=, which will then be evaluated by
returning only the symbol =a=.

#+begin_src C
Bel*
bel_special_quote(Bel *exp, Bel *lenv)
{
    uint64_t len = bel_length(exp);
    if(len != 2) {
        return bel_mkerror(
            bel_mkstring("Malformed quote: can only "
                         "quote one object."),
            bel_g_nil);
    }

    return bel_car(bel_cdr(exp));
}
#+end_src

** The /apply/ function

=bel_apply= is the /application/ function. It takes a certain /function/ and
applies to the /list of evaluated arguments/. A function can be a
primitive, but can also be a /literal closure/.

To apply a /closure/, we bind all arguments to the closure's formal
parameters, creating an extended lexical environment; then we proceed
to evaluate the closure's body under that new lexical environment.

#+begin_src C
Bel*
bel_apply(Bel *fun, Bel *args)
{
#ifdef BEL_DEBUG
    printf("apply> ");
    bel_print(fun);
    printf(" at ");
    bel_print(args);
    putchar(10);
#endif
    
    // Check for errors on fun
    if(bel_errorp(fun)) {
        return fun;
    }
    
    // Primitive procedure
    else if(bel_primitivep(fun)) {
        return bel_apply_primop(
            bel_car(bel_cdr(bel_cdr(fun))),
            args);
    }
    
    // Closure
    else if(bel_closurep(fun)) {
        Bel *lenv =
            bel_car(
                bel_cdr(bel_cdr(fun)));
        Bel *lambda_list =
            bel_car(
                bel_cdr(bel_cdr(bel_cdr(fun))));
        Bel *body =
            bel_car(
                bel_cdr(bel_cdr(bel_cdr(
                                    bel_cdr(fun)))));
        
        // Generate a new environment with the
        // arguments bound in it
        Bel *new_env = bel_bind(lambda_list,
                                args,
                                lenv);

        if(bel_errorp(new_env)) {
            return new_env;
        }

        // Evaluate body on the new environment
        return bel_eval(body, new_env);
    }

    // Error
    else {
        return bel_mkerror(
            bel_mkstring("~a is not a procedure"),
            bel_mkpair(fun, bel_g_nil));
    }
}
#+end_src

** Auxiliary functions

The following functions are also essential to the evaluator, but have
a more secondary role, such as handling special forms, applying
primitive operators, and other kinds of things.

*** Evaluate a list of values

=bel_evlist= evaluates a list of expressions under the given lexical
environment. This function should only be called for a proper list.

#+begin_src C
Bel*
bel_evlist(Bel *elist, Bel *lenv)
{
    if(bel_nilp(elist)) {
        return bel_g_nil;
    }

    Bel *eval_result =
        bel_eval(bel_car(elist), lenv);

    if(bel_errorp(eval_result)) {
        return eval_result;
    }

    Bel *ev_rest =
        bel_evlist(bel_cdr(elist), lenv);

    if(bel_errorp(ev_rest)) {
        return ev_rest;
    }

    return bel_mkpair(eval_result, ev_rest);
}
#+end_src

*** Apply a primitive operator to a list

Applying a primitive to a list involves checking for the symbol which
specifies it and dispatching the arguments to a specific function
which checks arity and performs the job.

**** Forward declarations

These forward declarations are related to the actual implementation of
primitive functions in the Bel environment. We forward-declare them so
that we can define a function which redirects to each one of them, and
after that we give their proper definitions.

#+begin_src C
// Forward declarations of primitive functions
Bel *bel_prim_id(Bel *args);
Bel *bel_prim_join(Bel *args);
Bel *bel_prim_car(Bel *args);
Bel *bel_prim_cdr(Bel *args);
Bel *bel_prim_type(Bel *args);
Bel *bel_prim_xar(Bel *args);
Bel *bel_prim_xdr(Bel *args);
Bel *bel_prim_sym(Bel *args);
Bel *bel_prim_nom(Bel *args);
Bel *bel_prim_wrb(Bel *args);
Bel *bel_prim_rdb(Bel *args);
Bel *bel_prim_ops(Bel *args);
Bel *bel_prim_cls(Bel *args);
Bel *bel_prim_stat(Bel *args);
Bel *bel_prim_coin(Bel *args);
Bel *bel_prim_sys(Bel *args);

// Forward declarations of primitive operators
Bel *bel_prim_add(Bel *args);
Bel *bel_prim_sub(Bel *args);
Bel *bel_prim_mul(Bel *args);
Bel *bel_prim_div(Bel *args);
//Bel *bel_prim_less(Bel *args);
//Bel *bel_prim_leq(Bel *args);
//Bel *bel_prim_great(Bel *args);
//Bel *bel_prim_geq(Bel *args);
//Bel *bel_prim_eq(Bel *args);

//  Forward declarations of other primitives
Bel *bel_prim_err(Bel *args);
#+end_src

**** Applying primitive operations

The =bel_apply_primop= function is the function which applies a
primitive operation, identified as a symbol, to a list of evaluated
values. It is important to know that this function does not usually do
the job; instead, we just dispatch the arguments to a function which
will perform as needed.

The macro =bel_is_prim= compares whether =sym= is the symbol which
represents the literal =lit=.

#+begin_src C
#define bel_is_prim(sym, lit)                     \
    (bel_idp(sym, bel_mksymbol(lit)))
#+end_src

The macro =bel_unimplemented= takes the symbol =sym= for a primitive
function and generates an error, stating that the function has not
been implemented. This is important while the interpreter is under
development.

#+begin_src C
#define bel_unimplemented(sym)                                  \
    bel_mkerror(                                                \
    bel_mkstring("~a is not implemented."),                     \
    bel_mkpair(sym, bel_g_nil))
#+end_src

=bel_apply_primop= is the crucial function for the operations described
above. It enumerates the core functions and dispatches the arguments
accordingly.

Notice that an attempt to apply a primitive operation which does not
exist results in error.

#+begin_src C
Bel*
bel_apply_primop(Bel *sym, Bel *args)
{
    // Primitive functions
    if(bel_is_prim(sym, "id"))        return bel_prim_id(args);
    else if(bel_is_prim(sym, "join")) return bel_prim_join(args);
    else if(bel_is_prim(sym, "car"))  return bel_prim_car(args);
    else if(bel_is_prim(sym, "cdr"))  return bel_prim_cdr(args);
    else if(bel_is_prim(sym, "type")) return bel_prim_type(args);
    else if(bel_is_prim(sym, "xar"))  return bel_prim_xar(args);
    else if(bel_is_prim(sym, "xdr"))  return bel_prim_xdr(args);
    else if(bel_is_prim(sym, "sym"))  return bel_prim_sym(args);
    else if(bel_is_prim(sym, "nom"))  return bel_prim_nom(args);
    else if(bel_is_prim(sym, "wrb"))  return bel_prim_wrb(args);
    else if(bel_is_prim(sym, "rdb"))  return bel_prim_rdb(args);
    else if(bel_is_prim(sym, "ops"))  return bel_prim_ops(args);
    else if(bel_is_prim(sym, "cls"))  return bel_prim_cls(args);
    else if(bel_is_prim(sym, "stat")) return bel_prim_stat(args);
    else if(bel_is_prim(sym, "coin")) return bel_prim_coin(args);
    else if(bel_is_prim(sym, "sys"))  return bel_prim_sys(args);

    // Primitive operators
    else if(bel_is_prim(sym, "+"))    return bel_prim_add(args);
    else if(bel_is_prim(sym, "-"))    return bel_prim_sub(args);
    else if(bel_is_prim(sym, "*"))    return bel_prim_mul(args);
    else if(bel_is_prim(sym, "/"))    return bel_prim_div(args);
    else if(bel_is_prim(sym, "<"))    return bel_unimplemented(sym);
    else if(bel_is_prim(sym, "<="))   return bel_unimplemented(sym);
    else if(bel_is_prim(sym, ">"))    return bel_unimplemented(sym);
    else if(bel_is_prim(sym, ">="))   return bel_unimplemented(sym);
    else if(bel_is_prim(sym, "="))    return bel_unimplemented(sym);
    
    // Other primitives
    else if(bel_is_prim(sym, "err"))  return bel_prim_err(args);

    // Otherwise, unknown application operation
    else {
        return bel_mkerror(
            bel_mkstring("Unknown primitive ~a."),
            bel_mkpair(sym, bel_g_nil));
    }
}
#+end_src

**** Maximum arity check

The following macro is a helper for checking the arity of a specific
function. Passing the arguments list and the number of desired
arguments performs such a check. If the arity is greater than the
given number, it returns an error complaining about it.

Notice that this macro expects two things: to be called inside a
function that returns a =Bel*= type, and that the arguments themselves
are a /proper list/.

It is also important to notice that Bel specifies that, when handling
primitives, missing arguments default to =nil=, therefore passing less
arguments than expected is not considered an error; since collecting
arguments is handled by =bel_car= and =bel_cdr=, the missing arguments are
guaranteed to be =nil= when retrieval is attempted.

#+begin_src C
#define BEL_CHECK_MAX_ARITY(args, num)                  \
    {                                                   \
    uint64_t length = bel_length(args);                 \
    if(length > num) {                                  \
    return bel_mkerror(                                 \
        bel_mkstring("Arity error"), bel_g_nil);        \
    }                                                   \
    }
#+end_src

**** Primitive functions

The next functions implement primitive functions for the environment.

***** =(id x y)=

=id= checks whether =x= and =y= are identical. This is stricter than
equality, since identity can only be tested for things that are always
the same -- namely, characters and symbols.

#+begin_src C
Bel*
bel_prim_id(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    return (bel_idp(bel_car(args),
                    bel_car(bel_cdr(args)))
            ? bel_g_t : bel_g_nil);
}
#+end_src

***** =(join x y)=

=join= creates a pair with =x= as its /car/ and =y= as its /cdr/.

#+begin_src C
Bel*
bel_prim_join(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    return bel_mkpair(bel_car(args),
                      bel_car(bel_cdr(args)));
}
#+end_src

***** =(car x)= and =(cdr x)=

=car= returns the first element of a pair =x=.

#+begin_src C
Bel*
bel_prim_car(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    return bel_car(bel_car(args));
}
#+end_src

=cdr= returns the second element of a pair =x=.

#+begin_src C
Bel*
bel_prim_cdr(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    return bel_cdr(bel_car(args));
}
#+end_src

***** =(type x)=

=type= returns a symbol which specifies the type of =x=. The returning
values can be =symbol=, =pair=, =char=, =stream= or =number=.

#+begin_src C
Bel*
bel_prim_type(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    switch(bel_car(args)->type) {
    case BEL_SYMBOL: return bel_mksymbol("symbol");  break;
    case BEL_PAIR:   return bel_mksymbol("pair");    break;
    case BEL_CHAR:   return bel_mksymbol("char");    break;
    case BEL_STREAM: return bel_mksymbol("stream");  break;
    case BEL_NUMBER: return bel_mksymbol("number");  break;
    default:         return bel_mksymbol("unknown"); break;
    };
}
#+end_src

***** =(xar x y)= and =(xdr x y)=

=xar= replaces the /car/ of a pair =x= with the given value =y=.

#+begin_src C
Bel*
bel_prim_xar(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    Bel *pair = bel_car(args);
    Bel *val  = bel_car(bel_cdr(args));
    if(!bel_pairp(pair)) {
        return bel_mkerror(
            bel_mkstring("~a is not a pair."),
            bel_mkpair(pair, bel_g_nil));
    }

    pair->pair->car = val;
    return val;
}
#+end_src

=xdr= replaces the /cdr/ of a pair =x= with the given value =y=.

#+begin_src C
Bel*
bel_prim_xdr(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    Bel *pair = bel_car(args);
    Bel *val  = bel_car(bel_cdr(args));
    if(!bel_pairp(pair)) {
        return bel_mkerror(
            bel_mkstring("~a is not a pair."),
            bel_mkpair(pair, bel_g_nil));
    }

    pair->pair->cdr = val;
    return val;
}
#+end_src

***** =(sym x)= and =(nom x)=

=sym= takes a Bel string and converts it into a symbol.

#+begin_src C
Bel*
bel_prim_sym(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *str = bel_car(args);
    if(!bel_stringp(str)) {
        return bel_mkerror(
            bel_mkstring("The object ~a must be a string."),
            bel_mkpair(str, bel_g_nil));
    }

    char *cstr = bel_cstring(str);
    if(!cstr || !strcmp(cstr, "")) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a proper string."),
            bel_mkpair(str, bel_g_nil));
    }

    return bel_mksymbol(cstr);
}
#+end_src

=nom= takes a symbol and discovers its name as a Bel string.

#+begin_src C
Bel*
bel_prim_nom(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *sym = bel_car(args);
    if(!bel_symbolp(sym)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a string."),
            bel_mkpair(sym, bel_g_nil));
    }

    return bel_mkstring(
        bel_sym_find_name(sym));
}
#+end_src

***** =(wrb x y)= and =(rdb x)=

=wrb= and =rdb= are functions responsible for input and output on a
stream.

=wrb= takes a bit =x= and a stream =y=, and writes that bit to the
stream. If the stream is =nil=, it writes instead to =outs=.

#+begin_src C
Bel*
bel_prim_wrb(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    Bel *x = bel_car(args);
    Bel *y = bel_car(bel_cdr(args));

    if(!bel_charp(x)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a character."),
            bel_mkpair(x, bel_g_nil));
    }

    if(bel_nilp(y)) {
        y = bel_lookup(bel_g_nil, bel_mksymbol("outs"));
    } else {
        if(!bel_streamp(y)) {
            return bel_mkerror(
                bel_mkstring("The object ~a must be a stream."),
                bel_mkpair(y, bel_g_nil));
        }
    }

    return bel_stream_write_bit(&y->stream, y->chr);
}
#+end_src

=rdb= simply reads a bit from the stream =x=.

#+begin_src C
Bel*
bel_prim_rdb(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *x = bel_car(args);

    if(bel_nilp(x)) {
        bel_lookup(bel_g_nil, bel_mksymbol("ins"));
    } else {
        if(!bel_streamp(x)) {
            return bel_mkerror(
                bel_mkstring("The object ~a must be a stream."),
                bel_mkpair(x, bel_g_nil));
        }
    }

    return bel_stream_read_bit(&x->stream);
}
#+end_src

***** =(ops x y)=, =(cls x)= and =(stat x)=

=ops=, =cls= and =stat= are functions related to the status of a stream.

=ops= opens a stream to the file =x=, depending on the direction specified
by symbol =y=, which can be either =in= or =out=.

#+begin_src C
Bel*
bel_prim_ops(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    Bel *x = bel_car(args);
    Bel *y = bel_car(bel_cdr(args));

    if(!bel_stringp(x)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a string."),
            bel_mkpair(x, bel_g_nil));
    }

    if(!bel_symbolp(y)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a symbol."),
            bel_mkpair(y, bel_g_nil));
    }

    if(bel_idp(y, bel_mksymbol("in"))) {
        return bel_mkstream(bel_cstring(x), BEL_STREAM_READ);
    } else if(bel_idp(y, bel_mksymbol("out"))) {
        return bel_mkstream(bel_cstring(x), BEL_STREAM_WRITE);
    }

    return bel_mkerror(
        bel_mkstring("The object ~a is not one of the "
                     "symbols `in` and `out`."),
        bel_mkpair(y, bel_g_nil));
}
#+end_src

=cls= closes a stream =x=, as long as it is open. If it was closed,
returns =t=; if it is already closed, returns =nil=.

#+begin_src C
Bel*
bel_prim_cls(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *stream = bel_car(args);

    if(!bel_streamp(stream)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a stream."),
            bel_mkpair(stream, bel_g_nil));
    }

    if(stream->stream.status == BEL_STREAM_CLOSED) {
        return bel_g_nil;
    }

    return bel_stream_close(stream);
}
#+end_src

=stat= takes a stream =x= and gives back symbols =closed=, =in= or =out=,
depending on stream status.

#+begin_src C
Bel*
bel_prim_stat(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *stream = bel_car(args);
    if(!bel_streamp(stream)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a stream."),
            bel_mkpair(stream, bel_g_nil));
    }

    switch(stream->stream.status) {
    case BEL_STREAM_CLOSED: return bel_mksymbol("closed");
    case BEL_STREAM_READ:   return bel_mksymbol("in");
    case BEL_STREAM_WRITE:  return bel_mksymbol("out");
    default: // ...wat
        return bel_mkerror(
            bel_mkstring("The stream ~a has an unknown "
                         "status."),
            bel_mkpair(stream, bel_g_nil));
    }
}
#+end_src

***** =(coin)=

=coin= returns symbols =t= and =nil= at random.

#+begin_src C
Bel*
bel_prim_coin(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 0);
    return (rand() % 2) ? bel_g_t : bel_g_nil;
}
#+end_src

***** =(sys x)=

=sys= takes a string =x= and sends it to the operational system, as a
console command, and returns the command's value as a proper Bel
number.

Number types are non-standard to the Bel language, however Bel does
not specify the return value of =sys=, therefore we have a degree of
freedom to specify that the return of =sys= is a number.

This function specifically is somewhat a matter of concern, because it
opens up for the execution of an arbitrary command on the operational
system.

#+begin_src C
Bel*
bel_prim_sys(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);

    Bel *str = bel_car(args);
    
    if(!bel_stringp(str)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a string."),
            bel_mkpair(str, bel_g_nil));
    }
    
    const char *com = bel_cstring(str);

    int64_t ret = system(com);

    return bel_mkinteger(ret);
}
#+end_src

**** Primitive operators

These primitive operations take an arbitrary number of arguments and
does the desired operation across the given values.

***** Addition

Adds all given values on the list, reducing them to a single
number. If not argument is given, returns =0=. If called with a single
argument, it returns that single argument (identity).

#+begin_src C
Bel*
bel_prim_add(Bel *args)
{
    if(!bel_number_list_p(args)) {
        return bel_mkerror(
            bel_mkstring("Cannot add a non-number."),
            bel_g_nil);
    }

    uint64_t length = bel_length(args);
    // No args: return 0
    if(length == 0) {
        return bel_mkinteger(0);
    }

    // One arg: identity
    if(length == 1) {
        return bel_car(args);
    }

    Bel *ret = bel_car(args);
    Bel *itr = bel_cdr(args);
    while(!bel_nilp(itr)) {
        ret = bel_num_add(ret, bel_car(itr));
        itr = bel_cdr(itr);
    }

    return ret;
}
#+end_src

***** Subtraction

Subtracts all given values on the list, reducing them to a single
number. If no argument is given, returns an error. If called with a
single argument, inverts that argument, multiplying it by =-1=.

#+begin_src C
Bel*
bel_prim_sub(Bel *args)
{
    if(!bel_number_list_p(args)) {
        return bel_mkerror(
            bel_mkstring("Cannot subtract a "
                         "non-number."),
            bel_g_nil);
    }

    uint64_t length = bel_length(args);
    // No args: error
    if(length == 0) {
        return bel_mkerror(
            bel_mkstring("Subtraction takes at "
                         "least one argument."),
            bel_g_nil);
    }

    // One arg: invert
    if(length == 1) {
        return bel_num_mul(bel_mkinteger(-1),
                           bel_car(args));
    }

    Bel *ret = bel_car(args);
    Bel *itr = bel_cdr(args);
    while(!bel_nilp(itr)) {
        ret = bel_num_sub(ret, bel_car(itr));
        itr = bel_cdr(itr);
    }

    return ret;
}
#+end_src

***** Multiplication

Multiplies all given values on the list, reducing them to a single
number. If no argument is given, returns =1=. If called with a single
argument, returns that single argument (identity).

#+TODO: Maybe return the signal, like APL?

#+begin_src C
Bel*
bel_prim_mul(Bel *args)
{
    if(!bel_number_list_p(args)) {
        return bel_mkerror(
            bel_mkstring("Cannot multiply a "
                         "non-number."),
            bel_g_nil);
    }

    uint64_t length = bel_length(args);
    // No args: return 1
    if(length == 0) {
        return bel_mkinteger(1);
    }

    // One arg: identity
    if(length == 1) {
        return bel_car(args);
    }

    Bel *ret = bel_car(args);
    Bel *itr = bel_cdr(args);
    while(!bel_nilp(itr)) {
        ret = bel_num_mul(ret, bel_car(itr));
        itr = bel_cdr(itr);
    }

    return ret;
}
#+end_src

***** Division

Divides all given arguments on the given list, reducing them to a
single number. If no argument is given, returns an error. If called
with a single argument, returns the argument's reciprocal (=1/x=).

If any division yields an error (e.g. a division by zero), returns
that error immediately.

#+begin_src C
Bel*
bel_prim_div(Bel *args)
{
    if(!bel_number_list_p(args)) {
        return bel_mkerror(
            bel_mkstring("Cannot divide a "
                         "non-number."),
            bel_g_nil);
    }

    uint64_t length = bel_length(args);
    // No args: error
    if(length == 0) {
        return bel_mkerror(
            bel_mkstring("Division takes at "
                         "least one argument."),
            bel_g_nil);
    }

    // One arg: reciprocal
    if(length == 1) {
        return bel_num_div(bel_mkinteger(1),
                           bel_car(args));
    }

    Bel *ret = bel_car(args);
    Bel *itr = bel_cdr(args);
    while(!bel_nilp(itr)) {
        ret = bel_num_div(ret, bel_car(itr));

        // If there is a division by zero
        // or something, return immediately
        if(bel_errorp(ret)) {
            return ret;
        }
        
        itr = bel_cdr(itr);
    }

    return ret;
}
#+end_src

***** COMMENT Equality

***** COMMENT Comparision

**** Other primitives

These primitives are not specified in the Bel language, but are useful.

***** =(err x . rest)=

=err= creates an error using =x= as a format string, and appends the =rest=
to the error as format arguments.

There is no arity check in =err=, though we do verify whether the first
argument is a string. Problems with the arguments should appear when
printing the error.

#+begin_src C
Bel*
bel_prim_err(Bel *args)
{
    Bel *string = bel_car(args);
    if(!bel_stringp(string)) {
        return bel_mkerror(
            bel_mkstring("First argument of `err` must "
                         "be a string format."),
            bel_g_nil);
    }

    // TODO: Maybe quote?
    return bel_mkerror(string, bel_cdr(args));
}
#+end_src

*** Bind a list of variables to values

=bel_bind= binds each variable to an associated value. If the binding
fails at any point, an error is returned; if not, a new environment
with the bindings is returned.

#+begin_src C
Bel*
bel_bind(Bel *vars, Bel *vals, Bel *lenv)
{
    int vars_ended = bel_nilp(vars);
    int vals_ended = bel_nilp(vals);

    if(vars_ended && !vals_ended) {
        return bel_mkerror(
            bel_mkstring("Too few variables in "
                         "function application"),
            bel_g_nil);
    } else if(!vars_ended && vals_ended) {
        return bel_mkerror(
            bel_mkstring("Too few values in "
                         "function application"),
            bel_g_nil);
    } else if(vars_ended && vals_ended) {
        return lenv;
    }

    Bel *binding = bel_mkpair(bel_car(vars),
                              bel_car(vals));

    return bel_bind(bel_cdr(vars),
                    bel_cdr(vals),
                    bel_mkpair(binding, lenv));
}
#+end_src

* COMMENT Parser
* COMMENT Interpreter
* Debug

The following definitions are related to testing what we have so
far.

** Tests
*** String manipulation and printing

A string test which shows the conversion between C strings and Bel
strings, and vice-versa.

#+begin_src C
void
string_test()
{
    Bel *bel  = bel_mkstring("Hello, Bel!");
    bel_print(bel);
    printf(" => %s\n", bel_cstring(bel));

    bel = bel_mkstring("There is no Bel without \a");
    bel_print(bel);
    putchar(10);
}
#+end_src

*** List/pair/dotted list notation

The following notation tests the printing capabilities of the list
printing algorithm. Should be able to handle printing lists and
dot-notation when necessary.

The data input reads as =((foo . bar) . (baz . quux))=, but the expected
output is =((foo . bar) baz . quux)=.

#+begin_src C
void
notation_test()
{
    Bel*
    bel = bel_mkpair(bel_mkpair(bel_mksymbol("foo"),
                                bel_mksymbol("bar")),
                     bel_mkpair(bel_mksymbol("baz"),
                                bel_mksymbol("quux")));
    bel_print(bel);
    putchar(10);
}
#+end_src

*** Proper list notation

This next test outputs the list =(The quick brown fox jumps over the
lazy dog)=, which is a proper list of symbols.

#+begin_src C
void
list_test()
{
    Bel*
    bel = bel_mkpair(
        bel_mksymbol("The"),
        bel_mkpair(
            bel_mksymbol("quick"),
            bel_mkpair(
                bel_mksymbol("brown"),
                bel_mkpair(
                    bel_mksymbol("fox"),
                    bel_mkpair(
                        bel_mksymbol("jumps"),
                        bel_mkpair(
                            bel_mksymbol("over"),
                            bel_mkpair(
                                bel_mksymbol("the"),
                                bel_mkpair(
                                    bel_mksymbol("lazy"),
                                    bel_mkpair(
                                        bel_mksymbol("dog"),
                                        bel_g_nil)))))))));
    bel_print(bel);
    putchar(10);
}
#+end_src

*** Closure representation

This test is also a list of symbols, but with nested lists also. Plus,
this is a proper list, representing the internal representation of a
closure such as =(fn (x) (* x x))=. Expected output is =(lit clo nil (x)
(* x x))=.

#+begin_src C
void
closure_repr_test()
{
    Bel*
    bel = bel_mkpair(bel_mksymbol("lit"),
                     bel_mkpair(
                         bel_mksymbol("clo"),
                         bel_mkpair(
                             bel_g_nil,
                             bel_mkpair(
                                 bel_mkpair(bel_mksymbol("x"),
                                            bel_g_nil),
                                 bel_mkpair(
                                     bel_mkpair(
                                         bel_mksymbol("*"),
                                         bel_mkpair(
                                             bel_mksymbol("x"),
                                             bel_mkpair(
                                                 bel_mksymbol("x"),
                                                 bel_g_nil))),
                                     bel_g_nil)))));
    bel_print(bel);
    putchar(10);
}
#+end_src

*** Character list printing and environment lookup

This next test prints the first ten characters in the global =chars=,
which is a list of pairs, each pair =(c . d)= containing a character =c=,
and its string representation in binary =d=.

It is also interesting to notice that the =chars= global is obtained by
a lookup operation on the environment, rather than using the global
variable directly.

#+begin_src C
void
character_list_test()
{
    // Character list
    // Char: 000 (?) => "00000000"
    // Char: 001 (?) => "00000001"
    // etc
    const int first_char = 'a';
    
    Bel *bel = bel_env_lookup(bel_g_globe, bel_mksymbol("chars"));
    
    int i;

    // Get nth cdr
    for(i = 0; i < first_char; i++) {
        bel = bel_cdr(bel);
    }

    i = 'a';
    while(!bel_nilp(bel) && i < first_char + 10) {
        Bel *car = bel_car(bel);
        printf("Char: %03d (%c) => ",
               bel_car(car)->chr,
               ((Bel_char)i));
        bel_print(bel_cdr(car));
        putchar(10);
        bel = bel_cdr(bel);
        i++;
    }
}
#+end_src

*** Read file bit by bit

This test opens up the Believe C source code file as a read stream,
using Bel's stream structure, then proceeds to read ten bytes from it
(meaning that it will read 80 bits). Every eight bit will be stored in
a Bel list and then converted to a proper Bel character, which will be
displayed on screen along with its bits.

It is interesting to notice that, since the bit-reading operation
itself returns characters =\0= or =\1=, the bit list composing a character
is always a Bel string.

#+begin_src C
void
read_file_test()
{
    // We are going to read ten bytes from Bel's
    // own source code file.
    Bel *file = bel_mkstream("believe.c", BEL_STREAM_READ);

    if(bel_errorp(file)) {
        bel_print(file);
        return;
    }

    printf("Stream: ");
    bel_print(file);
    putchar(10);
    
    int n_bytes = 10;
    while(n_bytes > 0) {
        // 1 byte = 8 bits, so we make a list of
        // eight characters
        Bel **char_nodes = GC_MALLOC(8 * sizeof(Bel*));

        int i;
        for(i = 0; i < 8; i++) {
            Bel *read_char =
                bel_stream_read_bit(&file->stream);
            char_nodes[i] = bel_mkpair(read_char, bel_g_nil);
        }

        // Link nodes
        for(i = 0; i < 7; i++) {
            char_nodes[i]->pair->cdr = char_nodes[i + 1];
        }

        // Display on screen
        bel_print(char_nodes[0]);
        printf(" => ");
        bel_print(
            bel_char_from_binary(char_nodes[0]));
        putchar(10);
        
        n_bytes--;
    }

    bel_stream_close(file);
}
#+end_src

*** Display errors

We generate a few errors and grab them, then we print these errors on
screen to show their literal structure.

#+begin_src C
void
show_errors_test()
{
    Bel *err;
    
    // Unexisting file
    err = bel_mkstream("waddawaddawadda", BEL_STREAM_READ);
    bel_print(err);
    putchar(10);
    printf("Is this an error? %c\n",
           bel_errorp(err) ? 'y' : 'n');

    // Incorrect use of car and cdr
    err = bel_car(bel_g_t);
    bel_print(err); putchar(10);
    err = bel_cdr(bel_g_t);
    bel_print(err); putchar(10);

    // Incorrect generation of Bel character from binary
    /* Bel *str = bel_mkstring("110"); */
    /* err = bel_char_from_binary(str); */
    /* bel_print(err); putchar(10); */

    /* str = bel_mkstring("110a1101"); */
    /* err = bel_char_from_binary(str); */
    /* bel_print(err); putchar(10); */
}
#+end_src

*** Lookup primitives

We look up a few registered primitives in the global environment, and
print them in their literal form.

#+begin_src C
void
lookup_primitives_test()
{
    Bel *bel;
    bel = bel_lookup(bel_g_nil, bel_mksymbol("car"));
    bel_print(bel);
    putchar(10);

    bel = bel_lookup(bel_g_nil, bel_mksymbol("cdr"));
    bel_print(bel);
    putchar(10);

    bel = bel_lookup(bel_g_nil, bel_mksymbol("coin"));
    bel_print(bel);
    putchar(10);
    
    bel = bel_lookup(bel_g_nil, bel_mksymbol("stat"));
    bel_print(bel);
    putchar(10);

    // Undefined primitive
    bel_print(bel_g_nil); putchar(10);
    bel = bel_lookup(bel_g_nil, bel_mksymbol("wadawada"));
    bel_print(bel);
    putchar(10);
}
#+end_src

*** Environment tests

The first test involves creating a temporary lexical environment,
pushing a few literals, assigning values, unbinding values too.

#+begin_src C
void
lexical_environment_test()
{
    Bel *lexenv = bel_g_nil;
    Bel *ret;

    puts("    -- Registering local `foo`");
    lexenv = bel_env_push(lexenv,
                          bel_mksymbol("foo"),
                          bel_mksymbol("bar"));
    
    printf("Environment:       ");
    bel_print(lexenv);
    printf("\nLookup:            ");
    bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    putchar(10); putchar(10);

    // Assignment
    puts("    -- Assigning new value to `foo`");
    ret =
        bel_assign(lexenv,
                   bel_mksymbol("foo"),
                   bel_mkliteral(bel_mkpair(bel_mksymbol("baz"),
                                            bel_g_nil)));

    printf("Environment:       ");
    bel_print(lexenv);
    printf("\nAssignment result: ");
    bel_print(ret);
    printf("\nLookup:            ");
    bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    putchar(10); putchar(10);

    // Unbinding
    puts("    -- Unbinding `foo`");
    ret = bel_unbind(&lexenv, bel_mksymbol("foo"));
    
    printf("Environment:       ");
    bel_print(lexenv);
    printf("\nUnbinding result:  ");
    bel_print(ret);
    printf("\nLookup:            ");
    bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    putchar(10);
}
#+end_src

Second test is creating a global variable through assignment, creating
a variable bound to the same symbol on a lexical environment,
unbinding both, then performing a last invalid unbinding.

#+begin_src C
void
global_assignment_test()
{
    Bel *lexenv = bel_g_nil;
    Bel *ret;

    // Global creation through assignment
    puts("    -- Assigning `foo` without previous definition");
    ret = bel_assign(bel_g_nil,
                     bel_mksymbol("foo"),
                     bel_mksymbol("bar"));

    printf("Assignment result: ");
    bel_print(ret);
    printf("\nLookup:            ");
    bel_print(bel_lookup(bel_g_nil, bel_mksymbol("foo")));
    putchar(10); putchar(10);

    // Local creation of variable bound to
    // same symbol
    puts("    -- Shadowing global `foo` with a local");
    lexenv =
        bel_env_push(lexenv,
                     bel_mksymbol("foo"),
                     bel_mksymbol("quux"));

    printf("Environment:       ");
    bel_print(lexenv);
    printf("\nLookup:            ");
    bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));

    // Three unbindings
    printf("\n    -- Unbinding `foo` three times");
    int i;
    for(i = 0; i < 3; i++) {
        ret = bel_unbind(&lexenv, bel_mksymbol("foo"));

        printf("\n\n      After unbinding.");
        printf("\nEnvironment:       ");
        bel_print(lexenv);
        printf("\nUnbinding result:  ");
        bel_print(ret);
        printf("\nLookup:            ");
        bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    }
    putchar(10);
}
#+end_src

*** Number test

#+begin_src C
void
number_test()
{
    Bel *a;
    Bel *b;

    // Integer sum
    a = bel_mkinteger(4);
    b = bel_mkinteger(2);

    printf("(+ ");
    bel_print(a);
    putchar(' ');
    bel_print(b);
    printf(") => ");
    bel_print(bel_num_add(a, b));
    putchar(10);

    
    // Float subtraction
    a = bel_mkfloat(4.0);
    b = bel_mkfloat(3.5);

    printf("(- ");
    bel_print(a);
    putchar(' ');
    bel_print(b);
    printf(") => ");
    bel_print(bel_num_sub(a, b));
    putchar(10);


    // Fraction sum
    a = bel_mkfraction(bel_mkinteger(1),
                       bel_mkinteger(3));
    b = bel_mkfraction(bel_mkinteger(1),
                       bel_mkinteger(6));

    printf("(+ ");
    bel_print(a);
    putchar(' ');
    bel_print(b);
    printf(") => ");
    bel_print(bel_num_add(a, b));
    putchar(10);

    
    // Complex multiplication
    a = bel_mkcomplex(bel_mkinteger(3),
                      bel_mkinteger(2));
    b = bel_mkcomplex(bel_mkinteger(1),
                      bel_mkinteger(4));

    printf("(* ");
    bel_print(a);
    putchar(' ');
    bel_print(b);
    printf(") => ");
    bel_print(bel_num_mul(a, b));
    putchar(10);

    // Complex division
    // Reusing a and b from last example
    printf("(/ ");
    bel_print(a);
    putchar(' ');
    bel_print(b);
    printf(") => ");
    bel_print(bel_num_div(a, b));
    putchar(10);

    // Integer division (inexact)
    a = bel_mkinteger(7);
    b = bel_mkinteger(2);

    printf("(/ ");
    bel_print(a);
    putchar(' ');
    bel_print(b);
    printf(") => ");
    bel_print(bel_num_div(a, b));
    putchar(10);
}
#+end_src

*** Evaluator test

#+TODO: Too long! Replace this!

#+begin_src C
void
eval_test()
{
    Bel *form;
    Bel *result;

    // (quote foo)
    form = bel_mkpair(
        bel_mksymbol("quote"),
        bel_mkpair(
            bel_mksymbol("foo"),
            bel_g_nil));
    printf("Form:   ");
    bel_print(form);
    putchar(10);
    
    result = bel_eval(form, bel_g_nil);
    
    printf("Result: "); bel_print(result);
    putchar(10); putchar(10);
    
    // (join (quote foo) (quote bar))
    form =
        bel_mkpair(
            bel_mksymbol("join"),
            bel_mkpair(
                bel_mkpair(
                    bel_mksymbol("quote"),
                    bel_mkpair(
                        bel_mksymbol("foo"),
                        bel_g_nil)),
                bel_mkpair(
                    bel_mkpair(
                        bel_mksymbol("quote"),
                        bel_mkpair(
                            bel_mksymbol("bar"),
                            bel_g_nil)),
                    bel_g_nil)));
    printf("Form:   ");
    bel_print(form);
    putchar(10);
    
    result = bel_eval(form, bel_g_nil);
    
    printf("Result: "); bel_print(result);
    putchar(10); putchar(10);


    // (fn (x) (id x x))
    form = bel_mkpair(
        bel_mksymbol("fn"),
        bel_mkpair(
            bel_mkpair(
                bel_mksymbol("x"),
                bel_g_nil),
            bel_mkpair(
                bel_mkpair(
                    bel_mksymbol("id"),
                    bel_mkpair(
                        bel_mksymbol("x"),
                        bel_mkpair(
                            bel_mksymbol("x"),
                            bel_g_nil))),
                bel_g_nil)));
    printf("Form:   ");
    bel_print(form);
    putchar(10);
    
    result = bel_eval(form, bel_g_nil);
    
    printf("Result: "); bel_print(result);
    putchar(10); putchar(10);

    
    // ((fn (x) (id x x)) (quote foo))
    form =
        bel_mkpair(
            form, // Use closure from last example
            bel_mkpair(
                bel_mkpair(
                    bel_mksymbol("quote"),
                    bel_mkpair(
                        bel_mksymbol("foo"),
                        bel_g_nil)),
                bel_g_nil));
    printf("Form:   ");
    bel_print(form);
    putchar(10);
    
    result = bel_eval(form, bel_g_nil);
    
    printf("Result: "); bel_print(result);
    putchar(10); putchar(10);

    
    // (if (id (quote bar) (quote foo)) (quote okay)
    //     (id (quote foo) (quote bar)) (quote okay)
    //                                  (quote nope))
    form = bel_mkpair(
        bel_mksymbol("if"),
        bel_mkpair(
            bel_mkpair(
                bel_mksymbol("id"),
                bel_mkpair(
                    bel_mkpair(
                        bel_mksymbol("quote"),
                        bel_mkpair(
                            bel_mksymbol("bar"),
                            bel_g_nil)),
                    bel_mkpair(
                        bel_mkpair(
                            bel_mksymbol("quote"),
                            bel_mkpair(
                                bel_mksymbol("foo"),
                                bel_g_nil)),
                        bel_g_nil))),
            bel_mkpair(
                bel_mkpair(
                    bel_mksymbol("quote"),
                    bel_mkpair(
                        bel_mksymbol("okay"),
                        bel_g_nil)),
                bel_mkpair(
                    bel_mkpair(
                        bel_mksymbol("id"),
                        bel_mkpair(
                            bel_mkpair(
                                bel_mksymbol("quote"),
                                bel_mkpair(
                                    bel_mksymbol("foo"),
                                    bel_g_nil)),
                            bel_mkpair(
                                bel_mkpair(
                                    bel_mksymbol("quote"),
                                    bel_mkpair(
                                        bel_mksymbol("bar"),
                                        bel_g_nil)),
                                bel_g_nil))),
                    bel_mkpair(
                        bel_mkpair(
                            bel_mksymbol("quote"),
                            bel_mkpair(
                                bel_mksymbol("okay"),
                                bel_g_nil)),
                        bel_mkpair(
                            bel_mkpair(
                                bel_mksymbol("quote"),
                                bel_mkpair(
                                    bel_mksymbol("nope"),
                                    bel_g_nil)),
                            bel_g_nil))))));
    printf("Form:   ");
    bel_print(form);
    putchar(10);
    
    result = bel_eval(form, bel_g_nil);
    
    printf("Result: "); bel_print(result);
    putchar(10); putchar(10);


    // (sys "echo Hello, world!")
    // NOTE: I am commenting out this test since
    //       this function could open some security
    //       holes in systems unadvertedly using it.
    /* form = bel_mkpair( */
    /*     bel_mksymbol("sys"), */
    /*     bel_mkpair( */
    /*         bel_mkstring("echo Hello, world!"), */
    /*         bel_g_nil)); */
    /* printf("Form:   "); */
    /* bel_print(form); */
    /* putchar(10); */
    
    /* result = bel_eval(form, bel_g_nil); */
    
    /* printf("Result: "); bel_print(result); */
    /* putchar(10); putchar(10); */

    
    // Eval some axioms
    puts("Evaluating some axioms");
    result = bel_eval(bel_g_t, bel_g_nil);
    printf("Result: ");
    bel_print(result);
    putchar(10); putchar(10);

    result = bel_eval(bel_g_o, bel_g_nil);
    printf("Result: ");
    bel_print(result);
    putchar(10); putchar(10);

    result = bel_eval(bel_g_apply, bel_g_nil);
    printf("Result: ");
    bel_print(result);
    putchar(10); putchar(10);

    result = bel_eval(bel_g_nil, bel_g_nil);
    printf("Result: ");
    bel_print(result);
    putchar(10); putchar(10);

    
    // Eval some numbers
    result = bel_eval(bel_mkinteger(42), bel_g_nil);
    printf("Result: ");
    bel_print(result);
    putchar(10); putchar(10);

    result = bel_eval(bel_mkfloat(42.0), bel_g_nil);
    printf("Result: ");
    bel_print(result);
    putchar(10); putchar(10);

    result = bel_eval(bel_mkfraction(
                          bel_mkinteger(2),
                          bel_mkinteger(3)),
                      bel_g_nil);
    printf("Result: ");
    bel_print(result);
    putchar(10); putchar(10);

    
    result = bel_eval(bel_mkcomplex(
                          bel_mkfloat(2.0),
                          bel_mkfloat(3.4)),
                      bel_g_nil);
    printf("Result: ");
    bel_print(result);
    putchar(10); putchar(10);
}
#+end_src

*** Arithmetic evaluation test

#+begin_src C
void
arithmetic_eval_test()
{
    Bel *exp;
    Bel *result;

    // (+ 2 #(c 3+7i) #(f 1/3))
    exp = bel_mkpair(
        bel_mksymbol("+"),
        bel_mkpair(
            bel_mkinteger(2),
            bel_mkpair(
                bel_mkcomplex(bel_mkinteger(3),
                              bel_mkinteger(7)),
                bel_mkpair(
                    bel_mkfraction(bel_mkinteger(1),
                                   bel_mkinteger(3)),
                    bel_g_nil))));
    printf("Expression: ");
    bel_print(exp); putchar(10);

    result = bel_eval(exp, bel_g_nil);
    printf("Result: ");
    bel_print(result); putchar(10);
    putchar(10);

    // (id #(c 1+3i) #(c 1+3i))
    exp = bel_mkpair(
        bel_mksymbol("id"),
        bel_mkpair(
            bel_mkcomplex(bel_mkinteger(1),
                          bel_mkinteger(3)),
            bel_mkpair(
                bel_mkcomplex(bel_mkinteger(1),
                              bel_mkinteger(3)),
                bel_g_nil)));
    printf("Expression: ");
    bel_print(exp); putchar(10);

    result = bel_eval(exp, bel_g_nil);
    printf("Result: ");
    bel_print(result); putchar(10);
    putchar(10);

    
    //(- #(c 3-8i))
    exp = bel_mkpair(
        bel_mksymbol("-"),
        bel_mkpair(
            bel_mkcomplex(bel_mkinteger(3),
                          bel_mkinteger(8)),
            bel_g_nil));
    printf("Expression: ");
    bel_print(exp); putchar(10);

    result = bel_eval(exp, bel_g_nil);
    printf("Result: ");
    bel_print(result); putchar(10);
    putchar(10);

    
    // (* 1 2 3 4 5)
    exp = bel_mkpair(
        bel_mksymbol("*"),
        bel_mkpair(
            bel_mkinteger(1),
            bel_mkpair(
                bel_mkinteger(2),
                bel_mkpair(
                    bel_mkinteger(3),
                    bel_mkpair(
                        bel_mkinteger(4),
                        bel_mkpair(
                            bel_mkinteger(5),
                            bel_g_nil))))));
    printf("Expression: ");
    bel_print(exp); putchar(10);

    result = bel_eval(exp, bel_g_nil);
    printf("Result: ");
    bel_print(result); putchar(10);
    putchar(10);

    exp = bel_mkpair(
        bel_mksymbol("/"),
        bel_mkpair(
            bel_mkfloat(45.0),
            bel_g_nil));
    printf("Expression: ");
    bel_print(exp); putchar(10);

    result = bel_eval(exp, bel_g_nil);
    printf("Result: ");
    bel_print(result); putchar(10);
    putchar(10);
}
#+end_src

*** Arity tests

The following tests check for the arity of primitive functions. By
default, a small number of arguments is not a bug, and the missing
arguments are traded for =nil=.

#+begin_src C
void
arity_test()
{
    Bel *exp;
    Bel *result;

    // (id) => t
    exp = bel_mkpair(
        bel_mksymbol("id"),
        bel_g_nil);
    printf("Expression: ");
    bel_print(exp); putchar(10);

    result = bel_eval(exp, bel_g_nil);
    printf("Result: ");
    bel_print(result); putchar(10);
    putchar(10);

    // (join) => (nil . nil)
    exp = bel_mkpair(
        bel_mksymbol("join"),
        bel_g_nil);
    printf("Expression: ");
    bel_print(exp); putchar(10);

    result = bel_eval(exp, bel_g_nil);
    printf("Result: ");
    bel_print(result); putchar(10);
    putchar(10);

    // (type) => symbol
    exp = bel_mkpair(
        bel_mksymbol("type"),
        bel_g_nil);
    printf("Expression: ");
    bel_print(exp); putchar(10);

    result = bel_eval(exp, bel_g_nil);
    printf("Result: ");
    bel_print(result); putchar(10);
    putchar(10);
}
#+end_src

* Entry point
** Initialization

This is the initialization function for the Bel interpreter. Once this
function is called, the Bel system is ready to be used.

#+begin_src C
Bel*
bel_init(void)
{
    // Initialize garbage collector
    GC_INIT();

    // Initialize random number generation
    // Warning: This is a VERY naive approach
    srand(time(NULL));

    // Initialize symbol table
    bel_sym_table_init();

    // Axioms
    bel_init_ax_vars();
    bel_init_ax_chars();
    bel_init_streams();
    bel_init_ax_env();
    bel_init_ax_primitives();

    // TODO: Return an environment?
    return bel_g_nil;
}
#+end_src

** Tests

This is the entry point for tests. All running tests are to be put
here.

#+begin_src C
void
run_tests()
{
    puts("-- Running debug tests");
    puts("  -- String test");
    string_test();
    puts("  -- Notation test");
    notation_test();
    puts("  -- List test");
    list_test();
    puts("  -- Closure representation test");
    closure_repr_test();
    puts("  -- Character List & Lookup test");
    character_list_test();
    puts("  -- Read five bytes from Believe's source");
    read_file_test();
    puts("  -- Show a few errors on screen");
    show_errors_test();
    puts("  -- Lookup a few primitives and print them");
    lookup_primitives_test();
    puts("  -- Lexical environment tests");
    lexical_environment_test();
    puts("  -- Globals and assignment tests");
    global_assignment_test();
    puts("  -- Number arithmetic tests");
    number_test();
    puts("  -- Evaluator test");
    eval_test();
    puts("  -- Arithmetic evaluation test");
    arithmetic_eval_test();
    puts("  -- Primitive arity test");
    arity_test();
}
#+end_src

** =main= function

This is the program entry point. It is supposed to only print the
ribbon, initialize Bel and perform some tests, for now.

#+begin_src C
int
main(void)
{
    printf("Believe %s\n", BELIEVE_VERSION);
    printf("A Bel Lisp interpreter\n");
    printf("Copyright (c) %s\n", BELIEVE_COPYRIGHT);
    printf("This software is distributed under the %s license.\n",
          BELIEVE_LICENSE);

    bel_init();

#ifdef BEL_DEBUG
    run_tests();
#endif
    
    return 0;
}
#+end_src

* Footnotes

[fn:3] You can see a list of compatible licenses at
https://creativecommons.org/compatible-licenses.

[fn:2] You must indicate if you modified the material and retain an
indication of previous modifications. 

[fn:1] You must provide the name of the creator and attribution
parties, a copyright notice, a license notice, a disclaimer notice,
and a link to the original material.
