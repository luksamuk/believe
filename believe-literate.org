#+TITLE:    Believe
#+SUBTITLE: A Bel interpreter built in C
#+AUTHOR:   Lucas S. Vieira
#+EMAIL:    lucasvieira@protonmail.com
#+PROPERTY: header-args:C :eval no :main no :tangle believe.c
#+STARTUP:  content
#+OPTIONS:  title:nil toc:nil

:HTML_PROPERTIES:
# When exporting to HTML, use the ReadTheOrg template
# by Fabrice Niessen (github.com/fniessen)

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>

# Enable title and table of contents if exporting to HTML.
# #+OPTIONS: title:t toc:t
:END:

:LATEX_PROPERTIES:
# Evaluate this block to use a book which starts with chapters instead
# of parts.

#+NAME: setclass
#+begin_src emacs-lisp :tangle no :eval yes :results silent :exports none
(add-to-list 'org-latex-classes
             '("book-noparts"
               "\\documentclass{memoir}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(setq org-latex-listings 'minted)

nil ;; prevent output
#+end_src

#+CALL: setclass()

# Preamble
# #+LATEX_CLASS: article

#+LATEX_CLASS: book-noparts
#+LATEX_CLASS_OPTIONS: [openright,a4paper,twoside,12pt]

#+LATEX_HEADER: \usepackage[brazil]{babel}
#+LATEX_HEADER: \usepackage{times}
#+LATEX_HEADER: \usepackage[utf8x]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{microtype}
#+LATEX_HEADER: \usepackage{titlesec}
#+LATEX_HEADER: \usepackage[english, hyperpageref]{backref}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage[alf,abnt-emphasize=bf,abnt-doi=link]{abntex2cite}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{draftwatermark}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage{titling}
#+LATEX_HEADER: \usepackage{lettrine}
#+LATEX_HEADER: \usepackage{leading}

# # Extra package property
#+LATEX_HEADER: \leading{13pt}
#+LATEX_HEADER: \pagestyle{fancy}
#+LATEX_HEADER: \chapterstyle{veelo}

# # Chater start header
#+LATEX_HEADER: \makepagestyle{abntbookchapfirst}
#+LATEX_HEADER: \makeoddhead{abntbookchapfirst}{}{}{}

# Remove colorization of links
#+LATEX_HEADER: \definecolor{blue}{RGB}{41,5,195}
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \hypersetup{
# #+LATEX_HEADER:     pdftitle={%t},
# #+LATEX_HEADER:     pdfauthor={%a},
# #+LATEX_HEADER:     pdfkeywords={%k},
# #+LATEX_HEADER:     pdfsubject={%d},
# #+LATEX_HEADER:     pdfcreator={%c},
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     linkcolor=black,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     filecolor=black,
#+LATEX_HEADER:     urlcolor=blue,
#+LATEX_HEADER:     bookmarksdepth=4
#+LATEX_HEADER: }
#+LATEX_HEADER: \makeatother
#+BIND: org-latex-hyperref-template ""

# Make watermark softer
#+LATEX_HEADER: \SetWatermarkLightness{0.85}

# Spacing
#+LATEX: \frenchspacing
:END:

:CODE_BLOCK_STYLE:
#+LATEX_HEADER: \usepackage{minted}

# List of styles: https://help.farbox.com/pygments.html

# Monokai style
# #+LATEX_HEADER: \usemintedstyle{monokai}
# #+LATEX_HEADER: \definecolor{monokaibg}{HTML}{383838}
# #+LATEX_HEADER: \setminted{bgcolor=monokaibg}

# Perldoc style
# #+LATEX_HEADER: \usemintedstyle{perldoc}
# #+LATEX_HEADER: \definecolor{perldocbg}{HTML}{ffffcc}
# #+LATEX_HEADER: \setminted{bgcolor=perldocbg}

# Manni style
# #+LATEX_HEADER: \usemintedstyle{manni}
# #+LATEX_HEADER: \definecolor{lightgrey}{HTML}{efefef}
# #+LATEX_HEADER: \setminted{bgcolor=lightgrey}

# Bw style
#+LATEX_HEADER: \usemintedstyle{bw}

# Line numbers
#+LATEX_HEADER: \setminted{linenos=true}

# Font size
#+LATEX_HEADER: \setminted{fontsize=\small, baselinestretch=1}

# Line breaking
#+LATEX_HEADER: \setminted{breaklines=true}

# Tabs
#+LATEX_HEADER: \setminted{obeytabs}
:END:

#+LATEX: \frontmatter

:COVER:
#+LATEX: \makeatletter
#+LATEX: \begin{titlingpage}
#+LATEX: \phantom{xxx}
#+LATEX: \vspace{0.5cm}
#+LATEX: \huge
#+LATEX: \raggedright
#+LATEX: \@author\\
#+LATEX: \vspace{2.5cm}
#+LATEX: \huge 
#+LATEX: {\raggedleft
# #+LATEX: \includegraphics[scale=0.9]{logo.pdf}\\[1cm]
#+LATEX: \textbf{\HUGE\textcolor{blue}{\@title}}\\
#+LATEX: {\large Version 0.3 (Alpha)}\\[1cm]
#+LATEX: }
#+LATEX: \centering 
#+LATEX:
#+LATEX: \vfill
#+LATEX: \Large
#+LATEX:
#+LATEX: \vfill
#+LATEX: \@date
#+LATEX: \end{titlingpage}
#+LATEX: \makeatother
:END:

:TABLE_OF_CONTENTS:
#+LATEX: \setcounter{secnumdepth}{5}
#+LATEX: \setcounter{tocdepth}{5}
#+LATEX: \pdfbookmark[0]{\contentsname}{toc}
#+LATEX: \tableofcontents*
#+LATEX: \cleardoublepage
:END:

#+LATEX: \mainmatter

* Acknowledgements
:PROPERTIES:
:UNNUMBERED: t
:END:
#+LATEX: \addcontentsline{toc}{chapter}{Acknowledgements}

This is an open-source project which anyone can contribute to. I'd
like to thank the people who helped me so far with this project.

Many thanks to Carl Mäsak ([[https://github.com/masak][github.com/masak]]) not only for contributing
with code, but also for highlighting a lot of important aspects in the
Bel specification, and also for taking time to discuss other
implementation aspects of the interpreter. This kind of contribution
is priceless, since it is easy to overlook important details on
technical documents. An extra pair of eyes on that regard is always
welcome.

* Introduction

The goal of this project is to provide a fully-functioning
implementation of the Bel language, proposed by Paul Graham. The main
goal is not to provide performance; instead, it is supposed to be a
didatic approach to implementing a Lisp interpreter.

The code here contained is also a study on how to build a Lisp
interpreter from scratch in C. Given that Bel is so simple and is
supposed to be a formalism before a commercial language, it seems like
the perfect didatic resource to do so.

Here are some useful links with language resources:

- [[http://paulgraham.com/bel.html][Paul Graham's Bel release website]]
- [[https://sep.yimg.com/ty/cdn/paulgraham/bellanguage.txt?t=1570993483&][Language Guide]]
- [[https://sep.yimg.com/ty/cdn/paulgraham/bel.bel?t=1570993483&][Language Source Code, written in Bel itself]]
- [[https://sep.yimg.com/ty/cdn/paulgraham/belexamples.txt?t=1570993483&][Bel examples]]

Note that *this software is still a work-in-progress. Do not expect it to work
fully yet.*

** About literate programming

# TODO: Lacks references! Use Org-ref for that!
This interpreter is built using [[https://orgmode.org/][Org with Org-mode in Emacs]]. Its
website specifies that Org is "a format for keeping notes, maintaining
TODO lists, planning projects, and authoring documents with a fast and
effective plain-text system".

All the code here appears in the order it is written on the actual
code files. By using [[http://www.literateprogramming.com/knuthweb.pdf][Donald Knuth's concept of literate programming]],
the relevant code blocks are /tangled/ and written in their specified
code files, and then the application can be compiled.

By using this approach, I hope to maintain an application where the
understanding of what is being written comes before the code itself,
so that the reader is able to take and analyse parts of said code
based on the prose that accompanies it.

** Licensing

The Believe project is composed of two relevant documents: one being
the /textbook/, which contains all the prose parts plus the code blocks
in relevant places; and another being the /code/, which is composed
solely of the code blocks contained in this /textbook/, and can be
understood both as the /code/ blocks of the /textbook/ or as a separate,
/tangled/ file containing the relevant discussed code.

When redistributing the /textbook/, one should take the /textbook/ license
into consideration. But anyone using the /code/ parts of the /textbook/ or
the /tangled/ code file included in the project's repository, for /any/
purpose, should take the /code/ license into consideration as well.

*** Textbook license

This work is licensed under a Creative Commons Attribution-ShareAlike
4.0 International License. This means that you are free to:

- *Share*: copy and redistribute the material in any medium or format
- *Adapt*: remix, transform, and build upon the material for any
  purpose, even commercially.

But only if you follow the terms below:

- *Attribution*: You must give appropriate credit[fn:1], provide a link to the
  license, and indicate if changes were made[fn:2]. You may do so in any
  reasonable manner, but not in any way that suggests the licensor
  endorses you or your use.
- *ShareAlike*: If you remix, transform, or build upon the material, you
  must distribute your contributions under the same license[fn:3] as the
  original.


See the CC-BY-SA 4.0[fn:6] link for more information.

#+ATTR_LATEX: :width .2\textwidth
[[file:images/cc-by-sa.png]]

*** Code license

This software's code is distributed under the MIT License, Copyright
(c) 2019-2020 Lucas S. Vieira.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

** Contribution guidelines

# We delegate this to an external file.
#+INCLUDE: CONTRIBUTING.org :only-contents t

* COMMENT Backlog
** Roadmap
- [x] Data types
  - [x] Symbols
  - [x] Pairs
    - [x] Lists
  - [x] Characters
  - [x] Strings
  - [x] Numbers (opaque; general type only)
    - [x] Integers
    - [x] Float
    - [x] Fractions
    - [x] Complex
- [x] Literals
  - [x] Primitives (representation)
- [x] Environments
  - [x] Environment hierarchy (dyn > lex > glo) [implemented on
    lookup]
  - [x] Dynamic binding (visible everywhere for short time)
  - [x] Hierarchical lookup (=bel_lookup=)
- [x] Functions
  - [x] Lexical bindings
- [ ] Evaluation [wip]
  - [x] Eval [wip]
    - [ ] Special forms [wip]
      - [x] =quote=
      - [x] =lit=
        - [x] =fn=   => literal closure
      - [x] =if=
      - [ ] =apply=
      - [x] =join=
      - [ ] =where=  => not so straightforward
      - [x] =dyn=
      - [ ] =after=
      - [ ] =ccc=    => Later?
      - [ ] =thread= => Later?
      - [x] =set=    => global binding
  - [x] Apply
  
** On-the-fly checklist
- [x] Environment functions
- [x] Global environment object =globe=
- [x] Various necessary predicates
  - [x] =stringp= predicate
- [x] Error object
- [x] String printing
- [x] Test for errors on core functions
- [x] Dynamic environment
- [x] Assignments/Unassignments
- [x] =err= primitive function, basic error handling
- [x] Use =BEL_DEBUG= flag everywhere!
- [x] Move debug printing functions to actual printing behaviour
- [x] Prototype evaluator
- [ ] Proper error propagation
- [ ] Add proper references with Org-ref and bibtex
- [ ] Lexical environment object =scope=, shadowable, not unique (is it
  necessary?)
- [ ] Prevent circular printing. Particularly useful for environments
  and closures

* Tools and scripts
** Makefile

This software was primarily developed on Void Linux x86_64, using the
Clang compiler. The following Makefile is the one used for building
Believe.

#+begin_src makefile :tangle Makefile
CC     = clang
CFLAGS = -std=c17 -g -O2 -Wall -DBEL_DEBUG
CLIBS  = -lgc -lm
BIN    = believe
OBJ    = believe.o

.PHONY: clean

$(BIN): $(OBJ)
	$(CC) $(CFLAGS) $(CLIBS) -o $@ $^

%.o: %.c
	$(CC) $(CFLAGS) -c -o $@ $^

clean:
	rm -rf *.o $(BIN)
#+end_src

** Memory leak testing

This script generates a log file with memory leak information using
Valgrind. Valgrind's output is stored in =believe.log=.

#+begin_src bash :results silent :tangle no
valgrind --check_leaks=full --log-file="believe.log" -v ./believe
#+end_src

** Tangling

The following snippet can be run from Emacs to enable tangling on save
for this file only.

Tangling is the process of taking each block of code and adding it to
its specific file. Believe's code will be written in C source files;
the Makefile will be written in its own file; and so on. Notice that
some blocks (like this one) is not written anywhere, and is meant to
be evaluated from inside Emacs.

#+begin_src emacs-lisp :tangle no :exports none :results silent
(setq lexical-binding t)
(add-hook 'after-save-hook 'org-babel-tangle)
#+end_src

** Running the program

This script attempts to build and run the Bel interpreter. It will
also enable verbose output for the garbage collector.

#+begin_src bash :tangle run.sh :eval no :cache yes :results silent :exports code
make
export GC_PRINT_STATS=1
./believe
#+end_src

* Libraries and headers

** File header

Let's add a modest copyright notice to the program's header.

#+begin_src C
/* Believe v0.3                                           *
 ,* A Bel Lisp interpreter.                                *
 ,* Copyright (c) 2019-2020 Lucas Vieira.                  *
 ,* This program is distributed under the MIT License. See *
 ,* the LICENSE file for details.                          *
 ,*                                                        *
 ,* Development information can also be consulted on the   *
 ,* book which accompanies this software, which was        * 
 ,* written in literate programming form. For more         *
 ,* information, see https://github.com/luksamuk/believe.  */
#+end_src

** Software-related definitions

These definitions relate to program metadata which is going to be
displayed on its startup.

#+begin_src C
#define BELIEVE_VERSION   "0.3"
#define BELIEVE_COPYRIGHT "2019-2020 Lucas Vieira"
#define BELIEVE_LICENSE   "MIT"
#define BELIEVE_BUILD_TIME __DATE__ " " __TIME__
#+end_src

We'll use a flag for debug which influences the building
process. Let's call this flag =BEL_DEBUG=.

When building, if you pass this flag to Clang (see the Makefile), some
debug outputs will be available.

By default we'll leave it on, at least for now.

** Default headers

We'll be using =stdio.h= for default console I/O, plus =stdint.h= for some
standard integer types. =string.h= provides definitions to handle string
manipulation on the C side, however Bel is supposed to have its own
string representation, to be discussed later. =errno.h= is used to fetch
error strings from streams, for example; and =math.h= is useful for math
operations.  =stdarg.h= is  used  for creating  variadic functions,  and
finally,  =ctype.h=  is  used  for  comparing  characters  when  parsing
expressions.

#+begin_src C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <math.h>
#include <stdarg.h>
#include <ctype.h>
#+end_src

** Boehm-Demers-Weiser Garbage Collector

We also use Boehm-Demers-Weiser GC for garbage collection, instead of
programming our own. The =GC_DEBUG= flag helps on debugging. See that we
use =-lgc= on the Makefile to link the relevant library to the
application.

#+begin_src C
#ifdef BEL_DEBUG
#define GC_DEBUG
#endif

#include <gc.h>
#+end_src

Plus, [[https://www.hboehm.info/gc/04tutorial.pdf][one could check the Boehm-Demers-Weiser GC tutorial slides]] by
Hans-J. Boehm, for a quick overview of this library.

# TODO: Use GC_REGISTER_FINALIZER for streams... if convenient.

* Fundamental data types

The first thing to do is specify how the data is going to be handled
by the interpreter. Here, we define each of these kinds of data. Any
procedure for data manipulation will be defined afterwards.

** Enumerating Bel types

We begin by specifying all data types, which Bel has four: symbols,
pairs, characters and streams. We also add a number type, which is
non-standard, but will be useful; this decision will be explained in
its section.

#+begin_src C
typedef enum
{
    BEL_SYMBOL,
    BEL_PAIR,
    BEL_CHAR,
    BEL_STREAM,
    BEL_NUMBER
} BEL_TYPE;
#+end_src

** Pair

A pair can have two things, which can in return be one of the four
data types themselves. Since this is sort of a recursive definition,
we need to make a forward declaration of the general =Bel= type, which
encloses all four data types.

#+begin_src C
typedef struct BEL Bel; // Forward declaration

typedef struct
{
    Bel *car;
    Bel *cdr;
} Bel_pair;
#+end_src

** Character

A character is nothing but an integer in standard C. For now we'll
support only ASCII, so there is no actual need to instantiate the
proposed table of characters -- this might change in the future.

We say that a character is nothing but a signed 8-bit integer. Should
be enough for now.

#+begin_src C
typedef int8_t Bel_char;
#+end_src

** Symbol

A symbol is nothing but a specific index on the symbol table, so
that's how we'll define it.

#+begin_src C
typedef uint64_t Bel_sym;
#+end_src

** Stream

The stream type is somewhat implementation-dependent. In C, a standard
way to refer to streams is to use a =FILE= pointer, since =stdout= and
=stdin= themselves are of such type. So we just wrap these pointers in
a stream type.

Plus, as per Bel's specification, a stream has three statuses: closed,
open for reading, open for writing. Therefore, we use a single
enumeration to represent these three states.

Since Bel's specification writes to a stream bit by bit, we need to
cache the currently filled byte inside the structure, from left to
right, dumping each byte as it is filled. Upon closing, the stream
shall write the cache at the end of the file, plus the incomplete
remaining bits. A "new" (not written and not dumped) cache is a single
byte, and is guaranteed to be filled with zero =(\0 \0 \0 \0 \0 \0 \0
\0)=.

When dealing with reading from a stream, since Bel also reads bit by
bit only, we take the same advantage of the cache, however as the
opposite approach: we read a single byte from stream and keep the
cache full. As we read each bit, we convert it to a Bel character (=\0=
or =\1=). Once all bits of the cache have been read, another byte is
fetched, stored on cache, and so on.

#+begin_src C
typedef enum BEL_STREAM_STATUS
{
    BEL_STREAM_CLOSED,
    BEL_STREAM_READ,
    BEL_STREAM_WRITE
} BEL_STREAM_STATUS;

typedef struct
{
    BEL_STREAM_STATUS  status;
    FILE              *raw_stream;
    uint8_t            cache;
    uint8_t            cache_used;
} Bel_stream;
#+end_src

** Number

Bel does not specify any numeric types in its standard. In fact,
numbers could be reproduced in Bel by using Church numerals, for
example. However, this approach has a huge impact on performance,
enough to make us want actual numeric types in our interpreter.

A /number/ in Believe is a union of many number subtypes. The /number/ can
be an integer, a float, a fraction or even a complex number in its
constitution, but this coercion happens away from the eyes of the Bel
programmer; from his standpoint, there is only an opaque /number/ type.

Let's start by defining the enumeration of types. Integers are C
/64-bit signed ints/, and floats are, in fact, C /doubles/.

#+begin_src C
typedef enum {
    BEL_NUMBER_INT,
    BEL_NUMBER_FLOAT,
    BEL_NUMBER_FRACTION,
    BEL_NUMBER_COMPLEX
} BEL_NUMBER_TYPE;

typedef int64_t Bel_longint;
typedef double  Bel_float;
#+end_src

We forward declare the =Bel_number= structure as a /typedef/ for a =struct
BEL_NUMBER=.

#+begin_src C
typedef struct BEL_NUMBER Bel_number; // Forward declaration
#+end_src

Now we define our /fraction/ and /complex/ subtypes. Notice that they use
=Bel_number= in their constitution. This is on purpose, as it allows us
to create recursive definitions of numbers.

#+begin_src C
typedef struct {
    Bel *numer;
    Bel *denom;
} Bel_fraction;

typedef struct {
    Bel *real;
    Bel *imag;
} Bel_complex;
#+end_src

All that is left is to define our =Bel_number= formally.

#+begin_src C
struct BEL_NUMBER {
    BEL_NUMBER_TYPE type;
    union {
        Bel_longint  num_int;
        Bel_float    num_float;
        Bel_fraction num_frac;
        Bel_complex  num_compl;
    };
};
#+end_src

** The =Bel= structure

The remaining thing to do is join all the types into the =Bel= type,
which will serve as our generic way of dealing with things.

#+begin_src C
// Aliased as 'Bel' before
struct BEL
{
    BEL_TYPE type;
    union {
        Bel_sym     sym;
        Bel_pair   *pair;
        Bel_char    chr;
        Bel_stream  stream;
        Bel_number  number;
    };
};
#+end_src

* Essential structures and manipulation of data
** Basic definitions

These definitions relate to essential symbols of the Bel global
environment. They also encode the symbols' position on the global
symbol table, to be defined later.

#+begin_src C
#define BEL_NIL   ((Bel_sym)0)
#define BEL_T     ((Bel_sym)1)
#define BEL_O     ((Bel_sym)2)
#define BEL_APPLY ((Bel_sym)3)
#+end_src

The following symbols are axioms which are global to the program. One
is expected to use them instead of creating new symbols, though it is
not strictly necessary.

#+begin_src C
Bel *bel_g_nil;
Bel *bel_g_t;
Bel *bel_g_o;
Bel *bel_g_apply;
#+end_src

These other variables are responsible for holding other axioms on the
system. More on then will be specified later.

# TODO: Add `errs` as an error stream?

#+begin_src C
Bel *bel_g_chars;
Bel *bel_g_ins_sys;
Bel *bel_g_outs_sys;
Bel *bel_g_ins;
Bel *bel_g_outs;
Bel *bel_g_prim;
Bel *bel_g_clo;
#+end_src

We may also define temporary variables for the global, lexical and
dynamic environments.

#+begin_src C
Bel *bel_g_scope;
Bel *bel_g_globe;
Bel *bel_g_dynae;
#+end_src

*** Forward declarations

We need to forward declare a few functions which will be useful for
certain operations. For example, it is important that we make a
forward declaration of =bel_mkerror=, since the primitives should depend
on it; also, providing =bel_mkstring= ensures that the error format can
be easily created, and so on.

# TODO: Is this even correct? Test whether bel_mkerror creates an infinite loop!

#+begin_src C
/* Forward declarations */
Bel *bel_mkerror(Bel *format, Bel *vars);
Bel *bel_mkstring(const char*);
Bel *bel_mksymbol(const char*);
Bel *bel_car(Bel*);
Bel *bel_cdr(Bel*);
Bel *bel_mklist(int, ...);
#+end_src

** Predicates

It is important to have a few predicates which will help us check for
errors. These predicates do not check for argument nullability
(e.g. unmanaged pointers), so use it wisely and only on initialized
data!

*** =symbolp=

=bel_symbolp= tests whether the element is a symbol.

#+begin_src C
#define bel_symbolp(x) ((x)->type==BEL_SYMBOL)
#+end_src

*** =nilp=

=bel_nilp= tests whether the element is the /symbol/ =nil=.

#+begin_src C
#define bel_nilp(x)                             \
    (bel_symbolp(x) && ((x)->sym==BEL_NIL))
#+end_src

*** =pairp=

=bel_pairp= tests whether the element is a /pair/.

#+begin_src C
#define bel_pairp(x) ((x)->type==BEL_PAIR)
#+end_src

*** =atomp=

=bel_atomp= tests whether an element is not a /pair/ -- that is, if it is
not "divisible".

#+begin_src C
#define bel_atomp(x) (!bel_pairp(x))
#+end_src

*** =charp=

=bel_charp= tests whether the object is a character.

#+begin_src C
#define bel_charp(x)                            \
    (((x)->type==BEL_CHAR))
#+end_src

*** =streamp=

=bel_streamp= tests whether the object is a stream.

#+begin_src C
#define bel_streamp(x)                          \
    (((x)->type==BEL_STREAM))
#+end_src

*** =numberp=

=bel_numberp= determines whether =x= is a number or not. Notice that
numbers are non-standard to Bel's definition.

#+begin_src C
#define bel_numberp(x)                          \
    ((x)->type==BEL_NUMBER)
#+end_src

*** =idp=

=bel_idp= tests whether an object is identical to another.
According to the Bel specification, identity is stricter than
equality: there is only one of each symbol and character. Pairs and
streams are compared by their references, so they are identical if and
only if they reside in the same memory address.

This is the first predicate that is implemented as a proper C
function, and it is used only internally; therefore, it outputs a C
integer value for truth and falsity.

#+begin_src C
int bel_idp_nums(Bel *x, Bel *y); // Forward declaration
#+end_src

#+begin_src C
int
bel_idp(Bel *x, Bel *y)
{
    if(bel_symbolp(x))
        return (x->sym == y->sym);
    else if(bel_charp(x))
        return (x->chr == y->chr);
    else if(bel_numberp(x)) {
        // Non-standard
        return bel_idp_nums(x, y);
    }

    // For pairs and streams, check for
    // pointer aliasing
    return (x == y);
}
#+end_src

Numbers are non-standard, so we develop our own identity test for
them: if two /numbers/ have the same /subtype/ (integer, float, fraction,
complex) and the same /value/, they are identical. In the case of
numbers with components (fraction, complex) we recursively test for
component identity instead of comparing /values/ directly.

#+begin_src C
int
bel_idp_nums(Bel *x, Bel *y)
{
    if(x->number.type == y->number.type) {
        switch(x->number.type) {
        case BEL_NUMBER_INT:
            return (x->number.num_int
                    == y->number.num_int);
        case BEL_NUMBER_FLOAT:
            return (x->number.num_float
                    == y->number.num_float);
        case BEL_NUMBER_FRACTION:
            return
                (bel_idp_nums(
                    x->number.num_frac.numer,
                    y->number.num_frac.numer)
                 && bel_idp_nums(
                     x->number.num_frac.denom,
                     y->number.num_frac.denom));
        case BEL_NUMBER_COMPLEX:
            return
                (bel_idp_nums(
                    x->number.num_compl.real,
                    y->number.num_compl.real)
                 && bel_idp_nums(
                     x->number.num_compl.imag,
                     y->number.num_compl.imag));
        };
    }
    return 0;
}
#+end_src

*** =errorp=

=bel_errorp= tests whether a specific object is a list in the format
=(lit err . rest)=.

#+begin_src C
int
bel_errorp(Bel *x)
{
    if(!bel_pairp(x)) return 0;
    if(!bel_idp(bel_car(x), bel_mksymbol("lit")))
        return 0;
    Bel *cdr = bel_cdr(x);
    if(!bel_idp(bel_car(cdr), bel_mksymbol("err")))
        return 0;
    return 1;
}
#+end_src

*** =proper-list-p=

A proper list is any list which ends in an appropriate =nil= symbol. So
for example, =(1 2 3)= is a proper list, but =(1 2 3 . 4)= is not. Compare
how these lists can be expressed by using dot notation:

- =(1 . (2 . (3 . nil)))=
- =(1 . (2 . (3 . 4)))=

An empty list is considered a proper list as well.

=bel_proper_list_p= checks whether a list is indeed a proper list. We do
that by traversing the list, pair by pair. If the /cdr/ is =nil=, it is
proper; if it is a pair, it proceeds with the traversal. But if the /cdr/
is anything else, then it is not a proper list.

#+begin_src C
int
bel_proper_list_p(Bel *x)
{
    if(!bel_pairp(x) && !bel_nilp(x))
        return 0;
    
    Bel *itr = x;
    while(!bel_nilp(itr)) {
        if(!bel_pairp(itr))
            return 0;
        itr = bel_cdr(itr);
    }

    return 1;
}
#+end_src

*** =stringp=

An object is a string if and only if:

- it is a proper list;
- it contains characters only.

=bel_stringp= tests for this. However, this first implementation is a
little naïve, since it performs a proper list check, which involves
traversing an entire list, and then it traverses the list again,
checking for characters in the /car/. This overhead can be reduced in
the future.

#+begin_src C
int
bel_stringp(Bel *x)
{
    if(!bel_proper_list_p(x)) {
        return 0;
    }

    Bel *itr = x;
    while(!bel_nilp(itr)) {
        Bel *car = bel_car(itr);

        if(!bel_charp(car))
            return 0;

        itr = bel_cdr(itr);
    }

    return 1;
}
#+end_src

*** =literalp=

=bel_literalp= takes a proper list and tells whether the list is a
literal, that is, if the first element of the list is the symbol =lit=.

#+begin_src C
int
bel_literalp(Bel *x)
{
    if(!bel_proper_list_p(x))
        return 0;

    return bel_idp(bel_car(x),
                   bel_mksymbol("lit"));
}
#+end_src

*** =primitivep=

=bel_primitivep= takes a literal and tests whether it is a primitive,
that is, if the second element of the list is the symbol =prim=.

#+begin_src C
int
bel_primitivep(Bel *x)
{
    return bel_literalp(x)
        && bel_idp(bel_car(bel_cdr(x)),
                   bel_mksymbol("prim"));
}
#+end_src

*** =closurep=

=bel_closurep= takes a literal and tests whether it is a closure, that
is, if the second element of the list is the symbol =clo=.

#+begin_src C
int
bel_closurep(Bel *x)
{
    return bel_literalp(x)
        && bel_idp(bel_car(bel_cdr(x)),
                   bel_mksymbol("clo"));
}
#+end_src

*** =quotep=

=bel_quotep= takes a proper list and determines whether it is a quoted
form.

#+begin_src C
int
bel_quotep(Bel *x)
{
    if(!bel_proper_list_p(x))
        return 0;

    return bel_idp(bel_car(x),
                   bel_mksymbol("quote"));
}
#+end_src

*** =number-list-p=

=bel_number_list_p= determines whether =x= is a proper list of numbers.

#+begin_src C
int
bel_number_list_p(Bel *x)
{
    if(!bel_proper_list_p(x)) {
        return 0;
    }

    Bel *itr = x;
    while(!bel_nilp(itr)) {
        Bel *car = bel_car(itr);

        if(!bel_numberp(car))
            return 0;

        itr = bel_cdr(itr);
    }

    return 1;
}
#+end_src

** Symbol Table and Symbols

The symbol table is an array that grows as necessary, doubling in
size, but never shrinks on the program's lifetime. Each element of the
table is a =const= C string.

We begin by defining such structure and a global symbol table.

#+begin_src C
typedef struct {
    const char **tbl;
    uint64_t     n_syms;
    uint64_t     size;
} _Bel_sym_table;
#+end_src

#+begin_src C
static _Bel_sym_table g_sym_table;
#+end_src

To initialize the symbol table, we give it an initial size of four,
just enough to enclose Bel's four fundamental symbols: =nil=, =t=, =o= and
=apply=. Notice that the order of these symbols relate to their
predefined macros, so any failure here is unexpected.

#+begin_src C
void
bel_sym_table_init(void)
{
    g_sym_table.n_syms = 4;
    g_sym_table.size   = 4;
    g_sym_table.tbl    =
        GC_MALLOC(g_sym_table.size * sizeof(char*));

    g_sym_table.tbl[BEL_NIL]   = "nil";
    g_sym_table.tbl[BEL_T]     = "t";
    g_sym_table.tbl[BEL_O]     = "o";
    g_sym_table.tbl[BEL_APPLY] = "apply";
}
#+end_src

The lookup function =bel_sym_table_find= does a linear search for the
presented literal on the symbol table. However, if it doesn't find the
symbol, it implicitly calls =bel_sym_table_add=, which appends the
symbol to the table.

This is obviously not a very wise approach as it opens up for some
exploits on interning symbols, but should be enough as long as these
symbols are only really interned on =lit= or =quote= scopes.

#+begin_src C
Bel_sym bel_sym_table_add(const char*); // Forward declaration

Bel_sym
bel_sym_table_find(const char *sym_literal)
{
    uint64_t i;
    for(i = 0; i < g_sym_table.n_syms; i++) {
        if(!strcmp(sym_literal, g_sym_table.tbl[i])) {
            return i;
        }
    }

    return bel_sym_table_add(sym_literal);
}

Bel_sym
bel_sym_table_add(const char *sym_literal)
{
    if(g_sym_table.n_syms == g_sym_table.size) {
        uint64_t new_size = 2 * g_sym_table.size;
        g_sym_table.tbl = GC_REALLOC(g_sym_table.tbl,
                                     new_size * sizeof(char*));
        g_sym_table.size = new_size;
    }
    g_sym_table.tbl[g_sym_table.n_syms++] = sym_literal;
    return (g_sym_table.n_syms - 1);
}
#+end_src

Eventually we'll also need to take a symbol and find its character
counterpart. Since the table is immutable, we can do that
instantaneously by taking the character string at the symbol's
position on the table. Notice that we do not check whether the given
argument is a symbol, since it is also an internal function.

#+begin_src C
const char*
bel_sym_find_name(Bel *sym)
{
    return g_sym_table.tbl[sym->sym];
}
#+end_src

Last but not least, we create a proper tool to build a symbol. Just
give it your desired symbol as a string literal and the runtime takes
care of the rest.

#+begin_src C
Bel*
bel_mksymbol(const char *str)
{
    Bel *ret  = GC_MALLOC(sizeof (*ret));
    ret->type = BEL_SYMBOL;
    ret->sym  = bel_sym_table_find(str);
    return ret;
}
#+end_src

** Pairs

Pairs are the kernel of every Lisp, so we need tools to manipulate
them.

We begin by specifying the function which builds pairs. Notice that
the function itself takes two references to values, so pairs cannot
exist without their /car/ and /cdr/.

#+begin_src C
Bel*
bel_mkpair(Bel *car, Bel *cdr)
{
    Bel *ret  = GC_MALLOC(sizeof (*ret));
    ret->type = BEL_PAIR;
    ret->pair = GC_MALLOC(sizeof (Bel_pair));
    ret->pair->car = car;
    ret->pair->cdr = cdr;
    return ret;
}
#+end_src

Now we may easily extract information from pairs, using the /car/ and
/cdr/ operations.

#+begin_src C
Bel*
bel_car(Bel *p)
{
    if(bel_nilp(p))
        return bel_g_nil;
    
    if(!bel_pairp(p)) {
        return bel_mkerror(
            bel_mkstring("Cannot extract the car of ~a."),
            bel_mkpair(p, bel_g_nil));
    }
    
    return p->pair->car;
}
#+end_src

#+begin_src C
Bel*
bel_cdr(Bel *p)
{
    if(bel_nilp(p))
        return bel_g_nil;
    
    if(!bel_pairp(p)) {
        return bel_mkerror(
            bel_mkstring("Cannot extract the cdr of ~a."),
            bel_mkpair(p, bel_g_nil));
    }
    
    return p->pair->cdr;
}
#+end_src

Let's also build a utility to return the size of a list. This is a
=O(n)= operation which takes a well-formed list and iterates over
it.

Note that *calculating the length of something that is not a /proper
list/ makes no sense and will crash this operation*. So before calling
=bel_length=, it is probably a good idea to check for a valid proper
list using =bel_proper_list_p= or a similar procedure.

#+begin_src C
uint64_t
bel_length(Bel *list)
{
    Bel *itr = list;
    uint64_t len = 0;
    while(!bel_nilp(itr)) {
        len++;
        itr = bel_cdr(itr);
    }
    return len;
}
#+end_src

We can also create a variadic function which implements Bel string
creation from a number of arguments passed to that string. This is
useful when creating lists from C.

=bel_mklist= asks for a number of elements and a variadic list of =Bel*=
objects. Then it attempts to create a single pair for each object, and
place the object itself in the /car/ of that pair.

When another object is added into the list, yet another pair is
created and so on, and this pair is set as the /cdr/ of the previous
pair.

#+begin_src C
Bel*
bel_mklist(int n_elem, ...)
{
    if(n_elem <= 0) return bel_g_nil;
    
    va_list args;
    va_start(args, n_elem);

    Bel *list_start = NULL;
    Bel *list = NULL;
    
    int i;
    for(i = 0; i < n_elem; i++) {
        Bel *newp =
            bel_mkpair(va_arg(args, Bel*),
                       bel_g_nil);
        if(!list) {
            list = newp;
            list_start = list;
        } else {
            list->pair->cdr = newp;
            list = newp;
        }
    }

    if(!list_start)
        return bel_g_nil;
    
    return list_start;
}
#+end_src

** Characters and Strings

Let's begin by adding a small function to wrap a character in a Bel
object.

#+begin_src C
Bel*
bel_mkchar(Bel_char c)
{
    Bel *ret  = GC_MALLOC(sizeof *ret);
    ret->type = BEL_CHAR;
    ret->chr  = c;
    return ret;
}
#+end_src

# TODO: This needs to change if unicode support is enabled
Characters have the size of one byte, so if we take a single list of 8
=\1= and =\0= characters, we should be able to generate a bitmask of the
corresponding character in question.

#+begin_src C
Bel*
bel_char_from_binary(Bel *list)
{
    if(!bel_pairp(list)) {
        return bel_mkerror(
            bel_mkstring("The binary representation of "
                         "a character must be a string of "
                         "characters \\0 and \\1."),
            bel_g_nil);
    }

    if(!bel_proper_list_p(list)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a proper "
                         "list, and therefore not a list "
                         "of characters \\0 and \\1."),
            bel_mkpair(list, bel_g_nil));
    }

    size_t len = bel_length(list);

    if(len != 8) {
        return bel_mkerror(
            bel_mkstring("The binary representation of "
                         "a character must have exactly "
                         "eight characters \\0 or \\1."),
            bel_g_nil);
    }
    
    Bel_char mask = '\0';
    size_t i;
    Bel *current = list;
    
    for(i = 0; i < len; i++) {
        Bel *bitchar = bel_car(current);

        if(!bel_charp(bitchar)) {
            return bel_mkerror(
                bel_mkstring("The provided binary "
                             "representation of a "
                             "character does not contain "
                             "only characters."),
                bel_g_nil);
        }

        if(bitchar->chr != '0' && bitchar->chr != '1') {
            return bel_mkerror(
                bel_mkstring("The binary representation of "
                             "a character must have exactly "
                             "eight characters \\0 or \\1."),
                bel_g_nil);
        }
        
        if(bitchar->chr == '1') {
            mask |= (1 << (7 - i));
        }
        current = bel_cdr(current);
    }
    return bel_mkchar(mask);
}
#+end_src

Strings on the Bel environment are nothing more than a list of
characters, therefore we need a way to convert C strings to proper Bel
lists.

#+begin_src C
Bel*
bel_mkstring(const char *str)
{
    size_t len = strlen(str);

    if(len == 0)
        return bel_g_nil;
    
    Bel **pairs = GC_MALLOC(len * sizeof (Bel));

    // Create pairs where CAR is a character and CDR is nil
    size_t i;
    for(i = 0; i < len; i++) {
        Bel *chr  = GC_MALLOC(sizeof *chr);
        chr->type = BEL_CHAR;
        chr->chr  = str[i];
        pairs[i]  = bel_mkpair(chr, bel_g_nil);
    }

    // Link all pairs properly
    for(i = 0; i < len - 1; i++) {
        pairs[i]->pair->cdr = pairs[i + 1];
    }

    return pairs[0];
}
#+end_src

We also add a utility to take back a Bel string and turn it into a
garbage-collected C string.

Note that the errors it can produce are instead dumped to the console
and we return a null pointer; proper manipulation of this function is
a responsibility of the programmer, since this is an internal
function.

#+begin_src C
char*
bel_cstring(Bel *belstr)
{
    if(!bel_pairp(belstr)) {
        puts("INTERNAL ERROR on bel_cstring: "
             "argument is not a pair");
        return NULL;
    }
    
    if(!bel_stringp(belstr)) {
        puts("INTERNAL ERROR on bel_cstring: "
             "argument is not a string");
        return NULL;
    }
    
    uint64_t len = bel_length(belstr);
    if(len == 0) return NULL;
    
    char *str    = GC_MALLOC_ATOMIC((len + 1) * sizeof (*str));

    Bel *itr     = belstr;
    size_t i     = 0;

    while(!bel_nilp(itr)) {
        str[i] = bel_car(itr)->chr;
        itr    = bel_cdr(itr);
        i++;
    }
    str[i] = '\0';
    return str;
}
#+end_src

** Streams

# TODO: Enclose stderr on Bel object
We start by creating tools to manipulate streams. First, we create a
raw stream from a file.

#+begin_src C
Bel*
bel_mkstream(const char* name, BEL_STREAM_STATUS status)
{
    Bel *ret           = GC_MALLOC(sizeof *ret);
    ret->type          = BEL_STREAM;

    if(status == BEL_STREAM_CLOSED) {
        return bel_mkerror(
            bel_mkstring("Cannot create a stream with "
                         "CLOSED status."),
            bel_g_nil);
    }

    if(!strncmp(name, "ins", 3)) {
        ret->stream.raw_stream = stdin;
    } else if(!strncmp(name, "outs", 4)) {
        ret->stream.raw_stream = stdout;
    } else {
        ret->stream.raw_stream =
            fopen(name,
                  status == BEL_STREAM_READ ? "rb" : "wb");
        
        if(!ret->stream.raw_stream) {
            return bel_mkerror(
                bel_mkstring("Unable to open stream ~a."),
                bel_mkpair(
                    bel_mkstring(name), bel_g_nil));
        }
    }

    ret->stream.status     = status;
    ret->stream.cache      = 0u;
    ret->stream.cache_used = 0u;
    return ret;
}
#+end_src

One important thing to have is a function which inputs a single bit in
a file. We use the previously defined cache system for that; by
filling the bits from left to right, we'll enable output as a single
bit.

First we define the function which dumps and resets the cache of a
specific stream when the cache is full; this should come in handy when
closing the stream as well. After that, we do the actual bit
writing. And of course, writing a bit returns =t= or =nil= for success and
failure; this will most likely not be external to the Bel environment
itself, since a failure in writing must signal an error. But that is
not the job for this primitive.

#+begin_src C
Bel*
bel_stream_dump_cache(Bel_stream *stream)
{
    if(!fwrite(&stream->cache, 1, 1, stream->raw_stream)) {
        return bel_g_nil;
    }
    stream->cache_used = 0u;
    stream->cache      = 0u;
    return bel_g_t;
}

Bel*
bel_stream_write_bit(Bel_stream *stream, Bel_char bit)
{
    if(bit != '0' || bit != '1') {
        return bel_mkerror(
            bel_mkstring("Written bit must be represented "
                         "as a character 0 or 1"),
            bel_g_nil);
    }

    if(stream->status != BEL_STREAM_WRITE) {
        return bel_mkerror(
            bel_mkstring("Write stream is not at WRITE "
                         "state"),
            bel_g_nil);
    }

    if(stream->cache_used >= 8) {
        return bel_stream_dump_cache(stream);
    } else {
        if(bit == '1') {
            stream->cache |= (1 << (7 - stream->cache_used));
        }
        stream->cache_used++;
    }
    
    return bel_mkchar(bit);
}
#+end_src

We can take advantage of the same variables to read single bits from a
file, as described before too. Keep the cache full, read single bits
as Bel characters, fill the cache when the read bits are exhausted.

# TODO: "Being unable to read a bit" signals an error.
# TODO: "No bit is currently available" returns nil -- but how should I do it?

#+begin_src C
Bel*
bel_stream_fill_cache(Bel_stream *stream)
{
    if(!fread(&stream->cache, 1, 1, stream->raw_stream)) {
        // Return nil on EOF
        return bel_g_nil;
    }
    stream->cache_used = 8;
    return bel_g_t;
}

Bel*
bel_stream_read_bit(Bel_stream *stream)
{
    if(stream->status != BEL_STREAM_READ) {
        return bel_mkerror(
            bel_mkstring("Read stream is not at READ "
                         "state"),
            bel_g_nil);
    }
    
    Bel *ret;
    if(stream->cache_used == 0) {
        ret = bel_stream_fill_cache(stream);
        if(bel_nilp(ret)) {
            return bel_mksymbol("eof");
        }
    }

    uint8_t mask = (1 << (stream->cache_used - 1));
    ret = bel_mkchar(((mask & stream->cache) == mask)
                     ? ((Bel_char)'1') : ((Bel_char)'0'));
    stream->cache_used--;
    return ret;
}
#+end_src

# TODO: Byte input/output -- unecessary?
# TODO: Text input/output, specifically for ins/outs -- unecessary?

We'll also need a tool to close a certain stream. Here we're being a
little more careful, since streams are managed more directly, by using
the C API. And of course, if we're dealing with output, dump the
stream cache before closing the file.

#+begin_src C
Bel*
bel_stream_close(Bel *obj)
{
    if(obj->type != BEL_STREAM) {
        return bel_mkerror(
            bel_mkstring("Cannot close something that "
                         "is not a stream."),
            bel_g_nil);
    }
    
    if(obj->stream.status == BEL_STREAM_CLOSED) {
        return bel_mkerror(
            bel_mkstring("Cannot close a closed stream."),
            bel_g_nil);
    }

    // Dump cache before closing
    if(obj->stream.status == BEL_STREAM_WRITE) {
        bel_stream_dump_cache(&obj->stream);
    }
    
    if(!fclose(obj->stream.raw_stream)) {
        obj->stream.raw_stream = NULL;
        obj->stream.status     = BEL_STREAM_CLOSED;
        return bel_g_t;
    }

    return bel_mkerror(
        bel_mkstring("Error closing stream: ~a."),
        bel_mkpair(
            bel_mkstring(strerror(errno)),
            bel_g_nil));
}
#+end_src

The default input and output streams are enclosed in Bel objects here,
however they relate to =stdin= and =stdout= respectively. To the system,
by default they have =nil= value.

#+begin_src C
void
bel_init_streams(void)
{
    bel_g_ins      = bel_g_nil;
    bel_g_outs     = bel_g_nil;
    bel_g_ins_sys  = bel_mkstream("ins",  BEL_STREAM_READ);
    bel_g_outs_sys = bel_mkstream("outs", BEL_STREAM_WRITE);
}
#+end_src

*** Stream manipulation safety

Since streams are defined taking advantage of the C API for
manipulating files, unfortunately these demand careful usage on Bel
programs. When handling streams, it is absolutely necessary to close
them. The Boehm GC does not have finalizers for C bindings, so
unfortunately it is not possible for now to call a finalizer which
automatically closes the stream when the stream object is garbage
collected.

** Numbers

As stated before, numbers are not described in Bel specification,
however we're implementing it for minimal ease and performance for
arithmetic manipulation.

We've built a resilient and recursive model for constituting numbers,
so we begin by arranging tools to create them.

*** Number generation

/Integers/ are pretty straightforward: we just allocate a proper space
and store them.

#+begin_src C
Bel*
bel_mkinteger(int64_t num)
{
    Bel *ret            = GC_MALLOC(sizeof (*ret));
    ret->type           = BEL_NUMBER;
    ret->number.type    = BEL_NUMBER_INT;
    ret->number.num_int = num;
    return ret;
}
#+end_src

The same goes for the /float/ type (which is actually a C double).

#+begin_src C
Bel*
bel_mkfloat(double num)
{
    Bel *ret              = GC_MALLOC(sizeof (*ret));
    ret->type             = BEL_NUMBER;
    ret->number.type      = BEL_NUMBER_FLOAT;
    ret->number.num_float = num;
    return ret;
}
#+end_src

A fraction has a layer of complexity, though. We take a numerator and
a denominator as /numbers/, but we need to make sure they are
numbers. Plus, even if they were, we need to make sure that the
denominator /is not zero/. However, the only checks we perform here are
related to the /numberness/ of numerator and denominator.

#+begin_src C
Bel*
bel_mkfraction(Bel *numer, Bel *denom)
{
    if(!bel_numberp(numer)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a number."),
            bel_mkpair(numer, bel_g_nil));
    }

    if(!bel_numberp(denom)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a number."),
            bel_mkpair(numer, bel_g_nil));
    }
    
    Bel *ret                   = GC_MALLOC(sizeof (*ret));
    ret->type                  = BEL_NUMBER;
    ret->number.type           = BEL_NUMBER_FRACTION;
    ret->number.num_frac.numer = numer;
    ret->number.num_frac.denom = denom;
    return ret;
}
#+end_src

We follow the same principle for a complex number: /real/ and /imaginary/
parts need to be a number themselves.

#+begin_src C
Bel*
bel_mkcomplex(Bel *real, Bel *imag)
{
    if(!bel_numberp(real)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a number."),
            bel_mkpair(real, bel_g_nil));
    }

    if(!bel_numberp(imag)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a number."),
            bel_mkpair(imag, bel_g_nil));
    }
    
    Bel *ret                   = GC_MALLOC(sizeof (*ret));
    ret->type                  = BEL_NUMBER;
    ret->number.type           = BEL_NUMBER_COMPLEX;
    ret->number.num_compl.real = real;
    ret->number.num_compl.imag = imag;
    return ret;
}
#+end_src

*** Number arithmetic

The following operations always happen between two numbers. We make
sure they are of compatible types to perform these operations, and
then we return numbers of a proper subtype afterwards.

**** Forward declarations

#+begin_src C
/* Forward declarations */
Bel *bel_num_add(Bel *x, Bel *y);
Bel *bel_num_sub(Bel *x, Bel *y);
Bel *bel_num_mul(Bel *x, Bel *y);
Bel *bel_num_div(Bel *x, Bel *y);
#+end_src

**** Coercion

Let's start with subtype coercion. Given a number and a number type
flag, we coerce that number to a new number of that subtype. Returns a
new number, and does not modify the old one.

Coercing a float to a fraction uses a naïve approach: we multiply the
number by =10= until it has no significant digits on the decimal
part. We count the =i= multiplications we've made, and then we build a
fraction where the numerator is a truncated, converted to integer
result, and the denominator is exactly ten to the power of =i=.

#+begin_src C
Bel*
bel_num_coerce(Bel *number, BEL_NUMBER_TYPE type)
{
    if(number->number.type == type)
        return number;

    switch(number->number.type) {
    case BEL_NUMBER_INT:
    {
        switch(type) {
        case BEL_NUMBER_FLOAT:
            return bel_mkfloat(
                (double)number->number.num_int);
        case BEL_NUMBER_FRACTION:
            return bel_mkfraction(
                number,
                bel_mkinteger(1));
        case BEL_NUMBER_COMPLEX:
            return bel_mkcomplex(
                number,
                bel_mkinteger(0));
        default: break;
        };
    }
    break;
    case BEL_NUMBER_FLOAT:
    {
        switch(type) {
        case BEL_NUMBER_INT:
            return bel_mkinteger(
                (int64_t)trunc(number->number.num_float));
        case BEL_NUMBER_FRACTION:
        {
            double num  = number->number.num_float;
            double trun = trunc(num);
            int i = 0;
            while(num != trun) {
                num *= 10.0;
                trun = trunc(num);
                i++;
            }
            return bel_mkfraction(
                bel_mkinteger((int64_t)num),
                bel_mkinteger((int64_t)pow(10, i)));
        }
        case BEL_NUMBER_COMPLEX:
            return bel_mkcomplex(number,
                                 bel_mkfloat(0.0));
        default: break;
        };
    }
    break;
    case BEL_NUMBER_FRACTION:
    {
        switch(type) {
        case BEL_NUMBER_INT:
        {
            Bel *float_res =
                bel_num_div(
                    bel_num_coerce(
                        number->number.num_frac.numer,
                        BEL_NUMBER_FLOAT),
                    bel_num_coerce(
                        number->number.num_frac.denom,
                        BEL_NUMBER_FLOAT));
            
            return bel_mkinteger(
                (int64_t)trunc(
                    float_res->number.num_float));
        }
        case BEL_NUMBER_FLOAT:
            return bel_num_div(
                bel_num_coerce(
                    number->number.num_frac.numer,
                    BEL_NUMBER_FLOAT),
                bel_num_coerce(
                    number->number.num_frac.denom,
                    BEL_NUMBER_FLOAT));
        case BEL_NUMBER_COMPLEX:
            return bel_mkcomplex(number,
                                 bel_mkinteger(0));
        default: break;
        };
    }
    break;
    case BEL_NUMBER_COMPLEX:
    {
        switch(type) {
        case BEL_NUMBER_INT:
        {
            Bel *coerced =
                bel_num_coerce(
                    number->number.num_compl.real,
                    BEL_NUMBER_FLOAT);
            
            return bel_mkinteger(
                (int64_t)trunc(
                    coerced->number.num_float));
        }
        case BEL_NUMBER_FLOAT:
            return bel_num_coerce(
                number->number.num_compl.real,
                BEL_NUMBER_FLOAT);
        case BEL_NUMBER_FRACTION:
            return bel_num_coerce(
                number->number.num_compl.real,
                BEL_NUMBER_FRACTION);
        default: break;
        };
    }
    break;
    default: break;
    };

    return number;
}
#+end_src

**** Force same type

The following function takes two numbers, and makes sure they both
have a subtype where both retain full information. Returns a pair
containing both numbers.

#+begin_src C
Bel*
bel_num_mksametype(Bel *x, Bel *y)
{
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        switch(y->number.type) {
        case BEL_NUMBER_INT:
            // int -> int -> int
            return bel_mkpair(x, y);
        case BEL_NUMBER_FLOAT:
            // int -> float -> float
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_FLOAT),
                y);
        case BEL_NUMBER_FRACTION:
            // int -> fraction -> fraction
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_FRACTION),
                y);
        case BEL_NUMBER_COMPLEX:
            // int -> complex -> complex
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_COMPLEX),
                y);
        default: break;
        }
        break;
    case BEL_NUMBER_FLOAT:
        switch(y->number.type) {
        case BEL_NUMBER_INT:
            // float -> int -> float
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FLOAT:
            // float -> float -> float
            // same type
            return bel_mkpair(x, y);
        case BEL_NUMBER_FRACTION:
            // float -> fraction -> fraction
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_FRACTION),
                y);
        case BEL_NUMBER_COMPLEX:
            // float -> complex -> complex
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_COMPLEX),
                y);
            break;
        default: break;
        }
        break;
    case BEL_NUMBER_FRACTION:
        switch(y->number.type) {
        case BEL_NUMBER_INT:
            // fraction -> int -> int
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FLOAT:
            // fraction -> float -> fraction
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FRACTION:
            // fraction -> fraction -> fraction
            // same type
            return bel_mkpair(x, y);
        case BEL_NUMBER_COMPLEX:
            // fraction -> complex -> complex
            return bel_mkpair(
                bel_num_coerce(x, BEL_NUMBER_COMPLEX),
                y);
            break;
        default: break;
        }
        break;
    case BEL_NUMBER_COMPLEX:
        switch(y->number.type) {
        case BEL_NUMBER_INT:
            // complex -> int -> complex
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FLOAT:
            // complex -> float -> complex
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_FRACTION:
            // complex -> fraction -> complex
            // duplicate
            return bel_num_mksametype(y, x);
        case BEL_NUMBER_COMPLEX:
            // complex -> complex -> complex
            // same type
            return bel_mkpair(x, y);
        default: break;
        }
        break;
    default: break;
    }

    // Satisfy the compiler on event of no coercion
    return bel_mkpair(x, y);
}
#+end_src

***** Helper macro for functions

The following macro does an inline conversion of =Bel= pointers to same
number subtype. Only the locals =x= and =y= will be affected; the original
pointed objects won't be modified.

#+begin_src C
#define BEL_NUM_SAMETYPE(x, y)                  \
    {                                           \
    Bel *p = bel_num_mksametype(x, y);          \
    x = bel_car(p);                             \
    y = bel_cdr(p);                             \
    }
#+end_src

**** Checking for zero

This function checks whether the argument is zero.

Comparing directly for zero on a double is not a really good
idea. We're doing a naïve approach here, but it is not completely
guaranteed.

#+begin_src C
int
bel_num_zerop(Bel *x)
{
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        return (x->number.num_int == 0);
    case BEL_NUMBER_FLOAT:
        return (x->number.num_float == 0.0)
            || (x->number.num_float == -0.0);
    case BEL_NUMBER_FRACTION:
        return bel_num_zerop(
            x->number.num_frac.numer);
    case BEL_NUMBER_COMPLEX:
        return (bel_num_zerop(
                    x->number.num_compl.real))
            && (bel_num_zerop(
                    x->number.num_compl.imag));
    }

    // This should not be reached...
    return 0;
}
#+end_src

**** Addition

The following function adds two arbitrary numbers.

#+begin_src C
Bel*
bel_num_add(Bel *x, Bel *y)
{
    BEL_NUM_SAMETYPE(x, y);
    
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        return bel_mkinteger(
            x->number.num_int + y->number.num_int);
    case BEL_NUMBER_FLOAT:
        return bel_mkfloat(
            x->number.num_float + y->number.num_float);
    case BEL_NUMBER_FRACTION:
    {
        Bel *new_numer_x =
            bel_num_mul(x->number.num_frac.numer,
                        y->number.num_frac.denom);
        Bel *new_numer_y =
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.numer);
        Bel *new_denom =
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.denom);

        return bel_mkfraction(
            bel_num_add(new_numer_x, new_numer_y),
            new_denom);
    }
    case BEL_NUMBER_COMPLEX:
        return bel_mkcomplex(
            bel_num_add(x->number.num_compl.real,
                        y->number.num_compl.real),
            bel_num_add(x->number.num_compl.imag,
                        y->number.num_compl.imag));
    default: break;
    };
    
    return bel_mkerror(
        bel_mkstring("Error while adding ~a and ~a."),
        bel_mkpair(x, bel_mkpair(y, bel_g_nil)));
}
#+end_src

**** Subtraction

This function is identical to =bel_num_add=, however it subtracts two
numbers.

#+begin_src C
Bel*
bel_num_sub(Bel *x, Bel *y)
{
    BEL_NUM_SAMETYPE(x, y);

    switch(x->number.type) {
    case BEL_NUMBER_INT:
        return bel_mkinteger(
            x->number.num_int - y->number.num_int);
    case BEL_NUMBER_FLOAT:
        return bel_mkfloat(
            x->number.num_float - y->number.num_float);
    case BEL_NUMBER_FRACTION:
    {
        Bel *new_numer_x =
            bel_num_mul(x->number.num_frac.numer,
                        y->number.num_frac.denom);
        Bel *new_numer_y =
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.numer);
        Bel *new_denom =
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.denom);

        return bel_mkfraction(
            bel_num_sub(new_numer_x, new_numer_y),
            new_denom);
    }
    case BEL_NUMBER_COMPLEX:
        return bel_mkcomplex(
            bel_num_sub(x->number.num_compl.real,
                        y->number.num_compl.real),
            bel_num_sub(x->number.num_compl.imag,
                        y->number.num_compl.imag));
    default: break;
    };
    
    return bel_mkerror(
        bel_mkstring("Error while subtracting ~a "
                     "and ~a."),
        bel_mkpair(x, bel_mkpair(y, bel_g_nil)));
}
#+end_src

**** Multiplication

This function multiplies two arbitrary numbers.

#+begin_src C
Bel*
bel_num_mul(Bel *x, Bel *y)
{
    BEL_NUM_SAMETYPE(x, y);
    
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        return bel_mkinteger(
            x->number.num_int * y->number.num_int);
    case BEL_NUMBER_FLOAT:
        return bel_mkfloat(
            x->number.num_float * y->number.num_float);
    case BEL_NUMBER_FRACTION:
        return bel_mkfraction(
            bel_num_mul(x->number.num_frac.numer,
                        y->number.num_frac.numer),
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.denom));
    case BEL_NUMBER_COMPLEX:
    {
        Bel *real =
            bel_num_sub(
                bel_num_mul(x->number.num_compl.real,
                            y->number.num_compl.real),
                bel_num_mul(x->number.num_compl.imag,
                            y->number.num_compl.imag));
        Bel *imag =
            bel_num_add(
                bel_num_mul(x->number.num_compl.real,
                            y->number.num_compl.imag),
                bel_num_mul(x->number.num_compl.imag,
                            y->number.num_compl.real));

        return bel_mkcomplex(real, imag);
    }
    break;
    default: break;
    };

    return bel_mkerror(
        bel_mkstring("Error while multiplying "
                     "~a and ~a."),
        bel_mkpair(x, bel_mkpair(y, bel_g_nil)));
}
#+end_src

**** Division

This function divides two arbitrary numbers.
Notice that we check whether the second argument is zero.

#+begin_src C
Bel*
bel_num_div(Bel *x, Bel *y)
{
    BEL_NUM_SAMETYPE(x, y);

    if(bel_num_zerop(y)) {
        return bel_mkerror(
            bel_mkstring("Cannot divide by zero."),
            bel_g_nil);
    }
    
    switch(x->number.type) {
    case BEL_NUMBER_INT:
        if(x->number.num_int % y->number.num_int) {
            return bel_mkfraction(x, y);
        } else {
            return bel_mkinteger(
                x->number.num_int / y->number.num_int);
        }
    case BEL_NUMBER_FLOAT:
        return bel_mkfloat(
            x->number.num_float / y->number.num_float);
    case BEL_NUMBER_FRACTION:
        return bel_mkfraction(
            bel_num_mul(x->number.num_frac.numer,
                        y->number.num_frac.denom),
            bel_num_mul(x->number.num_frac.denom,
                        y->number.num_frac.numer));
    case BEL_NUMBER_COMPLEX:
    {
        Bel *numer = bel_mkcomplex(
            bel_num_add(
                bel_num_mul(x->number.num_compl.real,
                            y->number.num_compl.real),
                bel_num_mul(x->number.num_compl.imag,
                            y->number.num_compl.imag)),
            bel_num_add(
                bel_num_mul(
                    bel_mkinteger(-1),
                    bel_num_mul(x->number.num_compl.real, y->number.num_compl.imag)),
                bel_num_mul(x->number.num_compl.imag,
                            y->number.num_compl.real)));

        Bel *denom = bel_num_add(
            bel_num_mul(y->number.num_compl.real,
                        y->number.num_compl.real),
            bel_num_mul(y->number.num_compl.imag,
                        y->number.num_compl.imag));

        return bel_mkfraction(numer, denom);
    }
    default: break;
    }

    return bel_mkerror(
        bel_mkstring("Error while dividing "
                     "~a and ~a."),
        bel_mkpair(x, bel_mkpair(y, bel_g_nil)));
}
#+end_src

** Errors

Bel does not have a formal specification on errors in primitives,
other than saying that there might be an =err= function which throws an
error in the system.

I will therefore specify that, in Believe, an error is a literal (much
like closures and primitives) which obeys the pattern...

=(lit err format . args)=

...where =lit= is the expected symbol for something that evaluates to
itself, =err= is the symbol which specifies that the object is an error,
=format= is a Bel string which contains a format for the given
arguments, and =args= is a list of arguments which should be parsed
within the format.

For a first implementation, I intend to make the format specification
follow loosely the conventions of the =format= macro in Common Lisp,
having =~a= as the format for any object and =~%= as the format for a new
line, for example.

Here's how it could look like:

#+begin_example
> (err "Cannot use ~a on ~a.~%" '(1 2 3) square)
Error: Cannot use (1 2 3) on (lit clo nil (x) (* x x)).

#+end_example

However, since this is a detail which can be implemented in Bel
itself, we'll just go ahead and say that there is a string format and
a list of arguments.

#+begin_src C
Bel*
bel_mkerror(Bel *format, Bel *arglist)
{
    return bel_mkpair(
        bel_mksymbol("lit"),
        bel_mkpair(
            bel_mksymbol("err"),
            bel_mkpair(format, arglist)));
}
#+end_src

* Axioms

To save memory, some of the following things will be globally defined.

** Variables and constants

Define global symbols which can be used across the program. These
symbols should be used repeatedly, and that's why they were already
declared. See the =bel_init= function to refer to their initialization.

#+begin_src C
void
bel_init_ax_vars(void)
{
    bel_g_nil   = bel_mksymbol("nil");
    bel_g_t     = bel_mksymbol("t");
    bel_g_o     = bel_mksymbol("o");
    bel_g_apply = bel_mksymbol("apply");

    bel_g_prim  = bel_mksymbol("prim");
    bel_g_clo   = bel_mksymbol("clo");
}
#+end_src

=bel_g_prim= is not part of the axiom variables, but we'll define it
here since we'll need this symbol for generating primitives later.

** List of all characters

First, we build an auxiliary function which converts an 8-bit number
into a string, where each character represents a bit.

#+begin_src C
char*
bel_conv_bits(uint8_t num)
{
    char *str = GC_MALLOC_ATOMIC(9 * sizeof(*str));
    
    uint8_t i;
    for(i = 0; i < 8; i++) {
        int is_bit_set = num & (1 << i);
        str[7 - i] = is_bit_set ? '1' : '0';
    }
    str[8] = '\0';
    
    return str;
}
#+end_src

We build a list of all characters so that the specification gets
happy. It will be stored in the previously defined =bel_g_chars= global
variable. This might seem unecessary in the future, though.

The list is supposed to be built out of pairs, therefore we start by
creating 255 =Bel= instances, representing list nodes; every node is
supposed to hold the pointer to a =Bel_pair=. These pairs will be linked
to one another: the /cdr/ of the first =Bel_pair= (again, contained inside
a =Bel= instance) points to the second =Bel=; the /cdr/ of the second
=Bel_pair= (also contained on its =Bel= instance) points to the third =Bel=,
and so on. The last /cdr/ of the last =Bel_pair=, also enclosed on a =Bel=
instance, contains the symbol =nil=.

Now, we discuss what should be held in the /car/ of each of these
pairs. And that would be other pairs, which will hold the actual
information we desire. Each of these secondary pairs is comprised of a
character at its /car/, and a Bel string representing the bits of the
character as its /cdr/.

#+begin_src C
void
bel_init_ax_chars(void)
{
    // Create a vector of 255 list nodes
    Bel **list = GC_MALLOC(255 * sizeof(*list));

    size_t i;
    for(i = 0; i < 255; i++) {        
        // Build a pair which holds the character information
        Bel *pair = bel_mkpair(bel_mkchar((Bel_char)i), bel_mkstring(bel_conv_bits(i)));
        // Assign the car of a node to the current pair,
        // set its cdr temporarily to nil
        list[i] = bel_mkpair(pair, bel_g_nil);
    }

    // Assign each pair cdr to the pair on the front.
    // Last pair should have a nil cdr still.
    for(i = 0; i < 254; i++) {
        list[i]->pair->cdr = list[i + 1];
    }

    // Hold reference to first element only
    bel_g_chars = list[0];
}
#+end_src

** Environment

Any environment is nothing but a list of pairs, where each pair =(var
. val)= represents the binding of a specific symbol =var= to the value
=val=.

We begin by creating a function which pushes, non-destructively, a new
pair to any environment. The result is the new environment.

#+begin_src C
Bel*
bel_env_push(Bel *env, Bel *var, Bel *val)
{
    Bel *new_pair = bel_mkpair(var, val);
    return bel_mkpair(new_pair, env);
}
#+end_src

Notice that this non-destructive approach is important, since a
lexical enviroment is supposed to extend the enviroment it is called
on -- for example, the environment of a function called from top-level
is a list where the first elements are lexical bindings, and
(conceptually) the latter elements are bindings belonging to the
global environment.

Now we register all our axioms to our global environment. This way, a
lookup operation on the global scope will yield proper values.

First, we define a macro which uses =bel_env_push= to modify the =globe=
environment variable. This macro just takes a =SYMSTR=, turns it into a
symbol, and generates a new environment, which is then assigned to the
global environment.

#+begin_src C
#define BEL_ENV_GLOBAL_PUSH(SYMSTR, VAL)           \
    (bel_g_globe =                                 \
     bel_env_push(bel_g_globe,                     \
                  bel_mksymbol(SYMSTR), VAL))
#+end_src

Initializing the global environment involves pushing certain values to
it. But the dynamic and lexical environments are initialized to =nil=.

#+begin_src C
void
bel_init_ax_env(void)
{
    bel_g_globe = bel_g_nil;
    bel_g_dynae = bel_g_nil;
    bel_g_scope = bel_g_nil; // TODO: is this really necessary?
    
    BEL_ENV_GLOBAL_PUSH("chars", bel_g_chars);
    BEL_ENV_GLOBAL_PUSH("ins",   bel_g_ins);
    BEL_ENV_GLOBAL_PUSH("outs",  bel_g_outs);
}
#+end_src

Then, we create a lookup function. This function traverses an
environment in linear time, so it is not fast, but it does its job. A
lookup process either returns the associated value or returns =nil=.

#+begin_src C
Bel*
bel_env_lookup(Bel *env, Bel *sym)
{
    if(bel_nilp(env)) {
        return bel_g_nil;
    }
    
    if(!bel_symbolp(sym)) {
        return bel_mkerror(
            bel_mkstring("Cannot perform lookup of ~a, "
                         "which is not a symbol."),
            bel_mkpair(sym, bel_g_nil));
    }

    Bel *itr = env;
    while(!bel_nilp(itr)) {
        Bel *p = bel_car(itr);
        if(bel_car(p)->type == BEL_SYMBOL
           && bel_car(p)->sym == sym->sym) {
            return bel_cdr(p);
        }
        
        itr = bel_cdr(itr);
    }
    return bel_g_nil;
}
#+end_src

We also implement a proper lookup function which takes a lexical
environment and a symbol. The function traverses all environments in
order (dynamic, lexical, global) to find the associated value of the
given symbol. If the symbol is not found, returns an error.

#+begin_src C
Bel*
bel_lookup(Bel *lenv, Bel *sym)
{
    Bel *value;

    // Dynamic scope lookup
    value = bel_env_lookup(bel_g_dynae, sym);
    if(!bel_nilp(value)) {
        return value;
    }
    
    // Lexical scope lookup
    value = bel_env_lookup(lenv, sym);
    if(!bel_nilp(value)) {
        return value;
    }

    // Global scope lookup
    value = bel_env_lookup(bel_g_globe, sym);
    if(bel_nilp(value)) {
        return bel_mkerror(
            bel_mkstring("The symbol ~a is unbound."),
            bel_mkpair(sym, bel_g_nil));
    }

    return value;
}
#+end_src

Another thing to do is enable assignment. We begin by creating a
function which finds a specific symbol on a specific environment and
replaces its value by the given one. On success, it returns the
symbol; on failure, it returns =nil=. If the environment is empty, we
also return =nil=. Oh, we also don't check if the given symbol is really
a symbol, since this is an internal function.

#+begin_src C
Bel*
bel_env_replace_val(Bel *env, Bel *sym, Bel *new_val)
{
    if(bel_nilp(env)) {
        return bel_g_nil;
    }
    
    Bel *itr = env;
    while(!bel_nilp(itr)) {
        Bel *p = bel_car(itr);
        if(bel_idp(sym, bel_car(p))) {
            p->pair->cdr = new_val;
            return sym;
        }
        itr = bel_cdr(itr);
    }
    return bel_g_nil;
}
#+end_src

We also need a function which takes the reference to an environment
and a symbol, and /unbinds/ that symbol from the value in the
environment. This can be achieved by simply iterating over the list
and "unlinking" the relevant pair. We also don't perform all the
checks on this internal function.

This function might modify the environment passed as reference by
argument. We only return a non-nil answer (which is the same
environment, but modified) if and only if the unbinding was
successful.

#+begin_src C
Bel*
bel_env_unbind(Bel **env, Bel *sym)
{
    if(bel_nilp(*env)) {
        return bel_g_nil;
    }
    
    // If first element is a match, return
    // cdr of environment
    if(bel_idp(bel_car(bel_car(*env)), sym)) {
        ,*env = bel_cdr(*env);
        return bel_g_t;
    }

    // Iterate looking at the next element always.
    // If next element is a match, set current cdr
    // to cdr of next element
    Bel *itr = *env;
    while(!bel_nilp(bel_cdr(itr))) {
        Bel *p = bel_car(bel_cdr(itr));
        if(bel_idp(bel_car(p), sym)) {
            itr->pair->cdr = p->pair->cdr;
            return bel_g_t;
        }
        
        itr = bel_cdr(itr);
    }

    // On no substitution, return nil
    return bel_g_nil;
}
#+end_src

The assignment operation itself respects the hierarchy of
environments, to be described in the next subsection. We attempt to
make an assignment on the three kinds of environment (lexical -- given
as argument --, dynamic and global). If the assignment fails in any of
these, the symbol is bound to the given new value, on the /global/
environment.

#+begin_src C
Bel*
bel_assign(Bel *lenv, Bel *sym, Bel *new_val)
{
    Bel *ret;

    // Dynamic assignment
    ret = bel_env_replace_val(bel_g_dynae, sym, new_val);
    if(!bel_nilp(ret)) return sym;
    
    // Lexical assignment
    ret = bel_env_replace_val(lenv, sym, new_val);
    if(!bel_nilp(ret)) return sym;

    // Global assignment
    ret = bel_env_replace_val(bel_g_globe, sym, new_val);
    if(!bel_nilp(ret)) return sym;

    // When not assignment was made, we push a global value
    bel_g_globe = bel_env_push(bel_g_globe, sym, new_val);
    return sym;
}
#+end_src

We proceed by the same principle for the actual unbinding function: we
respect the hierarchy of environments. Like =bel_env_unbind=, this
function might modify the passed environment, and that is why we take
a reference to it.

#+begin_src C
Bel*
bel_unbind(Bel **lenv, Bel *sym)
{
    Bel *ans;

    // Dynamic unbinding
    ans = bel_env_unbind(&bel_g_dynae, sym);
    if(!bel_nilp(ans)) {
        return sym;
    }
    
    // Lexical unbinding
    ans = bel_env_unbind(lenv, sym);
    if(!bel_nilp(ans)) {
        return sym;
    }

    // Global unbinding
    ans = bel_env_unbind(&bel_g_globe, sym);
    if(!bel_nilp(ans)) {
        return sym;
    }

    // On no unbinding, return nil
    return bel_g_nil;
}
#+end_src

*** Types and hierarchy of environments

There are three kinds of environments in Bel: Global, Lexical and
Dynamic. The global environment (=bel_g_globe=, =globe=) contains symbols
which are always visible from all scopes. This environment lives for
the lifetime of the interpreter.

The lexical environment (=bel_g_scope=, =scope=) contains symbols which
are visible only inside the current scope, and lives for a short
period of time, linked to its scope. It is the environment captured by
closures, and also the environment created when a closure is applied
(as a specific symbol is bound to evaluate a closure's body).

The dynamic environment (=bel_g_dynae=) is like the global environment
on its regards to access (symbols are visible to the whole
application). However, the dynamic environment lives for a short
period of time, linked to the scope it is used.

In Bel, any symbol lookup is performed by traversing the environments
in the following order: /Dynamic/, /Lexical/, /Global/.

*** Environment extension and capturing

Being a sequential list of pairs, where the values are pushed to their
top, environments (such as the lexical) can share symbols. For
example, suppose the following closure called =orig-fun=.

#+begin_example lisp
(def orig-fun (x y)
  (join (new-fun x) y))
#+end_example

Suppose further that this closure is applied to the symbols =foo= and
=bar=. They are then bound respectively to =x= and =y=. The closure's
lexical environment during application would look like this:

#+begin_example lisp
((y . bar)  (x . foo))
#+end_example

Suppose also that the closure =new-fun= is defined like this:

#+begin_example lisp
(def new-fun (x)
  (id x 'foo))
#+end_example

When =new-fun= is applied inside =orig-fun=, it captures =orig-fun='s
lexical environment. Additionally, =new-fun= binds =foo= (associated with
the original =x= symbol) to a new =x= symbol. So =new-fun='s lexical
environment looks like this:

#+begin_example lisp
((x . foo)  (y . bar)  (x . foo))
#+end_example

Since the environment stacks up definitions, a lookup process begins
at top (here displayed as the leftmost pair) and finds the first
binding of the requested symbol that it can find. So in =new-fun=, the
value associated to the symbol =x= can only be the first pair
represented above; however, after the evaluation of =new-fun=, back at
=orig-fun=, the associated value of =x= would be the last pair.

Another interesting fact is that, if =new-fun= were to make a blind
assignment to =y= after being called inside =orig-fun=, =y='s associated
value would be changed in =orig-fun='s lexical environment, so the
new value of =y= would be seen not only at =new-fun=; it would still be
different when we returned to =orig-fun=.

If =new-fun= were called from outside =orig-fun= (more specifically, at
top level), such assignment to =y= would create a new binding on the
global environment, effectively creating a new global variable.

** Literals

Although literals have already been seen on error implementation, but
here we reuse the concept to generate literals that should exist on
the global environment.

A /literal/ is a list, where the first element is the symbol
=lit=. Literals are described like persistent quotes, since evaluating a
quoted form strips away the quoting. A /literal/ is what should be used
to describe things that evaluate to themselves.

Literals follow the form =(lit . rest)=, where =lit= is a symbol, and =rest=
is a proper list of things that should be treated as a literal.

Primitives and functions are internally described as /literals/.

The first thing to do is create a tool for generating a literal; in
general, what it does is create a pair, where the /car/ is the symbol
=lit=, and the /cdr/ is anything that should be treated as a literal.

#+begin_src C
Bel*
bel_mkliteral(Bel *rest)
{
    if(!bel_proper_list_p(rest)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a "
                         "proper list to be turned "
                         "into a literal."),
            bel_mkpair(rest, bel_g_nil));
    }

    return bel_mkpair(bel_mksymbol("lit"),
                      rest);
}
#+end_src

*** Primitives

As stated above, primitives are represented as literals, since they
evaluate to themselves. We start by defining a tool to create a
certain primitive; it should be noted that, since primitives are
internal to the Bel implementation, this function does not check for
errors.

A primitive has the form =(lit prim name)=, where =lit= and =prim= are
constant symbols, and =name= is a symbol for the primitive name.

#+begin_src C
Bel*
bel_mkprim(Bel *sym)
{
    return bel_mkliteral(
        bel_mkpair(bel_g_prim,
                   bel_mkpair(sym, bel_g_nil)));
}
#+end_src

The next definition is a macro where, given an environment =env= and a
C string literal =x=, it generates a primitive for =x= and pushes it to
the enviroment =env=.

#+begin_src C
#define BEL_REGISTER_PRIM(env, x)               \
    {                                           \
    Bel *sym = bel_mksymbol(x);                 \
    env = bel_env_push(env, sym,                \
                       bel_mkprim(sym));        \
    }
#+end_src

Then we create a function where, given an environment =env=, it
registers all Bel primitives on it, creating a new environment which
is returned. Notice that this new environment is in fact making use of
the original one.

#+begin_src C
Bel*
bel_gen_primitives(Bel *env)
{
    // Primitive functions
    BEL_REGISTER_PRIM(env, "id");
    BEL_REGISTER_PRIM(env, "join");
    BEL_REGISTER_PRIM(env, "car");
    BEL_REGISTER_PRIM(env, "cdr");
    BEL_REGISTER_PRIM(env, "type");
    BEL_REGISTER_PRIM(env, "xar");
    BEL_REGISTER_PRIM(env, "xdr");
    BEL_REGISTER_PRIM(env, "sym");
    BEL_REGISTER_PRIM(env, "nom");
    BEL_REGISTER_PRIM(env, "wrb");
    BEL_REGISTER_PRIM(env, "rdb");
    BEL_REGISTER_PRIM(env, "ops");
    BEL_REGISTER_PRIM(env, "cls");
    BEL_REGISTER_PRIM(env, "stat");
    BEL_REGISTER_PRIM(env, "coin");
    BEL_REGISTER_PRIM(env, "sys");

    // Primitive operators
    BEL_REGISTER_PRIM(env, "+");
    BEL_REGISTER_PRIM(env, "-");
    BEL_REGISTER_PRIM(env, "*");
    BEL_REGISTER_PRIM(env, "/");
    BEL_REGISTER_PRIM(env, "<");
    BEL_REGISTER_PRIM(env, "<=");
    BEL_REGISTER_PRIM(env, ">");
    BEL_REGISTER_PRIM(env, ">=");
    BEL_REGISTER_PRIM(env, "=");

    // Other primitives
    BEL_REGISTER_PRIM(env, "err");
    BEL_REGISTER_PRIM(env, "gc");

    return env;
}
#+end_src

The last step is to have a function which pushes these primitives
automatically to the =globe= environment.

#+begin_src C
void
bel_init_ax_primitives()
{
    bel_g_globe = bel_gen_primitives(bel_g_globe);
}
#+end_src

*** Closures

Creating a closure is very straightforward. We take an environment and
a list. Such list must have two elements, where the first is a lambda
list, and the second is the body of the function.

#+begin_src C
Bel*
bel_mkclosure(Bel *lenv, Bel *rest)
{
    return bel_mkliteral(
        bel_mkpair(bel_g_clo,
                   bel_mkpair(lenv, rest)));
}
#+end_src

* Printing

The following functions are used to print a certain object on standard
output.

# TODO: Print to Bel streams?

** Forward declarations

We forward declare the =bel_print= function since printing pairs calls
it for the pairs' parts.

#+begin_src C
void bel_print(Bel*);
void bel_print_closure(Bel*);
void bel_print_primitive(Bel*);
#+end_src

** Printing pairs

The first function is a specialization for printing pairs in
general. This function should also handle the printing of lists
gracefully.

A closure is also  a pair (a literal, to be more  precise), but it has
its own printing function, which we invoke if needed.

Similarly,  a  primitive  is  a  primitive  function  whose  body  and
environment are not explicit to the Bel language, so we also add a way
to print them.

#+begin_src C
void
bel_print_pair(Bel *obj)
{
    if(bel_nilp(obj)) return;

    Bel *itr = obj;
    
    // Handle printing closures
    // and primitives
    if(bel_closurep(obj)) {
        bel_print_closure(obj);
        return;
    } else if(bel_primitivep(obj)) {
        bel_print_primitive(obj);
        return;
    }

    putchar('(');
    while(!bel_nilp(itr)) {
        Bel *car = bel_car(itr);
        Bel *cdr = bel_cdr(itr);

        bel_print(car);
        
        if(bel_nilp(cdr)) {
            break;
        } else if(cdr->type != BEL_PAIR) {
            putchar(' ');
            putchar('.');
            putchar(' ');
            bel_print(cdr);
            break;
        }
        putchar(' ');
        itr = cdr;
    }
    putchar(')');
}
#+end_src

*** Printing functions

We also add  a general way for printing closures.  This also turns the
closure  printing  safer,  since  we   do  not  print  the  associated
environment.

#+begin_src C
void
bel_print_closure(Bel *obj)
{
    Bel *lambda_list =
        bel_car(bel_cdr(bel_cdr(bel_cdr(obj))));
    printf("#<function (fn ");
    if(bel_nilp(lambda_list)) {
        printf("()");
    } else bel_print_pair(lambda_list);
    printf(") {%p}>", (void*)obj);
}
#+end_src

Another useful  function to have is  a way to print  primitives, which
are Bel functions that work like axioms, defined through C code.

#+begin_src C
void
bel_print_primitive(Bel *obj)
{
    Bel *name = bel_car(bel_cdr(bel_cdr(obj)));
    printf("#<function (prim ");
    bel_print(name);
    putchar(')');
    putchar('>');
}
#+end_src

** Printing strings

A string is a very specific type of list: it is a proper list
comprised only of characters. However, this function is not supposed
to test for the object's type; instead, it must be called when we are
certain that the object in question is a string.

#+begin_src C
void
bel_print_string(Bel *obj)
{
    putchar('\"');
    Bel *itr = obj;
    while(!bel_nilp(itr)) {
        Bel_char c = bel_car(itr)->chr;

        switch(c) {
        case '\a': printf("\\bel"); break;
        default:   putchar(c);      break;
        }

        itr = bel_cdr(itr);
    }
    putchar('\"');
}
#+end_src

** Printing streams

Printing a stream involves printing something that cannot be read back
in, so it can be considered merely aestethic. I made an option of
either printing that it is closed, or printing its status along with
the raw pointer.

#+begin_src C
void
bel_print_stream(Bel *obj)
{
    printf("#<stream :status ");
    if(obj->stream.status == BEL_STREAM_CLOSED) {
        printf("closed>");
    } else {
        switch(obj->stream.status) {
        case BEL_STREAM_READ:  printf("input ");  break;
        case BEL_STREAM_WRITE: printf("output "); break;
        default: printf("unknown ");              break;
        }
        printf("{0x%08lx}>", (uint64_t)obj->stream.raw_stream);
    }
}
#+end_src

** Printing numbers

We develop a function to print an arbitrary number. The function takes
the number itself and a parameter which tells whether the sign should
be explicit (the reason for that will be evident soon).

To print an /integer/, the only thing to do is to print a =long int=. We
prepend it with a plus if the number is positive and the explicit sign
flag is on.

To print a /float/, we print a =double= with reduced notation. If the
number is round, we append =.0= to it. We also follow the same rule of
/integers/ when prepending the plus sign.

A /fraction/ is a pair of two numbers. We just enclose them in a textual
representation like =#(f number)=, where =number= is the numerator and
the denominator separated by a slash. These two components can also be
numbers of any kind, so we print them recursively, without forcing the
plus sign.

A /complex/ is also a pair of two numbers of any kind, where the first
number is the /real/ part and the second number is the /imaginary/ part,
which multiplies =i=. So we enclose it in a textual representation like
=#(c number)=, where =number= is a complex number in the form =R+Ai=. In
this form, =R= is the real part, printed as any Bel number; =A= is the
imaginary part, but we force it to print its sign on screen, and then
we prepend it with an =i=. To force =A='s sign to appear, we call this
function recursively, with the =force_sign= flag active.

#+begin_src C
void
bel_print_number(Bel *num, int force_sign)
{
    switch(num->number.type) {
    case BEL_NUMBER_INT:
        if(force_sign && (num->number.num_int >= 0))
            putchar('+');
        printf("%ld", num->number.num_int);
        break;
    case BEL_NUMBER_FLOAT:
        if(force_sign && (num->number.num_float >= 0.0))
            putchar('+');
        printf("%lg", num->number.num_float);
        // Trailing .0 on round number
        if(num->number.num_float
           == trunc(num->number.num_float)) {
            printf(".0");
        }
        break;
    case BEL_NUMBER_FRACTION:
        printf("#(f ");
        bel_print_number(num->number.num_frac.numer, 0);
        putchar('/');
        bel_print_number(num->number.num_frac.denom, 0);
        putchar(')');
        break;
    case BEL_NUMBER_COMPLEX:
        printf("#(c ");
        bel_print_number(num->number.num_frac.numer, 0);
        bel_print_number(num->number.num_frac.denom, 1);
        printf("i)");
        break;
    default:
        printf("#<\?\?\?>");
        break;
    }
}
#+end_src

** Generic printing

The next function handles the printing of any data type. Notice that
it does not automatically print a newline character.

#+begin_src C
void
bel_print(Bel *obj)
{
    switch(obj->type) {
    case BEL_SYMBOL:
        printf("%s", g_sym_table.tbl[obj->sym]);
        break;
    case BEL_PAIR:
        if(!bel_stringp(obj)) {
            bel_print_pair(obj);
        } else {
            bel_print_string(obj);
        }
        break;
    case BEL_CHAR:
        if(obj->chr == '\a')
            printf("\\bel"); // There is no Bel without \bel
        else printf("\\%c", obj->chr);
        break;
    case BEL_STREAM:
        bel_print_stream(obj);
        break;
    case BEL_NUMBER:
        bel_print_number(obj, 0);
        break;
    default:
        printf("#<\?\?\?>"); // wat
        break;
    };
}
#+end_src

* Evaluator

The evaluator is the most crucial part of the Bel system. We follow
the pattern of the /metacircular evaluator/: by having two functions,
=eval= and =apply=, we make them call themselves mutually, equipping
them with auxiliary functions and special forms to produce a working
interpreter for a Lisp language.

** Forward declarations

These declarations specify the most crucial functions of the
interpreter. Forward declarations are important for the mutual calling
part.

#+begin_src C
/* Forward declarations */
Bel *bel_eval(Bel *exp, Bel *lenv);
Bel *bel_apply(Bel *proc, Bel *args);
Bel *bel_evlist(Bel *elist, Bel *lenv);
Bel *bel_apply_primop(Bel *sym, Bel *args);
Bel *bel_bind(Bel *vars, Bel *vals, Bel *lenv);
#+end_src

The following forward declarations are related to /special forms/ on the
evaluator. These special forms are handled outside of the /eval/
function to make it more succinct.

#+begin_src C
/* Forward declarations */
Bel *bel_special_if(Bel *exp, Bel *lenv);
Bel *bel_special_quote(Bel *exp, Bel *lenv);
Bel *bel_special_dyn(Bel *rest, Bel *lenv);
Bel *bel_special_set(Bel *clauses, Bel *lenv);
#+end_src

** The /eval/ function

=bel_eval= is the /evaluation/ function. The objective is to take a
particular expression, identify what it is (whether it is a special
form or a simple function application), and dispatch it
accordingly.

When a simple application is performed, we take a list and consider
that the first element is the symbol that the function is bound to. So
we evaluate every element of the list, including the function, and
then we /apply/ the closure (produced by evaluation of the function) to
the rest of the evaluated elements, which will be passed as
arguments.

It is also important to notice that the closure captures the lexical
environment where it is evaluated.

#+begin_src C
Bel*
bel_eval(Bel *exp, Bel *lenv)
{
/* #ifdef BEL_DEBUG */
/*     printf("eval>  "); */
/*     bel_print(exp); */
/*     putchar(10); */
/* #endif */

    // numbers eval to themselves
    if(bel_numberp(exp))
        return exp;
    
    // symbol
    if(bel_symbolp(exp)) {
        // If one of axiom symbols, eval to itself
        if(bel_idp(exp, bel_g_nil)
           || bel_idp(exp, bel_g_t)
           || bel_idp(exp, bel_g_o)
           || bel_idp(exp, bel_g_apply))
            return exp;
        // else lookup on table
        return bel_lookup(lenv, exp);
    }

    // quote
    if(bel_quotep(exp))
        return bel_special_quote(exp, lenv);
    
    // lit
    else if(bel_literalp(exp))
        return exp; // eval to itself

    // string
    else if(bel_stringp(exp))
        return exp; // eval to itself

    // Special forms
    else if(bel_proper_list_p(exp)) {
        // fn: closure
        if(bel_idp(bel_car(exp), bel_mksymbol("fn")))
            return bel_mkclosure(lenv, bel_cdr(exp));
    
        // if
        if(bel_idp(bel_car(exp), bel_mksymbol("if")))
            return bel_special_if(exp, lenv);

        // TODO:
        // apply
        // where (not straightforward)
        
        // dyn
        if(bel_idp(bel_car(exp), bel_mksymbol("dyn")))
            return bel_special_dyn(bel_cdr(exp), lenv);
        
        // after
        
        // set (global binding)
        if(bel_idp(bel_car(exp), bel_mksymbol("set")))
            return bel_special_set(bel_cdr(exp), lenv);
        
        // ccc (call/cc)
        // thread (does not share dynamic binding)

        // otherwise it is the case of an application
        return bel_apply(bel_eval(bel_car(exp), lenv),
                         bel_evlist(bel_cdr(exp), lenv));
    }

    return bel_mkerror(
        bel_mkstring("~a is not a proper list "
                     "for the application of "
                     "a function."),
        bel_mkpair(exp, bel_g_nil));
}
#+end_src

** The /apply/ function

=bel_apply= is the /application/ function. It takes a certain /function/ and
applies to the /list of evaluated arguments/. A function can be a
primitive, but can also be a /literal closure/.

To apply a /closure/, we bind all arguments to the closure's formal
parameters, creating an extended lexical environment; then we proceed
to evaluate the closure's body under that new lexical environment.

#+begin_src C
Bel*
bel_apply(Bel *fun, Bel *args)
{
/* #ifdef BEL_DEBUG */
/*     printf("apply> "); */
/*     bel_print(fun); */
/*     printf(" -> "); */
/*     bel_print(args); */
/*     putchar(10); */
/* #endif */
    
    // Check for errors on fun
    if(bel_errorp(fun)) {
        return fun;
    }
    
    // Primitive procedure
    else if(bel_primitivep(fun)) {
        return bel_apply_primop(
            bel_car(bel_cdr(bel_cdr(fun))),
            args);
    }
    
    // Closure
    else if(bel_closurep(fun)) {
        Bel *lenv =
            bel_car(
                bel_cdr(bel_cdr(fun)));
        Bel *lambda_list =
            bel_car(
                bel_cdr(bel_cdr(bel_cdr(fun))));
        Bel *body =
            bel_car(
                bel_cdr(bel_cdr(bel_cdr(
                                    bel_cdr(fun)))));
        
        // Generate a new environment with the
        // arguments bound in it
        Bel *new_env = bel_bind(lambda_list,
                                args,
                                lenv);

        if(bel_errorp(new_env)) {
            return new_env;
        }

        // Evaluate body on the new environment
        return bel_eval(body, new_env);
    }

    // Error
    else {
        return bel_mkerror(
            bel_mkstring("~a is not a procedure"),
            bel_mkpair(fun, bel_g_nil));
    }
}
#+end_src

** Auxiliary functions

The following functions are also essential to the evaluator, but have
a more secondary role, such as handling special forms, applying
primitive operators, and other kinds of things.

*** Evaluating special forms

Some special forms require greater attention, and so it is a little
better to give them their own function.

**** =(quote x)=

In Lisp languages, quoting an atom, like the expression ='a=, translates
to an expression such as =(quote a)=, which will then be evaluated by
returning only the symbol =a=.

#+begin_src C
Bel*
bel_special_quote(Bel *exp, Bel *lenv)
{
    uint64_t len = bel_length(exp);
    if(len != 2) {
        return bel_mkerror(
            bel_mkstring("Malformed quote: can only "
                         "quote one object."),
            bel_g_nil);
    }

    return bel_car(bel_cdr(exp));
}
#+end_src

**** =(if . clauses)=

The conditional =if= takes any number of clauses (at least two), and
does their evaluation in pairs of clauses (not to be confused with the
pair data type).

Suppose that we have a conditional such as

#+begin_example lisp
(if cond1 pred1 cond2 pred2)
#+end_example

We evaluate =cond1=. If its result is not =nil=, we return the evaluation
of =pred1=.

If evaluation of =cond1= is =nil=, however, we don't evaluate =pred1=; we
proceed to test the evaluation of =cond2=. If =cond2= yields a non-=nil=
result, however, we return the evaluation of =pred2=.

There can also be a different scenario, where the number of clauses is
odd, like

#+begin_example lisp
(if cond1 pred1 cond2 pred2 altern)
#+end_example

If, during evaluation, =cond2= did not yield a non-=nil= result, then
=pred2= would be skipped; however, as there are no more pairs, but only
the a single =altern= clause, it will be evaluated and its results will
be returned, as an alternative.

#+begin_src C
Bel*
bel_special_if(Bel *exp, Bel *lenv)
{
    Bel *body       = bel_cdr(exp);
    uint64_t length = bel_length(body);

    if(length < 2) {
        return bel_mkerror(
            bel_mkstring("if statement must have at "
                         "least one predicate with "
                         "a consequent."),
            bel_g_nil);
    }

    Bel *predicate;
    Bel *consequent;
            
    while(1) {
        predicate  = bel_car(body);
        consequent = bel_car(bel_cdr(body));
        body = bel_cdr(bel_cdr(body));

        // nil consequent = return-eval predicate
        if(bel_nilp(consequent)) {
            return bel_eval(predicate, lenv);
        }

        if(!bel_nilp(bel_eval(predicate, lenv))) {
            return bel_eval(consequent, lenv);
        }
    }
            
    return bel_g_nil;
}
#+end_src

**** =(dyn v x y)=

The special form =dyn= evaluates =x= and /dynamically/ binds it to symbol
=v=. After this dynamic binding, it then evaluates =y=, and finally
unbinds =x=.

This implementation of =dyn= is not thread-happy yet, since every thread
is supposed to have its dynamic bindings, which are not shared. This,
however, is something that will be solved later.

# TODO: Make dynamic bindings thread-happy.

#+begin_src C
Bel*
bel_special_dyn(Bel *rest, Bel *lenv)
{
    uint64_t len = bel_length(rest);

    if(len > 3) {
        return bel_mkerror(
            bel_mkstring("Too many arguments on "
                         "dynamic binding."),
            bel_g_nil);
    }
    
    Bel *sym = bel_car(rest);
    Bel *x   = bel_car(bel_cdr(rest));
    Bel *y   = bel_car(bel_cdr(bel_cdr(rest)));

    if(!bel_symbolp(sym)) {
        return bel_mkerror(
            bel_mkstring("Dynamic bindings can only "
                         "be attributed to symbols."),
            bel_g_nil);
    }

    if(bel_nilp(sym)) {
        return bel_mkerror(
            bel_mkstring("Cannot bind value to nil."),
            bel_g_nil);
    }

/* #ifdef BEL_DEBUG */
/*     printf("dynb>  "); */
/*     bel_print(sym); */
/*     printf(" := "); */
/*     bel_print(x); */
/*     putchar(10); */
/* #endif */
    
    bel_g_dynae =
        bel_env_push(bel_g_dynae,
                     sym,
                     bel_eval(x, lenv));

    Bel *ret = bel_eval(y, lenv);
    bel_env_unbind(&bel_g_dynae, sym);
    
    return ret;
}
#+end_src

**** =(set . rest)=

This form works with pairs in an expression like =(set s1 v1 s2
v2...)= in such a way that =vn= is evaluated and globally bound to =sn=.

This is the form behind definitions of functions, for example.

For the global assignments to happen properly, we evaluate all
expressions before binding. This does not prevent side effects on the
evaluation of values being assigned, but the values will only be
assigned if no evaluation error happened. Plus, assignment can only be
done to non =nil= symbols.

#+begin_src C
Bel*
bel_special_set(Bel *clauses, Bel *lenv)
{
    Bel *syms = bel_g_nil;
    Bel *vals = bel_g_nil;

    Bel *itr = clauses;
    while(!bel_nilp(itr)) {
        Bel *sym = bel_car(itr);

        if(!bel_symbolp(sym) || bel_nilp(sym)) {
            return bel_mkerror(
                bel_mkstring("Global bindings can only "
                             "be attributed to valid "
                             "symbols."),
                bel_g_nil);
        }
        
        Bel *val =
            bel_eval(bel_car(bel_cdr(itr)),
                     lenv);

        if(bel_errorp(val)) {
            return val;
        }
        
        syms = bel_mkpair(sym, syms);
        vals = bel_mkpair(val, vals);
        
        itr = bel_cdr(bel_cdr(itr));
    }

    while(!bel_nilp(syms)) {
/* #ifdef BEL_DEBUG */
/*         printf("glob>  "); */
/*         bel_print(bel_car(syms)); */
/*         printf(" := "); */
/*         bel_print(bel_car(vals)); */
/*         putchar(10); */
/* #endif */
        bel_assign(bel_g_nil, bel_car(syms), bel_car(vals));
        syms = bel_cdr(syms);
        vals = bel_cdr(vals);
    }

    return bel_g_nil;
}
#+end_src

*** Evaluate a list of values

=bel_evlist= evaluates a list of expressions under the given lexical
environment. This function should only be called for a proper list.

#+begin_src C
Bel*
bel_evlist(Bel *elist, Bel *lenv)
{
    if(bel_nilp(elist)) {
        return bel_g_nil;
    }

    Bel *eval_result =
        bel_eval(bel_car(elist), lenv);

    if(bel_errorp(eval_result)) {
        return eval_result;
    }

    Bel *ev_rest =
        bel_evlist(bel_cdr(elist), lenv);

    if(bel_errorp(ev_rest)) {
        return ev_rest;
    }

    return bel_mkpair(eval_result, ev_rest);
}
#+end_src

*** Apply a primitive operator to a list

Applying a primitive to a list involves checking for the symbol which
specifies it and dispatching the arguments to a specific function
which checks arity and performs the job.

**** Forward declarations

These forward declarations are related to the actual implementation of
primitive functions in the Bel environment. We forward-declare them so
that we can define a function which redirects to each one of them, and
after that we give their proper definitions.

#+begin_src C
/* Forward declarations of primitive functions */
Bel *bel_prim_id(Bel *args);
Bel *bel_prim_join(Bel *args);
Bel *bel_prim_car(Bel *args);
Bel *bel_prim_cdr(Bel *args);
Bel *bel_prim_type(Bel *args);
Bel *bel_prim_xar(Bel *args);
Bel *bel_prim_xdr(Bel *args);
Bel *bel_prim_sym(Bel *args);
Bel *bel_prim_nom(Bel *args);
Bel *bel_prim_wrb(Bel *args);
Bel *bel_prim_rdb(Bel *args);
Bel *bel_prim_ops(Bel *args);
Bel *bel_prim_cls(Bel *args);
Bel *bel_prim_stat(Bel *args);
Bel *bel_prim_coin(Bel *args);
Bel *bel_prim_sys(Bel *args);

/* Forward declarations of primitive operators */
Bel *bel_prim_add(Bel *args);
Bel *bel_prim_sub(Bel *args);
Bel *bel_prim_mul(Bel *args);
Bel *bel_prim_div(Bel *args);
//Bel *bel_prim_less(Bel *args);
//Bel *bel_prim_leq(Bel *args);
//Bel *bel_prim_great(Bel *args);
//Bel *bel_prim_geq(Bel *args);
//Bel *bel_prim_eq(Bel *args);

/* Forward declarations of other primitives */
Bel *bel_prim_err(Bel *args);
Bel *bel_prim_gc(Bel *args);
#+end_src

**** Applying primitive operations

The =bel_apply_primop= function is the function which applies a
primitive operation, identified as a symbol, to a list of evaluated
values. It is important to know that this function does not usually do
the job; instead, we just dispatch the arguments to a function which
will perform as needed.

The macro =bel_is_prim= compares whether =sym= is the symbol which
represents the literal =lit=.

#+begin_src C
#define bel_is_prim(sym, lit)                     \
    (bel_idp(sym, bel_mksymbol(lit)))
#+end_src

The macro =bel_unimplemented= takes the symbol =sym= for a primitive
function and generates an error, stating that the function has not
been implemented. This is important while the interpreter is under
development.

#+begin_src C
#define bel_unimplemented(sym)                    \
    bel_mkerror(                                  \
    bel_mkstring("~a is not implemented."),       \
    bel_mkpair(sym, bel_g_nil))
#+end_src

=bel_apply_primop= is the crucial function for the operations described
above. It enumerates the core functions and dispatches the arguments
accordingly.

Notice that an attempt to apply a primitive operation which does not
exist results in error.

#+begin_src C
Bel*
bel_apply_primop(Bel *sym, Bel *args)
{
    // Primitive functions
    if(bel_is_prim(sym, "id"))
        return bel_prim_id(args);
    else if(bel_is_prim(sym, "join"))
        return bel_prim_join(args);
    else if(bel_is_prim(sym, "car"))
        return bel_prim_car(args);
    else if(bel_is_prim(sym, "cdr"))
        return bel_prim_cdr(args);
    else if(bel_is_prim(sym, "type"))
        return bel_prim_type(args);
    else if(bel_is_prim(sym, "xar"))
        return bel_prim_xar(args);
    else if(bel_is_prim(sym, "xdr"))
        return bel_prim_xdr(args);
    else if(bel_is_prim(sym, "sym"))
        return bel_prim_sym(args);
    else if(bel_is_prim(sym, "nom"))
        return bel_prim_nom(args);
    else if(bel_is_prim(sym, "wrb"))
        return bel_prim_wrb(args);
    else if(bel_is_prim(sym, "rdb"))
        return bel_prim_rdb(args);
    else if(bel_is_prim(sym, "ops"))
        return bel_prim_ops(args);
    else if(bel_is_prim(sym, "cls"))
        return bel_prim_cls(args);
    else if(bel_is_prim(sym, "stat"))
        return bel_prim_stat(args);
    else if(bel_is_prim(sym, "coin"))
        return bel_prim_coin(args);
    else if(bel_is_prim(sym, "sys"))
        return bel_prim_sys(args);

    // Primitive operators
    else if(bel_is_prim(sym, "+"))
        return bel_prim_add(args);
    else if(bel_is_prim(sym, "-"))
        return bel_prim_sub(args);
    else if(bel_is_prim(sym, "*"))
        return bel_prim_mul(args);
    else if(bel_is_prim(sym, "/"))
        return bel_prim_div(args);
    else if(bel_is_prim(sym, "<"))
        return bel_unimplemented(sym);
    else if(bel_is_prim(sym, "<="))
        return bel_unimplemented(sym);
    else if(bel_is_prim(sym, ">"))
        return bel_unimplemented(sym);
    else if(bel_is_prim(sym, ">="))
        return bel_unimplemented(sym);
    else if(bel_is_prim(sym, "="))
        return bel_unimplemented(sym);
    
    // Other primitives
    else if(bel_is_prim(sym, "err"))
        return bel_prim_err(args);
    else if(bel_is_prim(sym, "gc"))
        return bel_prim_gc(args);

    // Otherwise, unknown application operation
    else {
        return bel_mkerror(
            bel_mkstring("Unknown primitive ~a."),
            bel_mkpair(sym, bel_g_nil));
    }
}
#+end_src

**** Maximum arity check

The following macro is a helper for checking the arity of a specific
function. Passing the arguments list and the number of desired
arguments performs such a check. If the arity is greater than the
given number, it returns an error complaining about it.

Notice that this macro expects two things: to be called inside a
function that returns a =Bel*= type, and that the arguments themselves
are a /proper list/.

It is also important to notice that Bel specifies that, when handling
primitives, missing arguments default to =nil=, therefore passing less
arguments than expected is not considered an error; since collecting
arguments is handled by =bel_car= and =bel_cdr=, the missing arguments are
guaranteed to be =nil= when retrieval is attempted.

#+begin_src C
#define BEL_CHECK_MAX_ARITY(args, num)                  \
    {                                                   \
    uint64_t length = bel_length(args);                 \
    if(length > num) {                                  \
    return bel_mkerror(                                 \
        bel_mkstring("Arity error"), bel_g_nil);        \
    }                                                   \
    }
#+end_src

**** Primitive functions

The next functions implement primitive functions for the environment.

***** =(id x y)=

=id= checks whether =x= and =y= are identical. This is stricter than
equality, since identity can only be tested for things that are always
the same -- namely, characters and symbols.

#+begin_src C
Bel*
bel_prim_id(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    return (bel_idp(bel_car(args),
                    bel_car(bel_cdr(args)))
            ? bel_g_t : bel_g_nil);
}
#+end_src

***** =(join x y)=

=join= creates a pair with =x= as its /car/ and =y= as its /cdr/.

#+begin_src C
Bel*
bel_prim_join(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    return bel_mkpair(bel_car(args),
                      bel_car(bel_cdr(args)));
}
#+end_src

***** =(car x)= and =(cdr x)=

=car= returns the first element of a pair =x=.

#+begin_src C
Bel*
bel_prim_car(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    return bel_car(bel_car(args));
}
#+end_src

=cdr= returns the second element of a pair =x=.

#+begin_src C
Bel*
bel_prim_cdr(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    return bel_cdr(bel_car(args));
}
#+end_src

***** =(type x)=

=type= returns a symbol which specifies the type of =x=. The returning
values can be =symbol=, =pair=, =char=, =stream= or =number=.

#+begin_src C
Bel*
bel_prim_type(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    switch(bel_car(args)->type) {
    case BEL_SYMBOL:
        return bel_mksymbol("symbol");
        break;
    case BEL_PAIR:
        return bel_mksymbol("pair");
        break;
    case BEL_CHAR:
        return bel_mksymbol("char");
        break;
    case BEL_STREAM:
        return bel_mksymbol("stream");
        break;
    case BEL_NUMBER:
        return bel_mksymbol("number");
        break;
    default:
        return bel_mksymbol("unknown");
        break;
    };
}
#+end_src

***** =(xar x y)= and =(xdr x y)=

=xar= replaces the /car/ of a pair =x= with the given value =y=.

#+begin_src C
Bel*
bel_prim_xar(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    Bel *pair = bel_car(args);
    Bel *val  = bel_car(bel_cdr(args));
    if(!bel_pairp(pair)) {
        return bel_mkerror(
            bel_mkstring("~a is not a pair."),
            bel_mkpair(pair, bel_g_nil));
    }

    pair->pair->car = val;
    return val;
}
#+end_src

=xdr= replaces the /cdr/ of a pair =x= with the given value =y=.

#+begin_src C
Bel*
bel_prim_xdr(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    Bel *pair = bel_car(args);
    Bel *val  = bel_car(bel_cdr(args));
    if(!bel_pairp(pair)) {
        return bel_mkerror(
            bel_mkstring("~a is not a pair."),
            bel_mkpair(pair, bel_g_nil));
    }

    pair->pair->cdr = val;
    return val;
}
#+end_src

***** =(sym x)= and =(nom x)=

=sym= takes a Bel string and converts it into a symbol.

#+begin_src C
Bel*
bel_prim_sym(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *str = bel_car(args);
    if(!bel_stringp(str)) {
        return bel_mkerror(
            bel_mkstring("The object ~a must be a string."),
            bel_mkpair(str, bel_g_nil));
    }

    char *cstr = bel_cstring(str);
    if(!cstr || !strcmp(cstr, "")) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a proper string."),
            bel_mkpair(str, bel_g_nil));
    }

    return bel_mksymbol(cstr);
}
#+end_src

=nom= takes a symbol and discovers its name as a Bel string.

#+begin_src C
Bel*
bel_prim_nom(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *sym = bel_car(args);
    if(!bel_symbolp(sym)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a string."),
            bel_mkpair(sym, bel_g_nil));
    }

    return bel_mkstring(
        bel_sym_find_name(sym));
}
#+end_src

***** =(wrb x y)= and =(rdb x)=

=wrb= and =rdb= are functions responsible for input and output on a
stream.

=wrb= takes a bit =x= and a stream =y=, and writes that bit to the
stream. If the stream is =nil=, it writes instead to =outs=.

#+begin_src C
Bel*
bel_prim_wrb(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    Bel *x = bel_car(args);
    Bel *y = bel_car(bel_cdr(args));

    if(!bel_charp(x)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a character."),
            bel_mkpair(x, bel_g_nil));
    }

    if(bel_nilp(y)) {
        y = bel_lookup(bel_g_nil, bel_mksymbol("outs"));
    } else {
        if(!bel_streamp(y)) {
            return bel_mkerror(
                bel_mkstring("The object ~a must be "
                             "a stream."),
                bel_mkpair(y, bel_g_nil));
        }
    }

    return bel_stream_write_bit(&y->stream, y->chr);
}
#+end_src

=rdb= simply reads a bit from the stream =x=.

#+begin_src C
Bel*
bel_prim_rdb(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *x = bel_car(args);

    if(bel_nilp(x)) {
        bel_lookup(bel_g_nil, bel_mksymbol("ins"));
    } else {
        if(!bel_streamp(x)) {
            return bel_mkerror(
                bel_mkstring("The object ~a must be "
                             "a stream."),
                bel_mkpair(x, bel_g_nil));
        }
    }

    return bel_stream_read_bit(&x->stream);
}
#+end_src

***** =(ops x y)=, =(cls x)= and =(stat x)=

=ops=, =cls= and =stat= are functions related to the status of a stream.

=ops= opens a stream to the file =x=, depending on the direction specified
by symbol =y=, which can be either =in= or =out=.

#+begin_src C
Bel*
bel_prim_ops(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 2);
    Bel *x = bel_car(args);
    Bel *y = bel_car(bel_cdr(args));

    if(!bel_stringp(x)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a string."),
            bel_mkpair(x, bel_g_nil));
    }

    if(!bel_symbolp(y)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a symbol."),
            bel_mkpair(y, bel_g_nil));
    }

    if(bel_idp(y, bel_mksymbol("in"))) {
        return bel_mkstream(bel_cstring(x), BEL_STREAM_READ);
    } else if(bel_idp(y, bel_mksymbol("out"))) {
        return bel_mkstream(bel_cstring(x), BEL_STREAM_WRITE);
    }

    return bel_mkerror(
        bel_mkstring("The object ~a is not one of "
                     "the symbols `in` and `out`."),
        bel_mkpair(y, bel_g_nil));
}
#+end_src

=cls= closes a stream =x=, as long as it is open. If it was closed,
returns =t=; if it is already closed, returns =nil=.

#+begin_src C
Bel*
bel_prim_cls(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *stream = bel_car(args);

    if(!bel_streamp(stream)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a stream."),
            bel_mkpair(stream, bel_g_nil));
    }

    if(stream->stream.status == BEL_STREAM_CLOSED) {
        return bel_g_nil;
    }

    return bel_stream_close(stream);
}
#+end_src

=stat= takes a stream =x= and gives back symbols =closed=, =in= or =out=,
depending on stream status.

#+begin_src C
Bel*
bel_prim_stat(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);
    Bel *stream = bel_car(args);
    if(!bel_streamp(stream)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a stream."),
            bel_mkpair(stream, bel_g_nil));
    }

    switch(stream->stream.status) {
    case BEL_STREAM_CLOSED: return bel_mksymbol("closed");
    case BEL_STREAM_READ:   return bel_mksymbol("in");
    case BEL_STREAM_WRITE:  return bel_mksymbol("out");
    default: // ...wat
        return bel_mkerror(
            bel_mkstring("The stream ~a has an "
                         "unknown status."),
            bel_mkpair(stream, bel_g_nil));
    }
}
#+end_src

***** =(coin)=

=coin= returns symbols =t= and =nil= at random.

#+begin_src C
Bel*
bel_prim_coin(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 0);
    return (rand() % 2) ? bel_g_t : bel_g_nil;
}
#+end_src

***** =(sys x)=

=sys= takes a string =x= and sends it to the operational system, as a
console command, and returns the command's value as a proper Bel
number.

Number types are non-standard to the Bel language, however Bel does
not specify the return value of =sys=, therefore we have a degree of
freedom to specify that the return of =sys= is a number.

This function specifically is somewhat a matter of concern, because it
opens up for the execution of an arbitrary command on the operational
system.

#+begin_src C
Bel*
bel_prim_sys(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 1);

    Bel *str = bel_car(args);
    
    if(!bel_stringp(str)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not "
                         "a string."),
            bel_mkpair(str, bel_g_nil));
    }
    
    const char *com = bel_cstring(str);

    int64_t ret = system(com);

    return bel_mkinteger(ret);
}
#+end_src

**** Primitive operators

These primitive operations take an arbitrary number of arguments and
does the desired operation across the given values.

***** Addition

Adds all given values on the list, reducing them to a single
number. If not argument is given, returns =0=. If called with a single
argument, it returns that single argument (identity).

#+begin_src C
Bel*
bel_prim_add(Bel *args)
{
    if(!bel_number_list_p(args)) {
        return bel_mkerror(
            bel_mkstring("Cannot add a non-number."),
            bel_g_nil);
    }

    uint64_t length = bel_length(args);
    // No args: return 0
    if(length == 0) {
        return bel_mkinteger(0);
    }

    // One arg: identity
    if(length == 1) {
        return bel_car(args);
    }

    Bel *ret = bel_car(args);
    Bel *itr = bel_cdr(args);
    while(!bel_nilp(itr)) {
        ret = bel_num_add(ret, bel_car(itr));
        itr = bel_cdr(itr);
    }

    return ret;
}
#+end_src

***** Subtraction

Subtracts all given values on the list, reducing them to a single
number. If no argument is given, returns zero. If called with a
single argument, inverts that argument, multiplying it by =-1=.

#+begin_src C
Bel*
bel_prim_sub(Bel *args)
{
    if(!bel_number_list_p(args)) {
        return bel_mkerror(
            bel_mkstring("Cannot subtract a "
                         "non-number."),
            bel_g_nil);
    }

    uint64_t length = bel_length(args);
    // No args: return zero
    if(length == 0) {
        return bel_mkinteger(0);
    }

    // One arg: invert
    if(length == 1) {
        return bel_num_mul(bel_mkinteger(-1),
                           bel_car(args));
    }

    Bel *ret = bel_car(args);
    Bel *itr = bel_cdr(args);
    while(!bel_nilp(itr)) {
        ret = bel_num_sub(ret, bel_car(itr));
        itr = bel_cdr(itr);
    }

    return ret;
}
#+end_src

***** Multiplication

Multiplies all given values on the list, reducing them to a single
number. If no argument is given, returns =1=. If called with a single
argument, returns that single argument (identity).

# TODO: Maybe return signum, like APL?

#+begin_src C
Bel*
bel_prim_mul(Bel *args)
{
    if(!bel_number_list_p(args)) {
        return bel_mkerror(
            bel_mkstring("Cannot multiply a "
                         "non-number."),
            bel_g_nil);
    }

    uint64_t length = bel_length(args);
    // No args: return 1
    if(length == 0) {
        return bel_mkinteger(1);
    }

    // One arg: identity
    if(length == 1) {
        return bel_car(args);
    }

    Bel *ret = bel_car(args);
    Bel *itr = bel_cdr(args);
    while(!bel_nilp(itr)) {
        ret = bel_num_mul(ret, bel_car(itr));
        itr = bel_cdr(itr);
    }

    return ret;
}
#+end_src

***** Division

Divides all given arguments on the given list, reducing them to a
single number. If no argument is given, returns =1=. If called
with a single argument, returns the given number.

If any division yields an error (e.g. a division by zero), returns
that error immediately.

#+begin_src C
Bel*
bel_prim_div(Bel *args)
{
    if(!bel_number_list_p(args)) {
        return bel_mkerror(
            bel_mkstring("Cannot divide a "
                         "non-number."),
            bel_g_nil);
    }

    uint64_t length = bel_length(args);
    // No args: return 1
    if(length == 0) {
        return bel_mkinteger(1);
    }

    // One arg: return such number
    if(length == 1) {
        return bel_car(args);
    }

    Bel *ret = bel_car(args);
    Bel *itr = bel_cdr(args);
    while(!bel_nilp(itr)) {
        ret = bel_num_div(ret, bel_car(itr));

        // If there is a division by zero
        // or something, return immediately
        if(bel_errorp(ret)) {
            return ret;
        }
        
        itr = bel_cdr(itr);
    }

    return ret;
}
#+end_src

***** COMMENT Equality

***** COMMENT Comparison

**** Other primitives

These primitives are not specified in the Bel language, but are useful.

***** =(err x . rest)=

=err= creates an error using =x= as a format string, and appends the =rest=
to the error as format arguments.

There is no arity check in =err=, though we do verify whether the first
argument is a string. Problems with the arguments should appear when
printing the error.

#+begin_src C
Bel*
bel_prim_err(Bel *args)
{
    Bel *string = bel_car(args);
    if(!bel_stringp(string)) {
        return bel_mkerror(
            bel_mkstring("First argument of `err` "
                         "must be a string format."),
            bel_g_nil);
    }

    // TODO: Maybe quote?
    return bel_mkerror(string, bel_cdr(args));
}
#+end_src

***** =(gc)=

=gc=    forces    the    garbage   collector    to    perform    garbage
collection. Always returns =nil=.

#+begin_src C
Bel*
bel_prim_gc(Bel *args)
{
    BEL_CHECK_MAX_ARITY(args, 0);
    GC_gcollect();
    return bel_g_nil;
}
#+end_src

*** Bind a list of variables to values

=bel_bind= binds each variable to an associated value. If the binding
fails at any point, an error is returned; if not, a new environment
with the bindings is returned.

#+begin_src C
Bel*
bel_bind(Bel *vars, Bel *vals, Bel *lenv)
{
    int vars_ended = bel_nilp(vars);
    int vals_ended = bel_nilp(vals);

    if(vars_ended && !vals_ended) {
        return bel_mkerror(
            bel_mkstring("Too few variables in "
                         "function application"),
            bel_g_nil);
    } else if(!vars_ended && vals_ended) {
        return bel_mkerror(
            bel_mkstring("Too few values in "
                         "function application"),
            bel_g_nil);
    } else if(vars_ended && vals_ended) {
        return lenv;
    }

    Bel *binding = bel_mkpair(bel_car(vars),
                              bel_car(vals));

    return bel_bind(bel_cdr(vars),
                    bel_cdr(vals),
                    bel_mkpair(binding, lenv));
}
#+end_src

* Parser

Our next job is  to set up the parser. This section  of our program is
responsible for taking  a specific amount of text and  turning it into
an actual program structure.

For example, an expression such as...

#+begin_example
(set x (* 5 5))
#+end_example

...should have the same effect as the following block of C code:

#+begin_src C :tangle no
bel_mklist(3,
           bel_mksymbol("set"),
           bel_mksymbol("x"),
           bel_mklist(3,
                      bel_mkinteger(5),
                      bel_mkinteger(5)));
#+end_src

As it  is true to every  Lisp based on s-expressions,  the parentheses
determine a linked list of objects. It is a linked list, because it is
a linking of pairs. In a more concrete way, we may express a list such
as this:

#+begin_example
(set . (x . ((* . (5 . (5 . nil))) . nil)))
#+end_example

Since the  list is a concatenation  of pairs, this also  means that we
can construct  the whole  thing by recursion  and/or iteration  on the
usage of =bel_mkpair=, and leave  =bel_mklist= as an internal function for
when we want to write Bel lists from the C side of things. So the list
could also, in principle, be constructed by this block of code too:

#+begin_src C :tangle no
bel_mkpair(
    bel_mksymbol("set"),
    bel_mkpair(
        bel_mksymbol("x"),
        bel_mkpair(
            bel_mkpair(
                bel_mksymbol("*"),
                bel_mkpair(
                    bel_mkinteger(5),
                    bel_mkpair(
                        bel_mkinteger("5"),
                        bel_g_nil))),
            bel_g_nil)));
#+end_src

This is obviously very impractical, but it  gives us a hint at how our
parser should work. Every nested parentheses =()= indicates a pair whose
~car~ is also a pair; and for other elements, they should be interpreted
as other data objects.

** Tokenizer

The  first step  for parsing  an expression  is tokenization.  This is
where we will split our  string into proper tokens (substrings), which
will be stored as a proper Bel list of Bel strings.

This  step also  determines  how to  use /read  macros/,  which are  not
explicitly  supported  by  Bel   specification,  but  are  useful  for
introducing new, different syntax. For example, a quoted list such as

#+begin_example
'(1 2 3)
#+end_example

is, in fact, directly translated to

#+begin_example
(quote (1 2 3))
#+end_example

In Believe, this  makes it easier for us to  parse these tokens later,
because all  we'll have  to care about  is recursively  or iteratively
build  our lists  of  expressions, so  any  embellishment before  that
should be the a responsibility of the tokenization phase.

Believe has  some inspiration  on Lisp dialects  such as  Common Lisp,
therefore implementing the tokenizer as  a flexible stucture is a very
good thing to do.

Basically,  the  main  inspiration  here  is  on  Common  Lisp's  read
macros.  The idea  is  that  one can  reprogram  the  token reader  to
introduce custom syntax, not strictly bound to s-expressions.

The  best part  of having  read  macros is  that some  of the  reading
routines could be bootstrapped in Bel itself, so it opens the door for
introducing languages built on top of Bel.

*** Reserved symbols

# TODO: This functionality should be mixed with read macros.

Some characters  are very basic  to Lisp, so  we'll just go  ahead and
hardcode them. These symbols will automatically be excluded from token
reading.

The following static vector has its end signalled by the null character.

#+begin_src C
static const char _Bel_reserved_chars[] = {
    '(', ')', '"', '[', ']', 0
};
#+end_src

An internal  predicate will  help us  know if  a certain  character is
reserved.  It is  designed  to look  similar to  what  you'll find  at
~ctypes.h~.

#+begin_src C
int
isreserved(char c)
{
    size_t i = 0;
    while(_Bel_reserved_chars[i] != 0) {
        if(c == _Bel_reserved_chars[i])
            return 1;
        i++;
    }
    return 0;
}
#+end_src

*** Read macros

The read  macros themselves are  exclusively programmed by  using Bel,
and  they are  an  alist.  Each element  is  another  list with  three
elements at most.

#+begin_example
((\')
 (\# \nul read-special-number)
 (\" \"))
#+end_example

As of  now, read macros are  still not implemented in  Believe. In the
future, this  will be mixed with  the reserved symbols and  occupy the
same space, managed by a single read  table, which will be used by the
rest of the tokenizer.

# TODO: Program this.

#+begin_src C
int
isreadmacro(int c)
{
    // TODO!
    return 0;
}
#+end_src

*** Token sizes

Before we begin  the process of tokenization, it is  important that we
create a way to count the sizes  of tokens so that we can separate the
token into its own string.

The next function  does that until it meets a  reserved character or a
space character.

#+begin_src C
size_t
token_length(const char *buffer, size_t position)
{
    size_t i = position,
        size = 0;
    while(!isreserved(buffer[i]) &&
          !isspace(buffer[i]) &&
          (buffer[i] != '\0')) {
        size++;
        i++;
    }
    return size;
}
#+end_src

# TODO: token length for special cases
Let's  also  introduce a  function  for  calculating token  length  of
verbatim  text. This  is  useful  for text  which  should  be read  in
verbatim, such as strings, for example. There, we won't be looking for
spaces or reserved  symbols. We'll gobble up all  characters, until we
find a character which represents the  end of text (and that character
will be counted also).

However, if  a null character is  found, this means that  the text was
not properly finished. This  is an error, so we'll return  a size of ~0~
as a warning to the tokenizer.

#+begin_src C
size_t
token_verbatim_length(const char *buffer, size_t position, char end)
{
    size_t i = position,
        size = 0;
    while(buffer[i] != end) {
        if(buffer[i] == '\0')
            return 0;
        size++;
        i++;
    }
    return size + 1;
}
#+end_src

Finally, we  create a helper  function which  helps us copy  a certain
token into a proper Bel string.

#+begin_src C
Bel*
gen_tok_string(const char *buffer, size_t pos, size_t length)
{
    char *ns = GC_MALLOC_ATOMIC((length + 1) * sizeof(char));
    size_t i;
    for(i = 0; i < length; i++) {
        ns[i] = buffer[pos + i];
    }
    ns[length] = '\0';
    return bel_mkstring(ns);
}
#+end_src

*** Tokenization

Tokenization is  actually a simple  process. We  are going to  write a
procedure which creates a list and keeps appending Bel strings to it.

# TODO: Explain everything.

There seems to be quite a lot going on here, so here's an explanation,
step by step.

Basically,  this  is a  recursive  function  which  builds a  list  of
tokens. To make  the operation faster, we also keep  track of the last
pair added (whose ~car~  is the last added token, and  its ~cdr~ is always
~nil~). Therefore, to add  a new token, one must only  create a new pair
in these molds with the relevant  information, then replace the ~cdr~ of
~last~ by the  address of this new  pair.

This  is a  similar behavior  to ~xdr~,  but we'll  go ahead  and do  it
manually.

As for  the rest,  it is  just a case  study. Characters  are analyzed
until we reach end of buffer. We perform tests in these orders:

1. Test  if the character signals  a read macro. Nothing  is performed
   for now, since nothing falls into this case for now also.
2. Test if  the  character is  ~;~,  signalling a  comment.  If so,  it
   attempts to find the next line break. If the file ends with no line
   break,  it is  considered  an  error. The  buffer  pointer is  then
   repositioned after the line break.
3. Test if  the character is a double quote,  signalling the beginning
   of a  string literal. If  so, it attempts  to find the  next double
   quote, and encloses both double quotes  and the text inbetween to a
   new token. The buffer pointer is then repositioned after the second
   double quote.
4. Test if the character is  reserved. If so, generates a token string
   with  that  same  single  character. The  buffer  pointer  is  then
   repositioned on the next character.
5. Test  if the current character  is not white space,  indicating the
   beginning of  a new arbitrary  token. If so,  it tries to  find the
   next white space, then gobbles all  characters before it into a new
   token.  The  buffer pointer  is  then  repositioned at  said  white
   space.

# TODO: Break this function into smaller functions.
# TODO: Better error dispatching; use parser as parameter

#+begin_src C
Bel*
bel_tokenize(const char *buffer)
{
    Bel *tokens = bel_g_nil;
    Bel *last   = tokens;
    
    size_t i;
    for(i = 0; i < strlen(buffer); i++) {
        Bel *token = bel_g_nil;
        if(isreadmacro(buffer[i])) {
            // TODO
        } else if(buffer[i] == ';') {
            size_t length =
                token_verbatim_length(buffer, i, '\n');
            if(length == 0) {
                return bel_mkerror(
                    bel_mkstring("Unexpected EOF: "
                                 "Comments must end on "
                                 "line breaks"),
                    bel_g_nil);
            }
            i += length;
        } else if(buffer[i] == '"') {
            size_t length =
                token_verbatim_length(buffer, i + 1, '"');
            if(length == 0) {
                return bel_mkerror(
                    bel_mkstring("Unbalanced double quote"),
                    bel_g_nil);
            }
            token = gen_tok_string(buffer, i, length + 1);
            i += length;
        } else if(isreserved(buffer[i])) {
            token = gen_tok_string(buffer, i, 1);
        } else if(!isspace(buffer[i])) {
            size_t length = token_length(buffer, i);
            token = gen_tok_string(buffer, i, length);
            i += length - 1;
        } else {}

        if(!bel_nilp(token)) {
            if(bel_nilp(tokens)) {
                tokens = bel_mkpair(token, bel_g_nil);
                last   = tokens;
            } else {
                last->pair->cdr = bel_mkpair(token, bel_g_nil);
                last = bel_cdr(last);
            }
        }
    }
    return tokens;
}
#+end_src

** Parsing

Now we  are going  to work in  the parser itself.  Since the  input is
already tokenized, all  we need to do is traverse  the list of tokens,
and build the list structure of our program.

For an expression such as

#+begin_example
(set x (* 5 5))
#+end_example

we expect to have a proper Bel list of strings, which would be printed
on console this way:

#+begin_example
("(" "set" "x" "(" "*" "5" "5" ")" ")")
#+end_example

Every time we find an open parenthesis token ~"("~, it indicates that we
need to create  a new list, which increases the  depth of our parser's
recursion,  since  it   will  be  mainly  comprised   of  a  recursive
function. The  close parenthesis ~")"~  indicates that we need  to close
the previous list, unless we are at recursion depth ~0~.

So this is  basically a matter of recognizing the  types of tokens and
controlling the  depth of recursion.  We may  also find some  kinds of
syntax errors here.

*** Forward declarations

Let's  begin  by declaring  a  few  prototypes for  important  parsing
functions. This time we'll be looking deeper into the tokens we split.

#+begin_src C
Bel *bel_parse_expr(Bel*, uint64_t);
Bel *bel_parse_token(Bel*);
Bel *bel_parse_int(const char*);
Bel *bel_parse_float(const char*);
Bel *bel_parse_frac(const char*);       // implement
Bel *bel_parse_char(const char*);       // implement
Bel *bel_parse_string(const char*);
#+end_src

We also need to declare prototypes for a few predicates, which are for
the C  part of the  program. These will help  us turn the  tokens into
proper symbols of their types.

#+begin_src C
int isstrint(const char*);
int isstrfloat(const char*);
int isstrfrac(const char*);    // implement
int isstrcomplex(const char*); // implement
int isstrchar(const char*);    // implement
int isstrstr(const char*);
#+end_src

*** Token list parser

Here, we  are going to  break a list of  tokens into proper  lists. At
this  point,   everything  should   already  be  broken   into  proper
s-expressions.

Parsing a token list is also a  case analysis, much like we did on the
tokenization phase.  But this one is  rather simple: we will  take our
string  objects,  convert   them  to  C  strings,   then  compare  for
parenthesis to perform recursion depth control.

When we  find an  open parenthesis,  we recurse  on the  function. The
expected  result for  ~depth >  0~  is a  pair comprised  of the  parsed
sublist of Bel  symbols, and the yet-to-be-parsed rest of  the list of
tokens.

When we  find a  close parenthesis,  either we build  a pair  with the
current expression and the rest of  tokens, or we generate an error if
we're working on depth ~0~.

As for  all the other tokens,  the token parsing job  is dispatched to
~bel_parse_token~, and the subexpression is  appended to the results. If
the subexpression is an error, though, we return it immediately.

# TODO: How  are we identifying  errors here?  What happens if  we are
# building an error literal by hand?

#+begin_src C
Bel*
bel_parse_expr(Bel *tokens, uint64_t depth)
{
    Bel *expr = bel_g_nil;
    Bel *last = bel_g_nil;
    while(!bel_nilp(tokens)) {
        Bel *car           = bel_car(tokens);
        tokens             = bel_cdr(tokens);
        Bel *subexpr       = bel_g_nil;
        const char *carstr = bel_cstring(car);

        if(!strcmp(carstr, ")")) {
            if(depth == 0) {
                return bel_mkerror(
                    bel_mkstring("Unbalanced parentheses"),
                    bel_g_nil);
            } else {
                return bel_mkpair(expr, tokens);
            }
        } else if(!strcmp(carstr, "(")) {
            Bel *pair = bel_parse_expr(tokens, depth + 1);
            subexpr   = bel_car(pair);
            tokens    = bel_cdr(pair);
        } else {
            subexpr = bel_parse_token(car);
        }

        if(bel_errorp(subexpr)) {
            return subexpr; // Errors out
        }

        if(bel_nilp(expr)) {
            expr = bel_mkpair(subexpr, bel_g_nil);
            last = expr;
        } else {
            last->pair->cdr =
                bel_mkpair(subexpr, bel_g_nil);
            last = bel_cdr(last);
        }
    }
    return expr;
}
#+end_src

*** Token parser

Parsing tokens themselves  is a simple case analysis  too. Here, we're
taking the tokens as C  strings and performing direct text comparisons
on them.

Predicates such as  ~isstrnum~, ~isstrfloat~ and ~isstrstr~  help detect the
type of  information represented  by the token.  We then  dispatch the
text to functions  of format ~bel_parse_*~, which will  then convert the
token to a proper Bel object of the given kind.

#+begin_src C
Bel*
bel_parse_token(Bel *token)
{
    const char *str = bel_cstring(token);
    if(isstrint(str)) {
        return bel_parse_int(str);
    } else if(isstrfloat(str)) {
        return bel_parse_float(str);
    } else if(isstrstr(str)) {
        return bel_parse_string(str);
    }
    // TODO: Add more special cases
    return bel_mksymbol(str);
}
#+end_src

**** Parsing an integer

We  know that  a token  represents an  integer if  it is  comprised of
digits only. It may be preceeded by a minus sign too.

#+begin_src C
int
isstrint(const char *str)
{
    uint64_t i = 0;

    if(str[0] == '-') {
        i++;
    }

    while(str[i] != '\0') {
        if(!isdigit(str[i]))
            return 0;
        i++;
    }
    return 1;
}
#+end_src

If the  token represents a  proper integer, then  we convert it  to an
~int64_t~ by using ~strtoll~, then we create the proper Bel number.

#+begin_src C
Bel*
bel_parse_int(const char *token)
{
    return bel_mkinteger(strtoll(token, NULL, 10));
}
#+end_src

**** Parsing a float value

A floating point  may be syntactically preceeded by a  minus, and /must/
have a single dot anywhere.

#+begin_src C
int
isstrfloat(const char *str)
{
    uint64_t i = 0;
    int found_dot = 0;
    if(str[0] == '-') {
        i++;
    } else if(str[0] == '.') {
        found_dot = 1;
        i++;
    }

    while(str[i] != '\0') {
        if(str[i] == '.') {
            if(!found_dot) {
                found_dot = 1;
            } else {
                return 0;
            }
        } else if(!isdigit(str[i])) {
            return 0;
        }
        i++;
    }
    return found_dot;
}
#+end_src

If the token  is a proper Bel float,  we use ~strtod~ to turn  it into a
~double~ value of C language, then create the Bel object.

#+begin_src C
Bel*
bel_parse_float(const char *token)
{
    return bel_mkfloat(strtod(token, NULL));
}
#+end_src

**** COMMENT Parsing a special number

# TODO: Implement

***** Parsing fractions

***** Parsing complex numbers

**** COMMENT Parsing a character

# TODO: Implement

**** Parsing strings

Anything between  a pair  of ~"~ is  supposed to be  a string,  at least
initially. So what we need to do is check for that.

#+begin_src C
int
isstrstr(const char *token)
{
    return (token[0] == '"') &&
        (token[strlen(token) - 1] == '"');
}
#+end_src

Having done so, all  we need to do is create a  new C string, properly
trimming the  token of its  surrounding double quotes, then  perform a
proper conversion  into a Bel string.  Notice that the string  size is
calculated taking a null terminator into account.

#+begin_src C
Bel*
bel_parse_string(const char *token)
{
    size_t strsz = strlen(token);
    char *str = GC_MALLOC_ATOMIC((strsz - 1) * sizeof(char));
    size_t i;
    strsz--;
    for(i = 0; i < strsz; i++) {
        str[i] = token[i + 1];
    }
    str[strsz - 1] = '\0';
    return bel_mkstring(str);
}
#+end_src

* COMMENT Interpreter



* Debug

The following definitions are related to testing what we have so
far.

** Tests
*** String manipulation and printing

A string test which shows the conversion between C strings and Bel
strings, and vice-versa.

#+begin_src C
void
string_test()
{
    Bel *bel  = bel_mkstring("Hello, Bel!");
    bel_print(bel);
    printf(" => %s\n", bel_cstring(bel));

    bel = bel_mkstring("There is no Bel without \a");
    bel_print(bel);
    putchar(10);
}
#+end_src

*** List/pair/dotted list notation

The following notation tests the printing capabilities of the list
printing algorithm. Should be able to handle printing lists and
dot-notation when necessary.

The data input reads as =((foo . bar) . (baz . quux))=, but the expected
output is =((foo . bar) baz . quux)=.

#+begin_src C
void
notation_test()
{
    Bel*
    bel = bel_mkpair(bel_mkpair(bel_mksymbol("foo"),
                                bel_mksymbol("bar")),
                     bel_mkpair(bel_mksymbol("baz"),
                                bel_mksymbol("quux")));
    bel_print(bel);
    putchar(10);
}
#+end_src

*** Proper list notation

This next test outputs the list =(The quick brown fox jumps over the
lazy dog)=, which is a proper list of symbols.

#+begin_src C
void
list_test()
{
    Bel*
    bel =
        bel_mklist(9,
                   bel_mksymbol("The"),
                   bel_mksymbol("quick"),
                   bel_mksymbol("brown"),
                   bel_mksymbol("fox"),
                   bel_mksymbol("jumps"),
                   bel_mksymbol("over"),
                   bel_mksymbol("the"),
                   bel_mksymbol("lazy"),
                   bel_mksymbol("dog"));
    bel_print(bel);
    putchar(10);
}
#+end_src

*** Closure representation

This test is also a list of symbols, but with nested lists also. Plus,
this is a proper list, representing the internal representation of a
closure such as =(fn (x) (* x x))=, but in its expected output form,
which is =(lit clo nil (x) (* x x))=. Plus, we try to represent another
closure in its original syntax as =(fn (x) (+ 1 x))=.

We also take the oportunity to test =bel_mklist= by creating a proper
closure not in its literal form.

#+begin_src C
void
closure_repr_test()
{
    // (lit clo nil (x) (* x x))
    Bel*
    bel = bel_mklist(5,
                     bel_mksymbol("lit"),
                     bel_mksymbol("clo"),
                     bel_g_nil,
                     bel_mklist(1,
                                bel_mksymbol("x")),
                     bel_mklist(3,
                                bel_mksymbol("*"),
                                bel_mksymbol("x"),
                                bel_mksymbol("x")));
    bel_print(bel);
    putchar(10);

    // (fn (x) (+ 1 x))
    bel =
        bel_mklist(3, bel_mksymbol("fn"),
                   bel_mklist(1, bel_mksymbol("x")),
                   bel_mklist(3, bel_mksymbol("+"),
                              bel_mkinteger(1),
                              bel_mksymbol("x")));
    bel_print(bel);
    putchar(10);     
}
#+end_src

*** Character list printing and environment lookup

This next test prints the first ten characters in the global =chars=,
which is a list of pairs, each pair =(c . d)= containing a character =c=,
and its string representation in binary =d=.

It is also interesting to notice that the =chars= global is obtained by
a lookup operation on the environment, rather than using the global
variable directly.

#+begin_src C
void
character_list_test()
{
    // Character list
    // Char: 000 (?) => "00000000"
    // Char: 001 (?) => "00000001"
    // etc
    const int first_char = 'a';
    
    Bel *bel = bel_env_lookup(bel_g_globe, bel_mksymbol("chars"));
    
    int i;

    // Get nth cdr
    for(i = 0; i < first_char; i++) {
        bel = bel_cdr(bel);
    }

    i = 'a';
    while(!bel_nilp(bel) && i < first_char + 10) {
        Bel *car = bel_car(bel);
        printf("Char: %03d (%c) => ",
               bel_car(car)->chr,
               ((Bel_char)i));
        bel_print(bel_cdr(car));
        putchar(10);
        bel = bel_cdr(bel);
        i++;
    }
}
#+end_src

*** Read file bit by bit

This test opens up the Believe C source code file as a read stream,
using Bel's stream structure, then proceeds to read ten bytes from it
(meaning that it will read 80 bits). Every eight bit will be stored in
a Bel list and then converted to a proper Bel character, which will be
displayed on screen along with its bits.

It is interesting to notice that, since the bit-reading operation
itself returns characters =\0= or =\1=, the bit list composing a character
is always a Bel string.

#+begin_src C
void
read_file_test()
{
    // We are going to read ten bytes from Bel's
    // own source code file.
    Bel *file = bel_mkstream("believe.c", BEL_STREAM_READ);

    if(bel_errorp(file)) {
        bel_print(file);
        return;
    }

    printf("Stream: ");
    bel_print(file);
    putchar(10);
    
    int n_bytes = 10;
    while(n_bytes > 0) {
        // 1 byte = 8 bits, so we make a list of
        // eight characters
        Bel **char_nodes = GC_MALLOC(8 * sizeof(Bel*));

        int i;
        for(i = 0; i < 8; i++) {
            Bel *read_char =
                bel_stream_read_bit(&file->stream);
            char_nodes[i] = bel_mkpair(read_char, bel_g_nil);
        }

        // Link nodes
        for(i = 0; i < 7; i++) {
            char_nodes[i]->pair->cdr = char_nodes[i + 1];
        }

        // Display on screen
        bel_print(char_nodes[0]);
        printf(" => ");
        bel_print(
            bel_char_from_binary(char_nodes[0]));
        putchar(10);
        
        n_bytes--;
    }

    bel_stream_close(file);
}
#+end_src

*** Display errors

We generate a few errors and grab them, then we print these errors on
screen to show their literal structure.

#+begin_src C
void
show_errors_test()
{
    Bel *err;
    
    // Unexisting file
    err = bel_mkstream("waddawaddawadda", BEL_STREAM_READ);
    bel_print(err);
    putchar(10);
    printf("Is this an error? %c\n",
           bel_errorp(err) ? 'y' : 'n');

    // Incorrect use of car and cdr
    err = bel_car(bel_g_t);
    bel_print(err); putchar(10);
    err = bel_cdr(bel_g_t);
    bel_print(err); putchar(10);

    // Incorrect generation of Bel character from binary
    /* Bel *str = bel_mkstring("110"); */
    /* err = bel_char_from_binary(str); */
    /* bel_print(err); putchar(10); */

    /* str = bel_mkstring("110a1101"); */
    /* err = bel_char_from_binary(str); */
    /* bel_print(err); putchar(10); */
}
#+end_src

*** Lookup primitives

We look up a few registered primitives in the global environment, and
print them in their literal form.

#+begin_src C
void
lookup_primitives_test()
{
    Bel *bel;
    bel = bel_lookup(bel_g_nil, bel_mksymbol("car"));
    bel_print(bel);
    putchar(10);

    bel = bel_lookup(bel_g_nil, bel_mksymbol("cdr"));
    bel_print(bel);
    putchar(10);

    bel = bel_lookup(bel_g_nil, bel_mksymbol("coin"));
    bel_print(bel);
    putchar(10);
    
    bel = bel_lookup(bel_g_nil, bel_mksymbol("stat"));
    bel_print(bel);
    putchar(10);

    // Undefined primitive
    bel_print(bel_g_nil); putchar(10);
    bel = bel_lookup(bel_g_nil, bel_mksymbol("wadawada"));
    bel_print(bel);
    putchar(10);
}
#+end_src

*** Environment tests

The first test involves creating a temporary lexical environment,
pushing a few literals, assigning values, unbinding values too.

#+begin_src C
void
lexical_environment_test()
{
    Bel *lexenv = bel_g_nil;
    Bel *ret;

    puts("    -- Registering local `foo`");
    lexenv = bel_env_push(lexenv,
                          bel_mksymbol("foo"),
                          bel_mksymbol("bar"));
    
    printf("Environment:       ");
    bel_print(lexenv);
    printf("\nLookup:            ");
    bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    putchar(10); putchar(10);

    // Assignment
    puts("    -- Assigning new value to `foo`");
    ret =
        bel_assign(
            lexenv,
            bel_mksymbol("foo"),
            bel_mkliteral(
                bel_mkpair(bel_mksymbol("baz"),
                           bel_g_nil)));

    printf("Environment:       ");
    bel_print(lexenv);
    printf("\nAssignment result: ");
    bel_print(ret);
    printf("\nLookup:            ");
    bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    putchar(10); putchar(10);

    // Unbinding
    puts("    -- Unbinding `foo`");
    ret = bel_unbind(&lexenv, bel_mksymbol("foo"));
    
    printf("Environment:       ");
    bel_print(lexenv);
    printf("\nUnbinding result:  ");
    bel_print(ret);
    printf("\nLookup:            ");
    bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    putchar(10);
}
#+end_src

Second test is creating a global variable through assignment, creating
a variable bound to the same symbol on a lexical environment,
unbinding both, then performing a last invalid unbinding.

#+begin_src C
void
global_assignment_test()
{
    Bel *lexenv = bel_g_nil;
    Bel *ret;

    // Global creation through assignment
    puts("    -- Assigning `foo` without previous definition");
    ret = bel_assign(bel_g_nil,
                     bel_mksymbol("foo"),
                     bel_mksymbol("bar"));

    printf("Assignment result: ");
    bel_print(ret);
    printf("\nLookup:            ");
    bel_print(bel_lookup(bel_g_nil, bel_mksymbol("foo")));
    putchar(10); putchar(10);

    // Local creation of variable bound to
    // same symbol
    puts("    -- Shadowing global `foo` with a local");
    lexenv =
        bel_env_push(lexenv,
                     bel_mksymbol("foo"),
                     bel_mksymbol("quux"));

    printf("Environment:       ");
    bel_print(lexenv);
    printf("\nLookup:            ");
    bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));

    // Three unbindings
    printf("\n    -- Unbinding `foo` three times");
    int i;
    for(i = 0; i < 3; i++) {
        ret = bel_unbind(&lexenv, bel_mksymbol("foo"));

        printf("\n\n      After unbinding.");
        printf("\nEnvironment:       ");
        bel_print(lexenv);
        printf("\nUnbinding result:  ");
        bel_print(ret);
        printf("\nLookup:            ");
        bel_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    }
    putchar(10);
}
#+end_src

*** Number test

This test performs raw arithmetic on the four subtypes of numbers:
integers, floats, complexes and fractions.

#+begin_src C
void
number_test()
{
    Bel *a;
    Bel *b;

    // Integer sum
    a = bel_mkinteger(4);
    b = bel_mkinteger(2);

    bel_print(a);
    printf(" + ");
    bel_print(b);
    printf(" = ");
    bel_print(bel_num_add(a, b));
    putchar(10);

    
    // Float subtraction
    a = bel_mkfloat(4.0);
    b = bel_mkfloat(3.5);

    bel_print(a);
    printf(" - ");
    bel_print(b);
    printf(" = ");
    bel_print(bel_num_sub(a, b));
    putchar(10);


    // Fraction sum
    a = bel_mkfraction(bel_mkinteger(1),
                       bel_mkinteger(3));
    b = bel_mkfraction(bel_mkinteger(1),
                       bel_mkinteger(6));

    bel_print(a);
    printf(" + ");
    bel_print(b);
    printf(" = ");
    bel_print(bel_num_add(a, b));
    putchar(10);

    
    // Complex multiplication
    a = bel_mkcomplex(bel_mkinteger(3),
                      bel_mkinteger(2));
    b = bel_mkcomplex(bel_mkinteger(1),
                      bel_mkinteger(4));

    bel_print(a);
    printf(" * ");
    bel_print(b);
    printf(" = ");
    bel_print(bel_num_mul(a, b));
    putchar(10);

    // Complex division
    // Reusing a and b from last example
    bel_print(a);
    printf(" / ");
    bel_print(b);
    printf(" = ");
    bel_print(bel_num_div(a, b));
    putchar(10);

    // Integer division (inexact)
    a = bel_mkinteger(7);
    b = bel_mkinteger(2);

    bel_print(a);
    printf(" / ");
    bel_print(b);
    printf(" = ");
    bel_print(bel_num_div(a, b));
    putchar(10);
}
#+end_src

*** Debriefing macro

This macro is a helper for debriefing results of evaluation tests.

#+begin_src C
#define BEL_EVAL_DEBRIEF(exp, res, env) \
    {                                   \
    printf("Expression: ");             \
    bel_print(exp); putchar(10);        \
    res = bel_eval(exp, env);           \
    printf("Result: ");                 \
    bel_print(res); putchar(10);        \
    putchar(10);                        \
    }
#+end_src

*** Evaluator test

This test performs the evaluation of a few forms so that we can check
if the evaluator runs properly.

# TODO: Too long! Replace this!

#+begin_src C
void
eval_test()
{
    Bel *form;
    Bel *result;

    // (quote foo)
    form = bel_mklist(2,
                      bel_mksymbol("quote"),
                      bel_mksymbol("foo"));
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);
    
    // (join (quote foo) (quote bar))
    form =
        bel_mklist(
            3,
            bel_mksymbol("join"),
            bel_mklist(
                2,
                bel_mksymbol("quote"),
                bel_mksymbol("foo")),
            bel_mklist(
                2,
                bel_mksymbol("quote"),
                bel_mksymbol("bar")));
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);


    // (fn (x) (id x x))
    form = bel_mklist(
        3,
        bel_mksymbol("fn"),
        bel_mklist(1, bel_mksymbol("x")),
        bel_mklist(
            3,
            bel_mksymbol("id"),
            bel_mksymbol("x"),
            bel_mksymbol("x")));
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);

    
    // ((fn (x) (id x x)) (quote foo))
    form = bel_mklist(
        2,
        form, // Use closure from last example
        bel_mklist(2,
                   bel_mksymbol("quote"),
                   bel_mksymbol("foo")));
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);

    
    // (if (id (quote bar) (quote foo)) (quote okay)
    //     (id (quote foo) (quote bar)) (quote okay)
    //                                  (quote nope))
    form =
        bel_mklist(
            6,
            bel_mksymbol("if"),
            // Clause 1
            bel_mklist(
                3,
                bel_mksymbol("id"),
                bel_mklist(
                    2,
                    bel_mksymbol("quote"),
                    bel_mksymbol("bar")),
                bel_mklist(
                    2,
                    bel_mksymbol("quote"),
                    bel_mksymbol("foo"))),
            bel_mklist(
                2,
                bel_mksymbol("quote"),
                bel_mksymbol("okay")),
            // Clause 2
            bel_mklist(
                3,
                bel_mksymbol("id"),
                bel_mklist(
                    2,
                    bel_mksymbol("quote"),
                    bel_mksymbol("foo")),
                bel_mklist(
                    2,
                    bel_mksymbol("quote"),
                    bel_mksymbol("bar"))),
            bel_mklist(
                2,
                bel_mksymbol("quote"),
                bel_mksymbol("okay")),
            // Alternative
            bel_mklist(
                2,
                bel_mksymbol("quote"),
                bel_mksymbol("nope")));
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);


    // (sys "echo Hello, world!")
    // NOTE: I am commenting out this test since
    //       this function could open some security
    //       holes in systems unadvertedly using it.
    /* form = bel_mklist( */
    /*     2, */
    /*     bel_mksymbol("sys"), */
    /*     bel_mkstring("echo Hello, world!")); */
    /* BEL_EVAL_DEBRIEF(form, result, bel_g_nil); */

    
    // Eval some axioms
    puts("Evaluating some axioms");
    form = bel_g_t;
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);
    
    form = bel_g_o;
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);

    form = bel_g_apply;
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);

    form = bel_g_nil;
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);

    
    // Eval some numbers
    form = bel_mkinteger(42);
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);

    form = bel_mkfloat(42.0);
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);

    form = bel_mkfraction(bel_mkinteger(2),
                          bel_mkinteger(3));
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);

    
    form = bel_mkcomplex(bel_mkfloat(2.0),
                         bel_mkfloat(3.4));
    BEL_EVAL_DEBRIEF(form, result, bel_g_nil);
}
#+end_src

*** Arithmetic evaluation test

This next test tests the evaluation of arithmetic on some numbers,
from calls to the evaluator itself.

#+begin_src C
void
arithmetic_eval_test()
{
    Bel *exp;
    Bel *result;

    // (+ 2 #(c 3+7i) #(f 1/3))
    exp = bel_mklist(
        4,
        bel_mksymbol("+"),
        bel_mkinteger(2),
        bel_mkcomplex(bel_mkinteger(3),
                      bel_mkinteger(7)),
        bel_mkfraction(bel_mkinteger(1),
                       bel_mkinteger(3)));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    // (id #(c 1+3i) #(c 1+3i))
    exp = bel_mklist(
        3,
        bel_mksymbol("id"),
        bel_mkcomplex(bel_mkinteger(1),
                      bel_mkinteger(3)),
        bel_mkcomplex(bel_mkinteger(1),
                      bel_mkinteger(3)));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    
    //(- #(c 3-8i))
    exp = bel_mklist(
        2,
        bel_mksymbol("-"),
        bel_mkcomplex(bel_mkinteger(3),
                      bel_mkinteger(8)));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    
    // (* 1 2 3 4 5)
    exp = bel_mklist(
        6,
        bel_mksymbol("*"),
        bel_mkinteger(1),
        bel_mkinteger(2),
        bel_mkinteger(3),
        bel_mkinteger(4),
        bel_mkinteger(5));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    // (/ 45.0)
    exp = bel_mklist(
        2,
        bel_mksymbol("/"),
        bel_mkfloat(45.0));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    
    // Spec conformity tests
    // (-) should return 0
    exp = bel_mklist(1, bel_mksymbol("-"));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    // (/) should return 1
    exp = bel_mklist(1, bel_mksymbol("/"));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    // (/ 5) should return 5
    exp = bel_mklist(
        2,
        bel_mksymbol("/"),
        bel_mkinteger(5));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);
}
#+end_src

*** Arity tests

The following tests check for the arity of primitive functions. By
default, a small number of arguments is not a bug, and the missing
arguments are traded for =nil=.

#+begin_src C
void
arity_test()
{
    Bel *exp;
    Bel *result;

    // (id) => t
    exp = bel_mklist(1, bel_mksymbol("id"));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    // (join) => (nil . nil)
    exp = bel_mklist(1, bel_mksymbol("join"));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    // (type) => symbol
    exp = bel_mklist(1, bel_mksymbol("type"));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);
}
#+end_src

*** Dynamic binding test

This test attempts to bind the result of the division between =1= and =2=
to a dynamic variable =x=, then proceeds to perform an operation with
it.

#+begin_src C
void
dynamic_binding_test()
{
    Bel *exp;
    Bel *result;

    // (dyn x (/ 1 2)
    //   (+ x 1))
    exp = bel_mklist(
        4,
        bel_mksymbol("dyn"),
        bel_mksymbol("x"),
        bel_mklist(
            3,
            bel_mksymbol("/"),
            bel_mkinteger(1),
            bel_mkinteger(2)),
        bel_mklist(
            3,
            bel_mksymbol("+"),
            bel_mksymbol("x"),
            bel_mkinteger(1)));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);
}
#+end_src

*** Global binding test

This test attributes a certain closure to the symbol =square= globally,
then proceeds to apply this new global function to some number.

#+begin_src C
void
global_binding_test()
{
    Bel *exp;
    Bel *result;

    // function definition
    // (fn (x) (* x x))
    exp =
        bel_mklist(
            3,
            bel_mksymbol("fn"),
            bel_mklist(1, bel_mksymbol("x")),
            bel_mklist(
                3,
                bel_mksymbol("*"),
                bel_mksymbol("x"),
                bel_mksymbol("x")));
    
    // assignment
    // (set square (fn (x) (* x x)))
    exp = bel_mklist(
        3,
        bel_mksymbol("set"),
        bel_mksymbol("square"),
        exp); // Reuse defined function
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    // Type check
    // (type square)
    exp = bel_mklist(
        2,
        bel_mksymbol("type"),
        bel_mksymbol("square"));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);
    
    // (square #(f 1/2))
    exp = bel_mklist(
        2,
        bel_mksymbol("square"),
        bel_mkfraction(bel_mkinteger(1),
                       bel_mkinteger(2)));
    BEL_EVAL_DEBRIEF(exp, result, bel_g_nil);

    // TODO: Unintern symbol?
}
#+end_src

*** Basic tokenizer test

This tests the tokenize. Basically, it will take any string expression
and attempt  to generate a  list of Bel  strings, each string  being a
token.

We begin by declaring a helper macro to reduce code repetition.

#+begin_src C
#define BEL_TOKENIZE_DEBRIEF(exp, res, str)             \
    {                                                   \
        exp = str;                                      \
        res = bel_tokenize(exp);                        \
        printf("Expression:\n%s\nResult: ", exp);       \
        bel_print(res);                                 \
        putchar(10);                                    \
    }
#+end_src

Now  we write  the  test.  This takes  the  exp  variable, the  result
variable,  and  a  potentially  multiline   string.  Each  case  is  a
tokenization test.

#+begin_src C
void
basic_tokenizer_test()
{
    const char *exp;
    Bel *result = bel_g_nil;

    BEL_TOKENIZE_DEBRIEF(exp, result, "(+ 1 2)");

    BEL_TOKENIZE_DEBRIEF(
        exp, result,
        "(progn (+ 1 2)\n"
        "       (+ 3 4))");

    BEL_TOKENIZE_DEBRIEF(
        exp, result,
        "(def some (f xs)\n"
        "  (if (no xs)      t\n"
        "      (f (car xs)) (all f (cdr xs))\n"
        "                   nil))");

}
#+end_src

*** Basic parser test

This is a  test for the parser. This takes  the tokenizer's output and
attempts to  parse each token  into a  proper Bel object  described by
it.

We begin with a  macro much like the one for  the tokenizer, but here,
we perform tokenization and then parsing.

#+begin_src C
#define BEL_PARSER_DEBRIEF(exp, res, str)               \
    {                                                   \
        exp = bel_tokenize(str);                        \
        res = bel_parse_expr(exp, 0);                   \
        printf("Expression:\n" str "\nResult: ");       \
        bel_print(res);                                 \
        putchar(10);                                    \
    }
#+end_src

The  test itself  just invokes  the macro,  and takes  the exact  same
variables needed by the tokenizer  tests. Here, instead of returning a
flat list of  strings, we return a list of  all parsed expressions, be
them lists or not.

#+begin_src C
void
parser_test()
{
    Bel *expr;
    Bel *result;
    
    BEL_PARSER_DEBRIEF(expr, result, "(+ 1 2)");

    BEL_PARSER_DEBRIEF(
        expr, result,
        "(progn (+ 1 2)\n"
        "       (+ 2 3))");

    BEL_PARSER_DEBRIEF(
        expr, result,
        "(def some (f xs)\n"
        "  (if (no xs)      t\n"
        "      (f (car xs)) (all f (cdr xs))\n"
        "                   nil))");
}
#+end_src

*** Arbitrary input parsing

This test  takes an arbitrary input  from the user and  parses it into
proper Bel objects.

As the behavior suggests, this is extremely unsafe! But it can be used
in debug  occasions. Plus, this uses  ~fgets~ for user input,  which has
its  constraints on  buffer  overflow,  but does  not  offer the  same
guarantees as ~libeditline~ or ~libreadline~.

When you are done, type ~#q~ to finish the parsing session.

#+begin_src C
void
arbitrary_input_parsing()
{
    Bel *result;
    Bel *tokens;
    char input[1024] = {0};
    puts("When you are done, type #q to exit.");
    puts("And don't worry about flush errors.");
    while(1) {
        printf("parse> ");
        fgets(input, 1024, stdin);
        input[strlen(input)] = '\0';

        // Sorry about that :V
        if(input[0] == '#' &&
           input[1] == 'q')
            break;

        tokens = bel_tokenize(input);
        puts("Tokens:");
        bel_print(tokens); putchar(10);

        result = bel_parse_expr(tokens, 0);
        puts("Result:");
        bel_print(result); putchar(10);
    }
}
#+end_src

*** Test-only REPL

This implements  a test REPL  which takes an  input from the  user and
attempts to evaluate everything that is written.

This is supposed to test the  parser and the evaluator together, those
not being the interpreter itself.

This  is also  very unsafe.  There  are a  lot  of checks  we are  not
performing here, and those are on purpose, since this is for debug and
testing purposes only.

When you are done, type ~#q~ to finish the evaluation session.

#+begin_src C
void
test_repl()
{
    Bel *result;
    Bel *tokens;
    char input[1024] = {0};
    puts("When you are done, type #q to exit.");
    puts("And don't worry about flush errors.");
    while(1) {
        printf("test> ");
        fgets(input, 1024, stdin);
        input[strlen(input)] = '\0';

        // Sorry about that :V
        if(input[0] == '#' &&
           input[1] == 'q')
            break;

        tokens = bel_tokenize(input);
        result = bel_parse_expr(tokens, 0);
        if(!bel_errorp(result)) {
            result = bel_eval(bel_car(result),
                              bel_g_nil);
        }
        bel_print(result); putchar(10);
    }
}
#+end_src

* Entry point
** Initialization

This is the initialization function for the Bel interpreter. Once this
function is called, the Bel system is ready to be used.

#+begin_src C
Bel*
bel_init(void)
{
    // Initialize garbage collector
    GC_INIT();

    // Initialize random number generation
    // Warning: This is a VERY naive approach
    srand(time(NULL));

    // Initialize symbol table
    bel_sym_table_init();

    // Axioms
    bel_init_ax_vars();
    bel_init_ax_chars();
    bel_init_streams();
    bel_init_ax_env();
    bel_init_ax_primitives();

    // TODO: Return an environment?
    return bel_g_nil;
}
#+end_src

** Tests

This is the entry point for tests. All running tests are to be put
here.

We also make sure that these tests are run as a menu, so that only the
desired test is shown when needed.

#+begin_src C
void
run_tests()
{
    int opt;

    do {
        puts("-- Believe test menu\n"
             "   Choose a test to run:\n"
             " 1. String test\n"
             " 2. Notation test\n"
             " 3. List test\n"
             " 4. Closure representation test\n"
             " 5. Character List & Lookup test\n"
             " 6. Read five bytes from Believe's source\n"
             " 7. Show a few errors on screen\n"
             " 8. Lookup a few primitives and print them\n"
             " 9. Lexical environment test\n"
             "10. Globals and assignment tests\n"
             "11. Number arithmetic tests\n"
             "12. Evaluator test\n"
             "13. Arithmetic evaluation test\n"
             "14. Primitive arity test\n"
             "15. Dynamic binding test\n"
             "16. Global binding test\n"
             "17. Basic tokenizer test\n"
             "18. Parser test\n"
             "19. Arbitrary input parser (unsafe!)\n"
             "20. Test REPL (unsafe!)\n"
             
             " 0. Exit menu");
        printf("Option >> ");
        scanf("%d", &opt);

        // flush here

        putchar(10);
        switch(opt) {
        default: puts("Invalid option.");    break;
        case  0:  break;
        case  1: string_test();              break;
        case  2: notation_test();            break;
        case  3: list_test();                break;
        case  4: closure_repr_test();        break;
        case  5: character_list_test();      break;
        case  6: read_file_test();           break;
        case  7: show_errors_test();         break;
        case  8: lookup_primitives_test();   break;
        case  9: lexical_environment_test(); break;
        case 10: global_assignment_test();   break;
        case 11: number_test();              break;
        case 12: eval_test();                break;
        case 13: arithmetic_eval_test();     break;
        case 14: arity_test();               break;
        case 15: dynamic_binding_test();     break;
        case 16: global_binding_test();      break;
        case 17: basic_tokenizer_test();     break;
        case 18: parser_test();              break;
        case 19: arbitrary_input_parsing();  break;
        case 20: test_repl();                break;
        }
        
    } while(opt != 0);
}
#+end_src

** =main= function

This is the program entry point. It is supposed to only print the
ribbon, initialize Bel and perform some tests, for now.

#+begin_src C
int
main(void)
{
    printf("Believe %s (built %s)\n",
           BELIEVE_VERSION,
           BELIEVE_BUILD_TIME);
    printf("A Bel Lisp interpreter\n");
    printf("Copyright (c) %s\n", BELIEVE_COPYRIGHT);
    printf("This software is distributed under the %s license.\n",
          BELIEVE_LICENSE);

    bel_init();

#ifdef BEL_DEBUG
    run_tests();
#else
    test_repl();
#endif
    
    return 0;
}
#+end_src

* Footnotes

[fn:6] https://creativecommons.org/licenses/by-sa/4.0/

[fn:3] You can see a list of compatible licenses at
https://creativecommons.org/compatible-licenses.

[fn:2] You must indicate if you modified the material and retain an
indication of previous modifications. 

[fn:1] You must provide the name of the creator and attribution
parties, a copyright notice, a license notice, a disclaimer notice,
and a link to the original material.
