#+TITLE:    Believe: A Bel interpreter built with C11 [Beta]
#+AUTHOR:   Lucas Vieira
# #+DATE:     2019
#+PROPERTY: header-args:C :eval no :main no :tangle believe.c
#+STARTUP:  content

:LATEX_PROPERTIES:
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,twoside]
#+LATEX_HEADER: \usepackage[brazil]{babel}
#+LATEX_HEADER: \usepackage{times}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{microtype}
#+LATEX_HEADER: \usepackage{titlesec}
#+LATEX_HEADER: \usepackage[brazilian, hyperpageref]{backref}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage[alf,abnt-emphasize=bf,abnt-doi=link]{abntex2cite}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{draftwatermark}

# Remove colorization of links
#+LATEX_HEADER: \definecolor{blue}{RGB}{41,5,195}
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \hypersetup{
# #+LATEX_HEADER:     pdftitle={%t},
# #+LATEX_HEADER:     pdfauthor={%a},
# #+LATEX_HEADER:     pdfkeywords={%k},
# #+LATEX_HEADER:     pdfsubject={%d},
# #+LATEX_HEADER:     pdfcreator={%c},
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     linkcolor=black,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     filecolor=black,
#+LATEX_HEADER:     urlcolor=blue,
#+LATEX_HEADER:     bookmarksdepth=4
#+LATEX_HEADER: }
#+LATEX_HEADER: \makeatother
#+BIND: org-latex-hyperref-template ""
:END:

* Introduction

The goal of this project is to provide a fully-functioning
implementation of the Bel language, proposed by Paul Graham. The main
goal is not to provide performance; instead, it is supposed to be a
didatic approach to implementing a Lisp interpreter.

The code here contained is also a study on how to build a Lisp
interpreter from scratch in C. Given that Bel is so simple and is
supposed to be a formalism before a commercial language, it seems like
the perfect didatic resource to do so.

Here are some useful links with language resources:

- [[http://paulgraham.com/bel.html][Paul Graham's Bel release website]]
- [[https://sep.yimg.com/ty/cdn/paulgraham/bellanguage.txt?t=1570993483&][Language Guide]]
- [[https://sep.yimg.com/ty/cdn/paulgraham/bel.bel?t=1570993483&][Language Source Code, written in Bel itself]]
- [[https://sep.yimg.com/ty/cdn/paulgraham/belexamples.txt?t=1570993483&][Bel examples]]

Note that *this software is still a work-in-progress. Do not expect it to work
fully yet.*

** About literate programming

#+TODO: Lacks references! Use Org-ref for that!
This interpreter is built using [[https://orgmode.org/][Org with Org-mode in Emacs]]. Its
website specifies that Org is "a format for keeping notes, maintaining
TODO lists, planning projects, and authoring documents with a fast and
effective plain-text system".

All the code here appears in the order it is written on the actual
code files. By using [[http://www.literateprogramming.com/knuthweb.pdf][Donald Knuth's concept of literate programming]],
the relevant code blocks are /tangled/ and written in their specified
code files, and then the application can be compiled.

By using this approach, I hope to maintain an application where the
understanding of what is being written comes before the code itself,
so that the reader is able to take and analyse parts of said code
based on the prose that accompanies it.

** Licenses
*** Prose license

#+LATEX_ATTR: :width 0.2cm
[[file:images/cc-by-sa.png]]

This work is licensed under a [[http://creativecommons.org/licenses/by-sa/4.0/][Creative Commons Attribution-ShareAlike
4.0 International License]]. See the link for more information.

*** Software license

This is a verbatim copy of the software's license file.

#+begin_src text :tangle LICENSE
MIT License

Copyright (c) 2019 Lucas Vieira

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
#+end_src

* COMMENT Informal TO-DO list

This section is not supposed to be exported in a PDF file.

- [x] Environment functions
- [x] Global environment object =globe=
- [x] Various necessary predicates
  - [x] =stringp= predicate
- [x] Error object
- [x] String printing
- [x] Test for errors on core functions
- [x] Dynamic environment
- [ ] Assignments/Unassignments
- [ ] Add proper references with Org-ref and bibtex
- [ ] Lexical environment object =scope=, shadowable, not unique
- [ ] =err= primitive function, basic error handling and propagation
  (WIP)
- [ ] Use =BEL_DEBUG= flag everywhere!
- [ ] Prevent circular printing. Particularly useful for environments
  and closures

- [ ] Data types
  - [x] Symbols
  - [x] Pairs
    - [x] Lists
  - [x] Characters
  - [x] Strings
  - [ ] Numbers
- [x] Literals
  - [x] Primitives (representation)
- [x] Environments
  - [x] Environment hierarchy (dyn > lex > glo) [implemented on
    lookup]
  - [ ] Dynamic binding (visible everywhere for short time)
  - [x] Hierarchical lookup (=bel_lookup=)
- [ ] Functions
  - [ ] Lexical bindings
- [ ] Evaluation
  - [ ] Eval
    - [ ] Special forms
      - [ ] =quote=
      - [ ] =lit=
        - [ ] =fn=   => literal closure
      - [ ] =if=
      - [ ] =apply=
      - [ ] =join=
      - [ ] =where=  => not so straightforward
      - [ ] =dyn=
      - [ ] =after=
      - [ ] =ccc=    => Later?
      - [ ] =thread= => Later?
      - [ ] =set=    => global binding
  - [ ] Apply
    - [ ] Primitives (application)
  
* Tools and scripts
** Makefile

This software was primarily developed on Void Linux x86\_64, using the
Clang compiler. The following Makefile is the one used for building
Believe.

#+begin_src makefile :tangle Makefile
CC     = clang
CFLAGS = --std=c11 -g -O2 -Wall -DBEL_DEBUG
CLIBS  = -lgc
BIN    = believe
OBJ    = believe.o

.PHONY: clean

$(BIN): $(OBJ)
	$(CC) $(CFLAGS) $(CLIBS) -o $@ $^

%.o: %.c
	$(CC) $(CFLAGS) -c -o $@ $^

clean:
	rm -rf *.o $(BIN)
#+end_src

** Memory leak testing

This script generates a log file with memory leak information using
Valgrind. Valgrind's output is stored in =believe.log=.

#+begin_src bash :results silent :tangle no
valgrind --check_leaks=full --log-file="believe.log" -v ./believe
#+end_src

** Tangling

The following snippet can be run from Emacs to enable tangling on save
for this file only.

Tangling is the process of taking each block of code and adding it to
its specific file. Believe's code will be written in C source files;
the Makefile will be written in its own file; and so on. Notice that
some blocks (like this one) is not written anywhere, and is meant to
be evaluated from inside Emacs.

#+begin_src emacs-lisp :tangle no :exports none :results silent
(let ((orig-lex-bind lexical-binding))
  (setq lexical-binding t)
  (add-hook 'after-save-hook 'org-babel-tangle)
  (setq lexical-binding orig-lex-bind))
#+end_src

** Running the program

This script attempts to build and run the Bel interpreter. It will
also enable verbose output for the garbage collector.

#+begin_src bash :tangle no :eval yes :cache yes :results output :exports code
make
printf "\n"
export GC_PRINT_STATS=1
./believe
#+end_src

#+RESULTS[94b57beffeb8149ed822eb732ce8c9ac526fa891]:
#+begin_example
clang --std=c11 -g -O2 -Wall -DBEL_DEBUG -c -o believe.o believe.c
clang --std=c11 -g -O2 -Wall -DBEL_DEBUG -lgc -o believe believe.o

Believe 0.1
A Bel Lisp interpreter
Copyright (c) 2019 Lucas Vieira
This software is distributed under the MIT license.
-- Running debug tests
  -- String test
"Hello, Bel!" => Hello, Bel!
"There is no Bel without \bel"
  -- Notation test
((foo . bar) baz . quux)
  -- List test
(The quick brown fox jumps over the lazy dog)
  -- Closure representation test
(lit clo nil (xar) (* xar xar))
  -- Character List & Lookup test
Char: 097 (a) => "01100001"
Char: 098 (b) => "01100010"
Char: 099 (c) => "01100011"
Char: 100 (d) => "01100100"
Char: 101 (e) => "01100101"
Char: 102 (f) => "01100110"
Char: 103 (g) => "01100111"
Char: 104 (h) => "01101000"
Char: 105 (i) => "01101001"
Char: 106 (j) => "01101010"
  -- Read five bytes from Believe's source
"00100011" => \#
"01101001" => \i
"01101110" => \n
"01100011" => \c
"01101100" => \l
"01110101" => \u
"01100100" => \d
"01100101" => \e
"00100000" => \ 
"00111100" => \<
  -- Show a few errors on screen
(lit err "Unable to open stream ~a." "waddawaddawadda")
Is this an error? y
(lit err "Cannot extract the car of ~a." t)
(lit err "Cannot extract the cdr of ~a." t)
  -- Lookup a few primitives and print them
(lit prim car)
(lit prim cdr)
(lit prim coin)
(lit prim stat)
nil
(lit err "The symbol ~a is unbound." wadawada)
  -- Lexical environment tests
    -- Registering local `foo`
Environment:       ((foo . bar))
Lookup:            bar

    -- Assigning new value to `foo`
Environment:       ((foo lit baz))
Assignment result: foo
Lookup:            (lit baz)

    -- Unbinding `foo`
Environment:       nil
Unbinding result:  foo
Lookup:            (lit err "The symbol ~a is unbound." foo)
  -- Globals and assignment tests
    -- Assigning `foo` without previous definition
WARNING: Assignment failed, registering new global
Assignment result: foo
Lookup:            bar

    -- Shadowing global `foo` with a local
Environment:       ((foo . quux))
Lookup:            quux
    -- Unbinding `foo` three times

Environment:       nil
Unbinding result:  foo
Lookup:            bar

Environment:       nil
Unbinding result:  foo
Lookup:            (lit err "The symbol ~a is unbound." foo)

Environment:       nil
Unbinding result:  nil
Lookup:            (lit err "The symbol ~a is unbound." foo)
#+end_example

* Libraries and headers

** Default headers

We'll be using =stdio.h= for default console I/O, plus =stdint.h= for some
standard integer types. =string.h= provides definitions to handle string
manipulation on the C side, however Bel is supposed to have its own
string representation, to be discussed later. =errno.h= is used to fetch
error strings from streams, for example.

#+begin_src C
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#+end_src

** Definitions

We'll use a flag for debug which influences the building
process. Let's call this flag =BEL_DEBUG=.

When building, if you pass this flag to Clang (see the Makefile), some
debug outputs will be available.

By default we'll leave it on, at least for now.

** Boehm-Demers-Weiser Garbage Collector

We also use Boehm-Demers-Weiser GC for garbage collection, instead of
programming our own. The =GC_DEBUG= flag helps on debugging. See that we
use =-lgc= on the Makefile to link the relevant library to the
application.

#+begin_src C
#define GC_DEBUG
#include <gc.h>
#+end_src

Plus, [[https://www.hboehm.info/gc/04tutorial.pdf][one could check the Boehm-Demers-Weiser GC tutorial slides]] by
Hans-J. Boehm, for a quick overview of this library.

#+TODO: Use GC_REGISTER_FINALIZER for streams... if convenient.

** Software-related definitions

These definitions relate to program metadata which is going to be
displayed on its startup.

#+begin_src C
#define BELIEVE_VERSION   "0.1"
#define BELIEVE_COPYRIGHT "2019 Lucas Vieira"
#define BELIEVE_LICENSE   "MIT"
#+end_src

* Fundamental data types

The first thing to do is specify how the data is going to be handled
by the interpreter. Here, we define each of these kinds of data. Any
procedure for data manipulation will be defined afterwards.

** Enumerating Bel types

We begin by specifying all data types, which Bel has four: symbols,
pairs, characters and streams.

#+begin_src C
typedef enum
{
    BEL_SYMBOL,
    BEL_PAIR,
    BEL_CHAR,
    BEL_STREAM
} BEL_TYPE;
#+end_src

** Pair

A pair can have two things, which can in return be one of the four
data types themselves. Since this is sort of a recursive definition,
we need to make a forward declaration of the general =Bel= type, which
encloses all four data types.

#+begin_src C
typedef struct BEL Bel; // Forward declaration

typedef struct
{
    Bel *car;
    Bel *cdr;
} Bel_pair;
#+end_src

** Character

A character is nothing but an integer in standard C. For now we'll
support only ASCII, so there is no actual need to instantiate the
proposed table of characters -- this might change in the future.

We say that a character is nothing but a signed 8-bit integer. Should
be enough for now.

#+begin_src C
typedef int8_t Bel_char;
#+end_src

** Symbol

A symbol is nothing but a specific index on the symbol table, so
that's how we'll define it.

#+begin_src C
typedef uint64_t Bel_sym;
#+end_src

** Stream

The stream type is somewhat implementation-dependent. In C, a standard
way to refer to streams is to use a =FILE= pointer, since =stdout= and
=stdin= themselves are of such type. So we just wrap these pointers in
a stream type.

Plus, as per Bel's specification, a stream has three statuses: closed,
open for reading, open for writing. Therefore, we use a single
enumeration to represent these three states.

Since Bel's specification writes to a stream bit by bit, we need to
cache the currently filled byte inside the structure, from left to
right, dumping each byte as it is filled. Upon closing, the stream
shall write the cache at the end of the file, plus the incomplete
remaining bits. A "new" (not written and not dumped) cache is a single
byte, and is guaranteed to be filled with zero =(\0 \0 \0 \0 \0 \0 \0
\0)=.

When dealing with reading from a stream, since Bel also reads bit by
bit only, we take the same advantage of the cache, however as the
opposite approach: we read a single byte from stream and keep the
cache full. As we read each bit, we convert it to a Bel character (=\0=
or =\1=). Once all bits of the cache have been read, another byte is
fetched, stored on cache, and so on.

#+begin_src C
typedef enum BEL_STREAM_STATUS
{
    BEL_STREAM_CLOSED,
    BEL_STREAM_READ,
    BEL_STREAM_WRITE
} BEL_STREAM_STATUS;

typedef struct
{
    BEL_STREAM_STATUS  status;
    FILE              *raw_stream;
    uint8_t            cache;
    uint8_t            cache_used;
} Bel_stream;
#+end_src

** The =Bel= structure

The remaining thing to do is join all the types into the =Bel= type,
which will serve as our generic way of dealing with things.

#+begin_src C
// Aliased as 'Bel' before
struct BEL
{
    BEL_TYPE type;
    union {
        Bel_sym     sym;
        Bel_pair   *pair;
        Bel_char    chr;
        Bel_stream  stream;
    };
};
#+end_src

* Essential structures and manipulation of data
** Basic definitions

These definitions relate to essential symbols of the Bel global
environment. They also encode the symbols' position on the global
symbol table, to be defined later.

#+begin_src C
#define BEL_NIL   ((Bel_sym)0)
#define BEL_T     ((Bel_sym)1)
#define BEL_O     ((Bel_sym)2)
#define BEL_APPLY ((Bel_sym)3)
#+end_src

The following symbols are axioms which are global to the program. One
is expected to use them instead of creating new symbols, though it is
not strictly necessary.

#+begin_src C
Bel *bel_g_nil;
Bel *bel_g_t;
Bel *bel_g_o;
Bel *bel_g_apply;
#+end_src

These other variables are responsible for holding other axioms on the
system. More on then will be specified later.

#+TODO: Add `errs` as an error stream?

#+begin_src C
Bel *bel_g_chars;
Bel *bel_g_ins_sys;
Bel *bel_g_outs_sys;
Bel *bel_g_ins;
Bel *bel_g_outs;
Bel *bel_g_prim;
#+end_src

We may also define temporary variables for the global, dynamic and
lexical environments.

#+begin_src C
Bel *bel_g_scope;
Bel *bel_g_dynae;
Bel *bel_g_globe;
#+end_src

*** Forward declarations

We need to forward declare a few functions which will be useful for
certain operations. For example, it is important that we make a
forward declaration of =bel_mkerror=, since the primitives should depend
on it; also, providing =bel_mkstring= ensures that the error format can
be easily created, and so on.

#+TODO: Is this even correct? Test whether bel_mkerror creates an infinite loop!

#+begin_src C
Bel *bel_mkerror(Bel *format, Bel *vars);   // Forward declaration
Bel *bel_mkstring(const char*);             // Forward declaration
Bel *bel_mksymbol(const char*);             // Forward declaration
Bel *bel_car(Bel*);                         // Forward declaration
Bel *bel_cdr(Bel*);                         // Forward declaration
#+end_src

*** Predicates

It is important to have a few predicates which will help us check for
errors. These predicates do not check for argument nullability
(e.g. unmanaged pointers), so use it wisely and only on initialized
data!

**** =symbolp=

=bel_symbolp= tests whether the element is a symbol.

#+begin_src C
#define bel_symbolp(x) ((x)->type==BEL_SYMBOL)
#+end_src

**** =nilp=

=bel_nilp= tests whether the element is the /symbol/ =nil=.

#+begin_src C
#define bel_nilp(x)                             \
    (bel_symbolp(x) && ((x)->sym==BEL_NIL))
#+end_src

**** =pairp=

=bel_pairp= tests whether the element is a /pair/. That is, either it is a
proper pair, or it is the symbol =nil=.

Note that Bel does not explicitly specify that =nil= is a pair, but I am
assuming it since one can "extract" the /car/ and the /cdr/ of =nil=.

#+begin_src C
#define bel_pairp(x)                            \
    (((x)->type==BEL_PAIR) || bel_nilp(x))
#+end_src

**** =atomp=

=bel_atomp= can be a little tricky to understand, altough the
implementation is simple. Bel specifies that anything that is not a
pair is called an atom. The problem, though, is to decide whether =nil=
is an atom or not.

Common Lisp takes =NIL= as being both a /cons/ and an /atom/ (since it is
both a symbol and a representation for the empty list). I leveraged
that and decided to say that, in Believe, an /atom/ is /anything that is
not built out of a pair of at least two elements/. Note that there is
no such thing like a "pair of one element", but I am considering =nil=
as a pair of "zero" elements. So =nil= is the only symbol which is both
an /atom/ and a /pair/.

#+begin_src C
#define bel_atomp(x)                             \
    (bel_nilp(x) || !bel_pairp(x))
#+end_src

**** =charp=

=bel_charp= tests whether the object is a character.

#+begin_src C
#define bel_charp(x)                            \
    (((x)->type==BEL_CHAR))
#+end_src

**** =streamp=

=bel_streamp= tests whether the object is a stream.

#+begin_src C
#define bel_streamp(x)                          \
    (((x)->type==BEL_STREAM))
#+end_src

**** =idp=

=bel_idp= tests whether an object is identical to another.
According to the Bel specification, identity is stricted than
equality: there is only one of each symbol and character, but pairs
and streams are never identical.

This is the first predicate that is implemented as a proper C
function, and it is used only internally; therefore, it outputs a C
integer value for truth and falsity.

#+begin_src C
int
bel_idp(Bel *x, Bel *y)
{
    if((!bel_symbolp(x) && !bel_charp(x))
       || (!bel_symbolp(y) && !bel_charp(y)))
        return 0;

    if(bel_symbolp(x))
        return (x->sym == y->sym);
    return (x->chr == y->chr);
}
#+end_src

**** =errorp=

=bel_errorp= tests whether a specific object is a list in the format
=(lit err . rest)=.

#+begin_src C
int
bel_errorp(Bel *x)
{
    if(!bel_pairp(x)) return 0;
    if(!bel_idp(bel_car(x), bel_mksymbol("lit")))
        return 0;
    Bel *cdr = bel_cdr(x);
    if(!bel_idp(bel_car(cdr), bel_mksymbol("err")))
        return 0;
    return 1;
}
#+end_src

**** =proper-list-p=

A proper list is any list which ends in an appropriate =nil= symbol. So
for example, =(1 2 3)= is a proper list, but =(1 2 3 . 4)= is not. Compare
how these lists can be expressed by using dot notation:

- =(1 . (2 . (3 . nil)))=
- =(1 . (2 . (3 . 4)))=

An empty list is considered a proper list as well.

=bel_proper_list_p= checks whether a list is indeed a proper list. We do
that by traversing the list, pair by pair. If the /cdr/ is =nil=, it is
proper; if it is a pair, it proceeds the traversal. But if the /cdr/ is
anything otherwise, then it is not a proper list.

#+begin_src C
int
bel_proper_list_p(Bel *x)
{
    if(!bel_pairp(x))
        return 0;
    
    if(bel_nilp(x))
        return 1;
    
    Bel *itr = x;
    while(!bel_nilp(itr)) {
        itr = bel_cdr(itr);
        if(!bel_pairp(x))
            return 0;
    }

    return 1;
}
#+end_src

**** =stringp=

An object is a string if and only if:

- it is a proper list;
- it contains characters only.

=bel_stringp= tests for this. However, this first implementation is a
little na√Øve, since it performs a proper list check, which involves
traversing an entire list, and then it traverses the list again,
checking for characters in the /car/. This overhead can be reduced in
the future.

#+begin_src C
int
bel_stringp(Bel *x)
{
    if(!bel_proper_list_p(x)) {
        return 0;
    }

    Bel *itr = x;
    while(!bel_nilp(itr)) {
        Bel *car = bel_car(itr);

        if(!bel_charp(car))
            return 0;

        itr = bel_cdr(itr);
    }

    return 1;
}
#+end_src

** Symbol Table and Symbols

The symbol table is an array that grows as necessary, doubling in
size, but never shrinks on the program's lifetime. Each element of the
table is a =const= C string.

We begin by defining such structure and a global symbol table.

#+begin_src C
typedef struct {
    const char **tbl;
    uint64_t     n_syms;
    uint64_t     size;
} _Bel_sym_table;

_Bel_sym_table g_sym_table;
#+end_src

To initialize the symbol table, we give it an initial size of four,
just enough to enclose Bel's four fundamental symbols: =nil=, =t=, =o= and
=apply=. Notice that the order of these symbols relate to their
predefined macros, so any failure here is unexpected.

#+begin_src C
void
bel_sym_table_init(void)
{
    g_sym_table.n_syms = 4;
    g_sym_table.size   = 4;
    g_sym_table.tbl    =
        GC_MALLOC(g_sym_table.size * sizeof(char*));

    g_sym_table.tbl[BEL_NIL]   = "nil";
    g_sym_table.tbl[BEL_T]     = "t";
    g_sym_table.tbl[BEL_O]     = "o";
    g_sym_table.tbl[BEL_APPLY] = "apply";
}
#+end_src

The lookup function =bel_sym_table_find= does a linear search for the
presented literal on the symbol table. However, if it doesn't find the
symbol, it implicitly calls =bel_sym_table_add=, which appends the
symbol to the table.

This is obviously not a very wise approach as it opens up for some
exploits on interning symbols, but should be enough as long as these
symbols are only really interned on =lit= or =quote= scopes.

#+begin_src C
Bel_sym bel_sym_table_add(const char*); // Forward declaration

Bel_sym
bel_sym_table_find(const char *sym_literal)
{
    uint64_t i;
    size_t len = strlen(sym_literal);
    for(i = 0; i < g_sym_table.n_syms; i++) {
        if(!strncmp(sym_literal, g_sym_table.tbl[i], len)) {
            return i;
        }
    }

    return bel_sym_table_add(sym_literal);
}

Bel_sym
bel_sym_table_add(const char *sym_literal)
{
    if(g_sym_table.n_syms == g_sym_table.size) {
        uint64_t new_size = 2 * g_sym_table.size;
        g_sym_table.tbl = GC_REALLOC(g_sym_table.tbl,
                                     new_size * sizeof(char*));
        g_sym_table.size = new_size;
    }
    g_sym_table.tbl[g_sym_table.n_syms++] = sym_literal;
    return (g_sym_table.n_syms - 1);
}
#+end_src

Last but not least, we create a proper tool to build a symbol. Just
give it your desired symbol as a string literal and the runtime takes
care of the rest.

#+begin_src C
Bel*
bel_mksymbol(const char *str)
{
    Bel *ret  = GC_MALLOC(sizeof (*ret));
    ret->type = BEL_SYMBOL;
    ret->sym  = bel_sym_table_find(str);
    return ret;
}
#+end_src

** Pairs

Pairs are the kernel of every Lisp, so we need tools to manipulate
them.

We begin by specifying the function which builds pairs. Notice that
the function itself takes two references to values, so pairs cannot
exist without their /car/ and /cdr/.

#+begin_src C
Bel*
bel_mkpair(Bel *car, Bel *cdr)
{
    Bel *ret  = GC_MALLOC(sizeof (*ret));
    ret->type = BEL_PAIR;
    ret->pair = GC_MALLOC(sizeof (Bel_pair));
    ret->pair->car = car;
    ret->pair->cdr = cdr;
    return ret;
}
#+end_src

Now we may easily extract information from pairs, using the /car/ and
/cdr/ operations.

#+begin_src C
Bel*
bel_car(Bel *p)
{
    if(!bel_pairp(p)) {
        return bel_mkerror(
            bel_mkstring("Cannot extract the car of ~a."),
            bel_mkpair(p, bel_g_nil));
    }
    
    if(bel_nilp(p))
        return bel_g_nil;
    return p->pair->car;
}

Bel*
bel_cdr(Bel *p)
{
    if(!bel_pairp(p)) {
        return bel_mkerror(
            bel_mkstring("Cannot extract the cdr of ~a."),
            bel_mkpair(p, bel_g_nil));
    }
    
    if(bel_nilp(p))
        return bel_g_nil;
    return p->pair->cdr;
}
#+end_src

Let's also build an utility to return the size of a list. This is a
=O(n)= operation which takes a well-formed list and iterates over
it.

Note that *calculating the length of something that is not a /proper
list/ makes no sense and will crash this operation*. So before calling
=bel_length=, it is probably a good idea to check for a valid proper
list using =bel_proper_list_p= or a similar procedure.

#+begin_src C
uint64_t
bel_length(Bel *list)
{
    Bel *itr = list;
    uint64_t len = 0;
    while(!bel_nilp(itr)) {
        len++;
        itr = bel_cdr(itr);
    }
    return len;
}
#+end_src

** Characters and Strings

Let's begin by adding a small function to wrap a character in a Bel
object.

#+begin_src C
Bel*
bel_mkchar(Bel_char c)
{
    Bel *ret  = GC_MALLOC(sizeof *ret);
    ret->type = BEL_CHAR;
    ret->chr  = c;
    return ret;
}
#+end_src

#+TODO: This needs to change if unicode support is enabled
Characters have the size of one byte, so if we take a single list of 8
=\1= and =\0= characters, we should be able to generate a bitmask of the
corresponding character in question.

#+begin_src C
Bel*
bel_char_from_binary(Bel *list)
{
    if(!bel_pairp(list)) {
        return bel_mkerror(
            bel_mkstring("The binary representation of "
                         "a character must be a string of "
                         "characters \\0 and \\1."),
            bel_g_nil);
    }

    if(!bel_proper_list_p(list)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a proper "
                         "list, and therefore not a list "
                         "of characters \\0 and \\1."),
            bel_mkpair(list, bel_g_nil));
    }

    size_t len = bel_length(list);

    if(len != 8) {
        return bel_mkerror(
            bel_mkstring("The binary representation of "
                         "a character must have exactly "
                         "eight characters \\0 or \\1."),
            bel_g_nil);
    }
    
    Bel_char mask = '\0';
    size_t i;
    Bel *current = list;
    
    for(i = 0; i < len; i++) {
        Bel *bitchar = bel_car(current);

        if(!bel_charp(bitchar)) {
            return bel_mkerror(
                bel_mkstring("The provided binary "
                             "representation of a "
                             "character does not contain "
                             "only characters."),
                bel_g_nil);
        }

        if(bitchar->chr != '0' && bitchar->chr != '1') {
            return bel_mkerror(
                bel_mkstring("The binary representation of "
                             "a character must have exactly "
                             "eight characters \\0 or \\1."),
                bel_g_nil);
        }
        
        if(bitchar->chr == '1') {
            mask |= (1 << (7 - i));
        }
        current = bel_cdr(current);
    }
    return bel_mkchar(mask);
}
#+end_src

Strings on the Bel environment are nothing more than a list of
characters, therefore we need a way to convert C strings to proper Bel
lists.

#+begin_src C
Bel*
bel_mkstring(const char *str)
{
    size_t len = strlen(str);

    if(len == 0)
        return bel_g_nil;
    
    Bel **pairs = GC_MALLOC(len * sizeof (Bel));

    // Create pairs where CAR is a character and CDR is nil
    size_t i;
    for(i = 0; i < len; i++) {
        Bel *chr  = GC_MALLOC(sizeof *chr);
        chr->type = BEL_CHAR;
        chr->chr  = str[i];
        pairs[i]  = bel_mkpair(chr, bel_g_nil);
    }

    // Link all pairs properly
    for(i = 0; i < len - 1; i++) {
        pairs[i]->pair->cdr = pairs[i + 1];
    }

    return pairs[0];
}
#+end_src

We also add an utility to take back a Bel string and turn it into a
garbage-collected C string.

Note that the errors it can produce are instead dumped to the console
and we return a null pointer; proper manipulation of this function is
a responsibility of the programmer, since this is an internal
function.

#+begin_src C
char*
bel_cstring(Bel *belstr)
{
    if(!bel_pairp(belstr)) {
        puts("INTERNAL ERROR on bel_cstring: "
             "argument is not a pair");
        return NULL;
    }
    
    if(!bel_stringp(belstr)) {
        puts("INTERNAL ERROR on bel_cstring: "
             "argument is not a string");
        return NULL;
    }
    
    uint64_t len = bel_length(belstr);
    if(len == 0) return NULL;
    
    char *str    = GC_MALLOC((len + 1) * sizeof (*str));

    Bel *itr     = belstr;
    size_t i     = 0;

    while(!bel_nilp(itr)) {
        str[i] = bel_car(itr)->chr;
        itr    = bel_cdr(itr);
        i++;
    }
    str[i] = '\0';
    return str;
}
#+end_src

** Streams

#+TODO: Enclose stderr on Bel object
We start by creating tools to manipulate streams. First, we create a
raw stream from a file.

#+begin_src C
Bel*
bel_mkstream(const char* name, BEL_STREAM_STATUS status)
{
    Bel *ret           = GC_MALLOC(sizeof *ret);
    ret->type          = BEL_STREAM;

    if(status == BEL_STREAM_CLOSED) {
        return bel_mkerror(
            bel_mkstring("Cannot create a stream with "
                         "CLOSED status."),
            bel_g_nil);
    }

    if(!strncmp(name, "ins", 3)) {
        ret->stream.raw_stream = stdin;
    } else if(!strncmp(name, "outs", 4)) {
        ret->stream.raw_stream = stdout;
    } else {
        ret->stream.raw_stream =
            fopen(name,
                  status == BEL_STREAM_READ ? "rb" : "wb");
        
        if(!ret->stream.raw_stream) {
            return bel_mkerror(
                bel_mkstring("Unable to open stream ~a."),
                bel_mkpair(
                    bel_mkstring(name), bel_g_nil));
        }
    }

    ret->stream.status     = status;
    ret->stream.cache      = 0u;
    ret->stream.cache_used = 0u;
    return ret;
}
#+end_src

One important thing to have is a function which inputs a single bit in
a file. We use the previously defined cache system for that; by
filling the bits from left to right, we'll enable output as a single
bit.

First we define the function which dumps and resets the cache of a
specific stream when the cache is full; this should come in handy when
closing the stream as well. After that, we do the actual bit
writing. And of course, writing a bit returns =t= or =nil= for success and
failure; this will most likely not be external to the Bel environment
itself, since a failure in writing must signal an error. But that is
not the job for this primitive.

#+begin_src C
Bel*
bel_stream_dump_cache(Bel_stream *stream)
{
    if(!fwrite(&stream->cache, 1, 1, stream->raw_stream)) {
        return bel_g_nil;
    }
    stream->cache_used = 0u;
    stream->cache      = 0u;
    return bel_g_t;
}

Bel*
bel_stream_write_bit(Bel_stream *stream, Bel_char bit)
{
    if(bit != '0' || bit != '1') {
        return bel_mkerror(
            bel_mkstring("Written bit must be represented "
                         "as a character 0 or 1"),
            bel_g_nil);
    }

    if(stream->status != BEL_STREAM_WRITE) {
        return bel_mkerror(
            bel_mkstring("Write stream is not at WRITE "
                         "state"),
            bel_g_nil);
    }

    if(stream->cache_used >= 8) {
        return bel_stream_dump_cache(stream);
    } else {
        if(bit == '1') {
            stream->cache |= (1 << (7 - stream->cache_used));
        }
        stream->cache_used++;
    }
    
    return bel_mkchar(bit);
}
#+end_src

We can take advantage of the same variables to read single bits from a
file, as described before too. Keep the cache full, read single bits
as Bel characters, fill the cache when the read bits are exhausted.

#+TODO: "Being unable to read a bit" signals an error.
#+TODO: "No bit is currently available" returns nil -- but how should I do it?

#+begin_src C
Bel*
bel_stream_fill_cache(Bel_stream *stream)
{
    if(!fread(&stream->cache, 1, 1, stream->raw_stream)) {
        // Return nil on EOF
        return bel_g_nil;
    }
    stream->cache_used = 8;
    return bel_g_t;
}

Bel*
bel_stream_read_bit(Bel_stream *stream)
{
    if(stream->status != BEL_STREAM_READ) {
        return bel_mkerror(
            bel_mkstring("Read stream is not at READ "
                         "state"),
            bel_g_nil);
    }
    
    Bel *ret;
    if(stream->cache_used == 0) {
        ret = bel_stream_fill_cache(stream);
        if(bel_nilp(ret)) {
            return bel_mksymbol("eof");
        }
    }

    uint8_t mask = (1 << (stream->cache_used - 1));
    ret = bel_mkchar(((mask & stream->cache) == mask)
                     ? ((Bel_char)'1') : ((Bel_char)'0'));
    stream->cache_used--;
    return ret;
}
#+end_src

#+TODO: Byte input/output -- unecessary?
#+TODO: Text input/output, specifically for ins/outs -- unecessary?

We'll also need a tool to close a certain stream. Here we're being a
little more careful, since streams are managed more directly, by using
the C API. And of course, if we're dealing with output, dump the
stream cache before closing the file.

#+begin_src C
Bel*
bel_stream_close(Bel *obj)
{
    if(obj->type != BEL_STREAM) {
        return bel_mkerror(
            bel_mkstring("Cannot close something that "
                         "is not a stream."),
            bel_g_nil);
    }
    
    if(obj->stream.status == BEL_STREAM_CLOSED) {
        return bel_mkerror(
            bel_mkstring("Cannot close a closed stream."),
            bel_g_nil);
    }

    // Dump cache before closing
    if(obj->stream.status == BEL_STREAM_WRITE) {
        bel_stream_dump_cache(&obj->stream);
    }
    
    if(!fclose(obj->stream.raw_stream)) {
        obj->stream.raw_stream = NULL;
        obj->stream.status     = BEL_STREAM_CLOSED;
        return bel_g_t;
    }

    return bel_mkerror(
        bel_mkstring("Error closing stream: ~a."),
        bel_mkpair(
            bel_mkstring(strerror(errno)),
            bel_g_nil));
}
#+end_src

The default input and output streams are enclosed in Bel objects here,
however they relate to =stdin= and =stdout= respectively. To the system,
by default they have =nil= value.

#+begin_src C
void
bel_init_streams(void)
{
    bel_g_ins      = bel_g_nil;
    bel_g_outs     = bel_g_nil;
    bel_g_ins_sys  = bel_mkstream("ins",  BEL_STREAM_READ);
    bel_g_outs_sys = bel_mkstream("outs", BEL_STREAM_WRITE);
}
#+end_src

*** Stream manipulation safety

Since streams are defined taking advantage of the C API for
manipulating files, unfortunately these demand careful usage on Bel
programs. When handling streams, it is absolutely necessary to close
them. The Boehm GC does not have finalizers for C bindings, so
unfortunately it is not possible for now to call a finalizer which
automatically closes the stream when the stream object is garbage
collected.

** Errors

Bel does not have a formal specification on errors in primitives,
other than saying that there might be an =err= function which throws an
error in the system.

I will therefore specify that, in Believe, an error is a literal (much
like closures and primitives) which obeys the pattern...

=(lit err format . args)=

...where =lit= is the expected symbol for something that evaluates to
itself, =err= is the symbol which specifies that the object is an error,
=format= is a Bel string which contains a format for the given
arguments, and =args= is a list of arguments which should be parsed
within the format.

For a first implementation, I intend to make the format specification
follow loosely the conventions of the =format= macro in Common Lisp,
having =~a= as the format for any object and =~%= as the format for a new
line, for example.

Here's how it could look like:

#+begin_example
> (err "Cannot use ~a on ~a.~%" '(1 2 3) square)
Error: Cannot use (1 2 3) on (lit clo nil (x) (* x x)).

#+end_example

However, since this is a detail which can be implemented in Bel
itself, we'll just go ahead and say that there is a string format and
a list of arguments.

#+begin_src C
Bel*
bel_mkerror(Bel *format, Bel *arglist)
{
    return bel_mkpair(
        bel_mksymbol("lit"),
        bel_mkpair(
            bel_mksymbol("err"),
            bel_mkpair(format, arglist)));
}
#+end_src

* Axioms

To save memory, some of the following things will be globally defined.

** Variables and constants

Define global symbols which can be used across the program. These
symbols should be used repeatedly, and that's why they were already
declared. See the =bel_init= function to refer to their initialization.

#+begin_src C
void
bel_init_ax_vars(void)
{
    bel_g_nil   = bel_mksymbol("nil");
    bel_g_t     = bel_mksymbol("t");
    bel_g_o     = bel_mksymbol("o");
    bel_g_apply = bel_mksymbol("apply");

    bel_g_prim  = bel_mksymbol("prim");
}
#+end_src

=bel_g_prim= is not part of the axiom variables, but we'll define it
here since we'll need this symbol for generating primitives later.

** List of all characters

First, we build an auxiliary function which converts an 8-bit number
into a string, where each character represents a bit.

#+begin_src C
char*
bel_conv_bits(uint8_t num)
{
    char *str = GC_MALLOC(9 * sizeof(*str));
    
    uint8_t i;
    for(i = 0; i < 8; i++) {
        int is_bit_set = num & (1 << i);
        str[7 - i] = is_bit_set ? '1' : '0';
    }
    str[8] = '\0';
    
    return str;
}
#+end_src

We build a list of all characters so that the specification gets
happy. It will be stored in the previously defined =bel_g_chars= global
variable. This might seem unecessary in the future, though.

The list is supposed to be built out of pairs, therefore we start by
creating 255 =Bel= instances, representing list nodes; every node is
supposed to hold the pointer to a =Bel_pair=. These pairs will be linked
to one another: the /cdr/ of the first =Bel_pair= (again, contained inside
a =Bel= instance) points to the second =Bel=; the /cdr/ of the second
=Bel_pair= (also contained on its =Bel= instance) points to the third =Bel=,
and so on. The last /cdr/ of the last =Bel_pair=, also enclosed on a =Bel=
instance, contains the symbol =nil=.

Now, we discuss what should be held in the /car/ of each of these
pairs. And that would be other pairs, which will hold the actual
information we desire. Each of these secondary pairs is comprised of a
character at its /car/, and a Bel string representing the bits of the
character as its /cdr/.

#+begin_src C
void
bel_init_ax_chars(void)
{
    // Create a vector of 255 list nodes
    Bel **list = GC_MALLOC(255 * sizeof(*list));

    size_t i;
    for(i = 0; i < 255; i++) {        
        // Build a pair which holds the character information
        Bel *pair = bel_mkpair(bel_mkchar((Bel_char)i),
                               bel_mkstring(bel_conv_bits(i)));
        // Assign the car of a node to the current pair,
        // set its cdr temporarily to nil
        list[i] = bel_mkpair(pair, bel_g_nil);
    }

    // Assign each pair cdr to the pair on the front.
    // Last pair should have a nil cdr still.
    for(i = 0; i < 254; i++) {
        list[i]->pair->cdr = list[i + 1];
    }

    // Hold reference to first element only
    bel_g_chars = list[0];
}
#+end_src

** Environment

Any environment is nothing but a list of pairs, where each pair =(var
. val)= represents the binding of a specific symbol =var= to the value
=val=.

We begin by creating a function which pushes, non-destructively, a new
pair to any environment. The result is the new environment.

#+begin_src C
Bel*
bel_env_push(Bel *env, Bel *var, Bel *val)
{
    Bel *new_pair = bel_mkpair(var, val);
    return bel_mkpair(new_pair, env);
}
#+end_src

Notice that this non-destructive approach is important, since a
lexical enviroment is supposed to extend the enviroment it is called
on -- for example, the environment of a function called from top-level
is a list where the first elements are lexical bindings, and
(conceptually) the latter elements are bindings belonging to the
global environment.

Now we register all our axioms to our global environment. This way, a
lookup operation on the global scope will yield proper values.

First, we define a macro which uses =bel_env_push= to modify the =globe=
environment variable. This macro just takes a =SYMSTR=, turns it into a
symbol, and generates a new environment, which is then assigned to the
global environment.

#+begin_src C
#define BEL_ENV_GLOBAL_PUSH(SYMSTR, VAL)           \
    (bel_g_globe =                                 \
     bel_env_push(bel_g_globe,                     \
                  bel_mksymbol(SYMSTR), VAL))
#+end_src

Initializing the global environment involves pushing certain values to
it. But the dynamic and lexical environments are initialized to =nil=.

#+begin_src C
void
bel_init_ax_env(void)
{
    bel_g_globe = bel_g_nil;
    bel_g_dynae = bel_g_nil;
    bel_g_scope = bel_g_nil; // TODO: is this really necessary?
    
    BEL_ENV_GLOBAL_PUSH("chars", bel_g_chars);
    BEL_ENV_GLOBAL_PUSH("ins",   bel_g_ins);
    BEL_ENV_GLOBAL_PUSH("outs",  bel_g_outs);
}
#+end_src

Then, we create a lookup function. This function traverses an
environment in linear time, so it is not fast, but it does its job. A
lookup process either returns the associated value or returns =nil=.

#+begin_src C
Bel*
bel_env_lookup(Bel *env, Bel *sym)
{
    if(bel_nilp(env)) {
        return bel_g_nil;
    }
    
    if(!bel_symbolp(sym)) {
        return bel_mkerror(
            bel_mkstring("Cannot perform lookup of ~a, "
                         "which is not a symbol."),
            bel_mkpair(sym, bel_g_nil));
    }

    Bel *itr = env;
    while(!bel_nilp(itr)) {
        Bel *p = bel_car(itr);
        if(bel_car(p)->type == BEL_SYMBOL
           && bel_car(p)->sym == sym->sym) {
            return bel_cdr(p);
        }
        
        itr = bel_cdr(itr);
    }
    return bel_g_nil;
}
#+end_src

We also implement a proper lookup function which takes a lexical
environment and a symbol. The function traverses all environments in
order (lexical, dynamic, global) to find the associated value of the
given symbol. If the symbol is not found, returns an error.

#+begin_src C
Bel*
bel_lookup(Bel *lenv, Bel *sym)
{
    Bel *value;

    // Lexical scope lookup
    value = bel_env_lookup(lenv, sym);
    if(!bel_nilp(value)) {
        return value;
    }

    // Dynamic scope lookup
    value = bel_env_lookup(bel_g_dynae, sym);
    if(!bel_nilp(value)) {
        return value;
    }

    // Global scope lookup
    value = bel_env_lookup(bel_g_globe, sym);
    if(bel_nilp(value)) {
        return bel_mkerror(
            bel_mkstring("The symbol ~a is unbound."),
            bel_mkpair(sym, bel_g_nil));
    }

    return value;
}
#+end_src

Another thing to do is enable assignment. We begin by creating a
function which finds a specific symbol on a specific environment and
replaces its value by the given one. On success, it returns the
symbol; on failure, it returns =nil=. If the environment is empty, we
also return =nil=. Oh, we also don't check if the given symbol is really
a symbol, since this is an internal function.

#+begin_src C
Bel*
bel_env_replace_val(Bel *env, Bel *sym, Bel *new_val)
{
    if(bel_nilp(env)) {
        return bel_g_nil;
    }
    
    Bel *itr = env;
    while(!bel_nilp(itr)) {
        Bel *p = bel_car(itr);
        if(bel_idp(sym, bel_car(p))) {
            p->pair->cdr = new_val;
            return sym;
        }
        itr = bel_cdr(itr);
    }
    return bel_g_nil;
}
#+end_src

We also need a function which takes the reference to an environment
and a symbol, and /unbinds/ that symbol from the value in the
environment. This can be achieved by simply iterating over the list
and "unlinking" the relevant pair. We also don't perform all the
checks on this internal function.

This function might modify the environment passed as reference by
argument. We only return a non-nil answer (which is the same
environment, but modified) if and only if the unbinding was
successful.

#+begin_src C
Bel*
bel_env_unbind(Bel **env, Bel *sym)
{
    if(bel_nilp(*env)) {
        return bel_g_nil;
    }
    
    // If first element is a match, return
    // cdr of environment
    if(bel_idp(bel_car(bel_car(*env)), sym)) {
        ,*env = bel_cdr(*env);
        return bel_g_t;
    }

    // Iterate looking at the next element always.
    // If next element is a match, set current cdr
    // to cdr of next element
    Bel *itr = *env;
    while(!bel_nilp(bel_cdr(itr))) {
        Bel *p = bel_car(bel_cdr(itr));
        if(bel_idp(bel_car(p), sym)) {
            itr->pair->cdr = p->pair->cdr;
            return bel_g_t;
        }
        
        itr = bel_cdr(itr);
    }

    // On no substitution, return nil
    return bel_g_nil;
}
#+end_src

The assignment operation itself respects the hierarchy of
environments, to be described in the next subsection. We attempt to
make an assignment on the three kinds of environment (lexical -- given
as argument --, dynamic and global). If the assignment fails in any of
these, the symbol is bound to the given new value, on the /global/
environment.

#+begin_src C
Bel*
bel_assign(Bel *lenv, Bel *sym, Bel *new_val)
{
    Bel *ret;

    // Lexical assignment
    ret = bel_env_replace_val(lenv, sym, new_val);
    if(!bel_nilp(ret)) return sym;

    // Dynamic assignment
    ret = bel_env_replace_val(bel_g_dynae, sym, new_val);
    if(!bel_nilp(ret)) return sym;

    // Global assignment
    ret = bel_env_replace_val(bel_g_globe, sym, new_val);
    if(!bel_nilp(ret)) return sym;

    // When not assignment was made, we push a global value
    // TODO: We might need a proper warning API
    puts("WARNING: Assignment failed, registering new global");
    bel_g_globe = bel_env_push(bel_g_globe, sym, new_val);
    return sym;
}
#+end_src

We proceed by the same principle for the actual unbinding function: we
respect the hierarchy of environments. Like =bel_env_unbind=, this
function might modify the passed environment, and that is why we take
a reference to it.

#+begin_src C
Bel*
bel_unbind(Bel **lenv, Bel *sym)
{
    Bel *ans;

    // Lexical unbinding
    ans = bel_env_unbind(lenv, sym);
    if(!bel_nilp(ans)) {
        return sym;
    }

    // Dynamic unbinding
    ans = bel_env_unbind(&bel_g_dynae, sym);
    if(!bel_nilp(ans)) {
        return sym;
    }

    // Global unbinding
    ans = bel_env_unbind(&bel_g_globe, sym);
    if(!bel_nilp(ans)) {
        return sym;
    }

    // On no unbinding, return nil
    return bel_g_nil;
}
#+end_src

*** Types and hierarchy of environments

There are three kinds of environments in Bel: Global, Dynamic and
Lexical. The global environment (=bel_g_globe=, =globe=) contains symbols
which are always visible from all scopes. This environment lives for
the lifetime of the interpreter.

The dynamic environment (=bel_g_dynae=) is like the global environment
on its regards to access (symbols are visible to the whole
application). However, the dynamic environment lives for a short
period of time, linked to the scope it is used.

The lexical environment (=bel_g_scope=, =scope=) contains symbols which
are visible only inside the current scope, and lives for a short
period of time, linked to its scope. It is the environment captured by
closures, and also the environment created when a closure is applied
(as a specific symbol is bound to evaluate a closure's body).

*** Environment extension and capturing

Being a sequential list of pairs, where the values are pushed to their
top, environments (such as the lexical) can share symbols. For
example, suppose the following closure called =orig-fun=.

#+begin_example lisp
(def orig-fun
  (fn (x y)
    (join (new-fun x) y)))
#+end_example

Suppose further that this closure is applied to the symbols =foo= and
=bar=. They are then bound respectively to =x= and =y=. The closure's
lexical environment during application would look like this:

#+begin_example lisp
((y . bar)  (x . foo))
#+end_example

Suppose also that the closure =new-fun= is defined like this:

#+begin_example lisp
(def new-fun
  (fn (x)
    (id x 'foo)))
#+end_example

When =new-fun= is applied inside =orig-fun=, it captures =orig-fun='s
lexical environment. Additionally, =new-fun= binds =foo= (associated with
the original =x= symbol) to a new =x= symbol. So =new-fun='s lexical
environment looks like this:

#+begin_example lisp
((x . foo)  (y . bar)  (x . foo))
#+end_example

Since the environment stacks up definitions, a lookup process begins
at top (here displayed as the leftmost pair) and finds the first
binding of the requested symbol that it can find. So in =new-fun=, the
value associated to the symbol =x= can only be the first pair
represented above; however, after the evaluation of =new-fun=, back at
=orig-fun=, the associated value of =x= would be the last pair.

Another interesting fact is that, if =new-fun= were to make a blind
assignment to =y= after being called inside =orig-fun=, =y='s associated
value would be changed in =orig-fun='s lexical environment, so the
new value of =y= would be seen not only at =new-fun=; it would still be
different when we returned to =orig-fun=.

If =new-fun= were called from outside =orig-fun= (more specifically, at
top level), such assignment to =y= would create a new binding on the
global environment, effectively creating a new global variable.

** Literals

Although literals have already been seen on error implementation, but
here we reuse the concept to generate literals that should exist on
the global environment.

A /literal/ is a list, where the first element is the symbol
=lit=. Literals are described like persistent quotes, since evaluating a
quoted form strips away the quoting. A /literal/ is what should be used
to describe things that evaluate to themselves.

Literals follow the form =(lit . rest)=, where =lit= is a symbol, and =rest=
is a proper list of things that should be treated as a literal.

Primitives and functions are internally described as /literals/.

The first thing to do is create a tool for generating a literal; in
general, what it does is create a pair, where the /car/ is the symbol
=lit=, and the /cdr/ is anything that should be treated as a literal.

#+begin_src C
Bel*
bel_mkliteral(Bel *rest)
{
    if(!bel_proper_list_p(rest)) {
        return bel_mkerror(
            bel_mkstring("The object ~a is not a "
                         "proper list to be turned "
                         "into a literal."),
            bel_mkpair(rest, bel_g_nil));
    }

    return bel_mkpair(bel_mksymbol("lit"),
                      rest);
}
#+end_src

*** Primitives

As stated above, primitives are represented as literals, since they
evaluate to themselves. We start by defining a tool to create a
certain primitive; it should be noted that, since primitives are
internal to the Bel implementation, this function does not check for
errors.

A primitive has the form =(lit prim name)=, where =lit= and =prim= are
constant symbols, and =name= is a symbol for the primitive name.

#+begin_src C
Bel*
bel_mkprim(Bel *sym)
{
    return bel_mkliteral(
        bel_mkpair(bel_g_prim,
                   bel_mkpair(sym, bel_g_nil)));
}
#+end_src

The next definition is a macro where, given an environment =env= and a
C string literal =x=, it generates a primitive por =x= and pushes it to
the enviroment =env=.

#+begin_src C
#define BEL_REGISTER_PRIM(env, x)               \
    {                                           \
    Bel *sym = bel_mksymbol(x);                 \
    env = bel_env_push(env, sym,                \
                       bel_mkprim(sym));        \
    }
#+end_src

Then we create a function where, given an environment =env=, it
registers all Bel primitives on it, creating a new environment which
is returned. Notice that this new environment is in fact making use of
the original one.

#+begin_src C
Bel*
bel_gen_primitives(Bel *env)
{
    // Primitive functions
    BEL_REGISTER_PRIM(env, "id");
    BEL_REGISTER_PRIM(env, "join");
    BEL_REGISTER_PRIM(env, "car");
    BEL_REGISTER_PRIM(env, "cdr");
    BEL_REGISTER_PRIM(env, "type");
    BEL_REGISTER_PRIM(env, "xar");
    BEL_REGISTER_PRIM(env, "xdr");
    BEL_REGISTER_PRIM(env, "sym");
    BEL_REGISTER_PRIM(env, "nom");
    BEL_REGISTER_PRIM(env, "wrb");
    BEL_REGISTER_PRIM(env, "rdb");
    BEL_REGISTER_PRIM(env, "ops");
    BEL_REGISTER_PRIM(env, "cls");
    BEL_REGISTER_PRIM(env, "stat");
    BEL_REGISTER_PRIM(env, "coin");
    BEL_REGISTER_PRIM(env, "sys");

    // Primitive operators
    BEL_REGISTER_PRIM(env, "+");
    BEL_REGISTER_PRIM(env, "-");
    BEL_REGISTER_PRIM(env, "*");
    BEL_REGISTER_PRIM(env, "/");
    BEL_REGISTER_PRIM(env, "<");
    BEL_REGISTER_PRIM(env, "<=");
    BEL_REGISTER_PRIM(env, ">");
    BEL_REGISTER_PRIM(env, ">=");
    BEL_REGISTER_PRIM(env, "=");

    // Other primitives
    BEL_REGISTER_PRIM(env, "err");
    
    return env;
}
#+end_src

The last step is to have a function which pushes these primitives
automatically to the =globe= environment.

#+begin_src C
void
bel_init_ax_primitives()
{
    bel_g_globe = bel_gen_primitives(bel_g_globe);
}
#+end_src

* Debug

Below we define some very simple debug functions, which will help us
show data on screen.

** Printing pairs

The first function is a specialization for printing pairs in
general. This function should also handle the printing of lists
gracefully.

#+begin_src C
void bel_dbg_print(Bel*); // Forward declaration

void
bel_dbg_print_pair(Bel *obj)
{
    if(bel_nilp(obj)) return;
    
    Bel *itr = obj;
    
    putchar('(');
    while(!bel_nilp(itr)) {
        Bel *car = bel_car(itr);
        Bel *cdr = bel_cdr(itr);

        bel_dbg_print(car);
        
        if(bel_nilp(cdr)) {
            break;
        } else if(cdr->type != BEL_PAIR) {
            putchar(' ');
            putchar('.');
            putchar(' ');
            bel_dbg_print(cdr);
            break;
        }
        putchar(' ');
        itr = cdr;
    }
    putchar(')');
}
#+end_src

** Printing strings

#+begin_src C
void
bel_dbg_print_string(Bel *obj)
{
    putchar('\"');
    Bel *itr = obj;
    while(!bel_nilp(itr)) {
        Bel_char c = bel_car(itr)->chr;

        switch(c) {
        case '\a': printf("\\bel"); break;
        default:   putchar(c);      break;
        }

        itr = bel_cdr(itr);
    }
    putchar('\"');
}
#+end_src

** Printing data types

The next function handles the printing of any data type. Notice that
it does not automatically print a newline character.

#+begin_src C
void
bel_dbg_print(Bel *obj)
{
    switch(obj->type) {
    case BEL_SYMBOL:
        printf("%s", g_sym_table.tbl[obj->sym]);
        break;
    case BEL_PAIR:
        if(!bel_stringp(obj)) {
            bel_dbg_print_pair(obj);
        } else {
            bel_dbg_print_string(obj);
        }
        break;
    case BEL_CHAR:
        if(obj->chr == '\a')
            printf("\\bel"); // There is no Bel without \bel
        else printf("\\%c", obj->chr);
        break;
    case BEL_STREAM: printf("<stream>");         break;
    default:         printf("???");              break; // wat
    };
}
#+end_src

** Tests

*** String manipulation and printing

A string test which shows the conversion between C strings and Bel
strings, and vice-versa.

#+begin_src C
void
string_test()
{
    Bel *bel  = bel_mkstring("Hello, Bel!");
    bel_dbg_print(bel);
    printf(" => %s\n", bel_cstring(bel));

    bel = bel_mkstring("There is no Bel without \a");
    bel_dbg_print(bel);
    putchar(10);
}
#+end_src

*** List/pair/dotted list notation

The following notation tests the printing capabilities of the list
printing algorithm. Should be able to handle printing lists and
dot-notation when necessary.

The data input reads as =((foo . bar) . (baz . quux))=, but the expected
output is =((foo . bar) baz . quux)=.

#+begin_src C
void
notation_test()
{
    Bel*
    bel = bel_mkpair(bel_mkpair(bel_mksymbol("foo"),
                                bel_mksymbol("bar")),
                     bel_mkpair(bel_mksymbol("baz"),
                                bel_mksymbol("quux")));
    bel_dbg_print(bel);
    putchar(10);
}
#+end_src

*** Proper list notation

This next test outputs the list =(The quick brown fox jumps over the
lazy dog)=, which is a proper list of symbols.

#+begin_src C
void
list_test()
{
    Bel*
    bel = bel_mkpair(
        bel_mksymbol("The"),
        bel_mkpair(
            bel_mksymbol("quick"),
            bel_mkpair(
                bel_mksymbol("brown"),
                bel_mkpair(
                    bel_mksymbol("fox"),
                    bel_mkpair(
                        bel_mksymbol("jumps"),
                        bel_mkpair(
                            bel_mksymbol("over"),
                            bel_mkpair(
                                bel_mksymbol("the"),
                                bel_mkpair(
                                    bel_mksymbol("lazy"),
                                    bel_mkpair(
                                        bel_mksymbol("dog"),
                                        bel_g_nil)))))))));
    bel_dbg_print(bel);
    putchar(10);
}
#+end_src

*** Closure representation

This test is also a list of symbols, but with nested lists also. Plus,
this is a proper list, representing the internal representation of a
closure such as =(fn (x) (* x x))=. Expected output is =(lit clo nil (x)
(* x x))=.

#+begin_src C
void
closure_repr_test()
{
    Bel*
    bel = bel_mkpair(bel_mksymbol("lit"),
                     bel_mkpair(
                         bel_mksymbol("clo"),
                         bel_mkpair(
                             bel_g_nil,
                             bel_mkpair(
                                 bel_mkpair(bel_mksymbol("x"),
                                            bel_g_nil),
                                 bel_mkpair(
                                     bel_mkpair(
                                         bel_mksymbol("*"),
                                         bel_mkpair(
                                             bel_mksymbol("x"),
                                             bel_mkpair(
                                                 bel_mksymbol("x"),
                                                 bel_g_nil))),
                                     bel_g_nil)))));
    bel_dbg_print(bel);
    putchar(10);
}
#+end_src

*** Character list printing and environment lookup

This next test prints the first ten characters in the global =chars=,
which is a list of pairs, each pair =(c . d)= containing a character =c=,
and its string representation in binary =d=.

It is also interesting to notice that the =chars= global is obtained by
a lookup operation on the environment, rather than using the global
variable directly.

#+begin_src C
void
character_list_test()
{
    // Character list
    // Char: 000 (?) => "00000000"
    // Char: 001 (?) => "00000001"
    // etc
    const int first_char = 'a';
    
    Bel *bel = bel_env_lookup(bel_g_globe, bel_mksymbol("chars"));
    
    int i;

    // Get nth cdr
    for(i = 0; i < first_char; i++) {
        bel = bel_cdr(bel);
    }

    i = 'a';
    while(!bel_nilp(bel) && i < first_char + 10) {
        Bel *car = bel_car(bel);
        printf("Char: %03d (%c) => ",
               bel_car(car)->chr,
               ((Bel_char)i));
        bel_dbg_print(bel_cdr(car));
        putchar(10);
        bel = bel_cdr(bel);
        i++;
    }
}
#+end_src

*** Read file bit by bit

This test opens up the Believe C source code file as a read stream,
using Bel's stream structure, then proceeds to read ten bytes from it
(meaning that it will read 80 bits). Every eight bit will be stored in
a Bel list and then converted to a proper Bel character, which will be
displayed on screen along with its bits.

It is interesting to notice that, since the bit-reading operation
itself returns characters =\0= or =\1=, the bit list composing a character
is always a Bel string.

#+begin_src C
void
read_file_test()
{
    // We are going to read ten bytes from Bel's
    // own source code file.
    Bel *file = bel_mkstream("believe.c", BEL_STREAM_READ);

    if(bel_errorp(file)) {
        bel_dbg_print(file);
        return;
    }
    
    int n_bytes = 10;
    while(n_bytes > 0) {
        // 1 byte = 8 bits, so we make a list of
        // eight characters
        Bel **char_nodes = GC_MALLOC(8 * sizeof(Bel*));

        int i;
        for(i = 0; i < 8; i++) {
            Bel *read_char =
                bel_stream_read_bit(&file->stream);
            char_nodes[i] = bel_mkpair(read_char, bel_g_nil);
        }

        // Link nodes
        for(i = 0; i < 7; i++) {
            char_nodes[i]->pair->cdr = char_nodes[i + 1];
        }

        // Display on screen
        bel_dbg_print(char_nodes[0]);
        printf(" => ");
        bel_dbg_print(
            bel_char_from_binary(char_nodes[0]));
        putchar(10);
        
        n_bytes--;
    }

    bel_stream_close(file);
}
#+end_src

*** Display errors

We generate a few errors and grab them, then we print these errors on
screen to show their literal structure.

#+begin_src C
void
show_errors_test()
{
    Bel *err;
    
    // Unexisting file
    err = bel_mkstream("waddawaddawadda", BEL_STREAM_READ);
    bel_dbg_print(err);
    putchar(10);
    printf("Is this an error? %c\n",
           bel_errorp(err) ? 'y' : 'n');

    // Incorrect use of car and cdr
    err = bel_car(bel_g_t);
    bel_dbg_print(err); putchar(10);
    err = bel_cdr(bel_g_t);
    bel_dbg_print(err); putchar(10);

    // Incorrect generation of Bel character from binary
    /* Bel *str = bel_mkstring("110"); */
    /* err = bel_char_from_binary(str); */
    /* bel_dbg_print(err); putchar(10); */

    /* str = bel_mkstring("110a1101"); */
    /* err = bel_char_from_binary(str); */
    /* bel_dbg_print(err); putchar(10); */
}
#+end_src

*** Lookup primitives

We look up a few registered primitives in the global environment, and
print them in their literal form.

#+begin_src C
void
lookup_primitives_test()
{
    Bel *bel;
    bel = bel_lookup(bel_g_nil, bel_mksymbol("car"));
    bel_dbg_print(bel);
    putchar(10);

    bel = bel_lookup(bel_g_nil, bel_mksymbol("cdr"));
    bel_dbg_print(bel);
    putchar(10);

    bel = bel_lookup(bel_g_nil, bel_mksymbol("coin"));
    bel_dbg_print(bel);
    putchar(10);
    
    bel = bel_lookup(bel_g_nil, bel_mksymbol("stat"));
    bel_dbg_print(bel);
    putchar(10);

    // Undefined primitive
    bel_dbg_print(bel_g_nil); putchar(10);
    bel = bel_lookup(bel_g_nil, bel_mksymbol("wadawada"));
    bel_dbg_print(bel);
    putchar(10);
}
#+end_src

*** Environment tests

The first test involves creating a temporary lexical environment,
pushing a few literals, assigning values, unbinding values too.

#+begin_src C
void
lexical_environment_test()
{
    Bel *lexenv = bel_g_nil;
    Bel *ret;

    puts("    -- Registering local `foo`");
    lexenv = bel_env_push(lexenv,
                          bel_mksymbol("foo"),
                          bel_mksymbol("bar"));
    
    printf("Environment:       ");
    bel_dbg_print(lexenv);
    printf("\nLookup:            ");
    bel_dbg_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    putchar(10); putchar(10);

    // Assignment
    puts("    -- Assigning new value to `foo`");
    ret =
        bel_assign(lexenv,
                   bel_mksymbol("foo"),
                   bel_mkliteral(bel_mkpair(bel_mksymbol("baz"),
                                            bel_g_nil)));

    printf("Environment:       ");
    bel_dbg_print(lexenv);
    printf("\nAssignment result: ");
    bel_dbg_print(ret);
    printf("\nLookup:            ");
    bel_dbg_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    putchar(10); putchar(10);

    // Unbinding
    puts("    -- Unbinding `foo`");
    ret = bel_unbind(&lexenv, bel_mksymbol("foo"));
    
    printf("Environment:       ");
    bel_dbg_print(lexenv);
    printf("\nUnbinding result:  ");
    bel_dbg_print(ret);
    printf("\nLookup:            ");
    bel_dbg_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    putchar(10);
}
#+end_src

Second test is creating a global variable through assignment, creating
a variable bound to the same symbol on a lexical environment,
unbinding both, then performing a last invalid unbinding.

#+begin_src C
void
global_assignment_test()
{
    Bel *lexenv = bel_g_nil;
    Bel *ret;

    // Global creation through assignment
    puts("    -- Assigning `foo` without previous definition");
    ret = bel_assign(bel_g_nil,
                     bel_mksymbol("foo"),
                     bel_mksymbol("bar"));

    printf("Assignment result: ");
    bel_dbg_print(ret);
    printf("\nLookup:            ");
    bel_dbg_print(bel_lookup(bel_g_nil, bel_mksymbol("foo")));
    putchar(10); putchar(10);

    // Local creation of variable bound to
    // same symbol
    puts("    -- Shadowing global `foo` with a local");
    lexenv =
        bel_env_push(lexenv,
                     bel_mksymbol("foo"),
                     bel_mksymbol("quux"));

    printf("Environment:       ");
    bel_dbg_print(lexenv);
    printf("\nLookup:            ");
    bel_dbg_print(bel_lookup(lexenv, bel_mksymbol("foo")));

    // Three unbindings
    printf("\n    -- Unbinding `foo` three times");
    int i;
    for(i = 0; i < 3; i++) {
        ret = bel_unbind(&lexenv, bel_mksymbol("foo"));

        printf("\n\nEnvironment:       ");
        bel_dbg_print(lexenv);
        printf("\nUnbinding result:  ");
        bel_dbg_print(ret);
        printf("\nLookup:            ");
        bel_dbg_print(bel_lookup(lexenv, bel_mksymbol("foo")));
    }
    putchar(10);
}
#+end_src

* Entry point
** Initialization

This is the initialization function for the Bel interpreter. Once this
function is called, the Bel system is ready to be used.

#+begin_src C
Bel*
bel_init(void)
{
    GC_INIT();
    bel_sym_table_init();

    // Axioms
    bel_init_ax_vars();
    bel_init_ax_chars();
    bel_init_streams();
    bel_init_ax_env();
    bel_init_ax_primitives();

    // TODO: Return an environment?
    return bel_g_nil;
}
#+end_src

** Tests

This is the entry point for tests. All running tests are to be put
here.

#+begin_src C
void
run_tests()
{
    puts("-- Running debug tests");
    puts("  -- String test");
    string_test();
    puts("  -- Notation test");
    notation_test();
    puts("  -- List test");
    list_test();
    puts("  -- Closure representation test");
    closure_repr_test();
    puts("  -- Character List & Lookup test");
    character_list_test();
    puts("  -- Read five bytes from Believe's source");
    read_file_test();
    puts("  -- Show a few errors on screen");
    show_errors_test();
    puts("  -- Lookup a few primitives and print them");
    lookup_primitives_test();
    puts("  -- Lexical environment tests");
    lexical_environment_test();
    puts("  -- Globals and assignment tests");
    global_assignment_test();
}
#+end_src

** =main= function

This is the program entry point. It is supposed to only print the
ribbon, initialize Bel and perform some tests, for now.

#+begin_src C
int
main(void)
{
    printf("Believe %s\n", BELIEVE_VERSION);
    printf("A Bel Lisp interpreter\n");
    printf("Copyright (c) %s\n", BELIEVE_COPYRIGHT);
    printf("This software is distributed under the %s license.\n",
          BELIEVE_LICENSE);

    bel_init();

    run_tests();
    
    return 0;
}
#+end_src

